{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"resolvable.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/utils/resolvable.ts"],"sourcesContent":["// Copyright 2019 Joseph Gentle\n\n// Permission to use, copy, modify, and / or distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n// FITNESS.IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n//   INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n// LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n// OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n// PERFORMANCE OF THIS SOFTWARE.\n\nexport type Resolvable<T> = Promise<T> & {\n  resolve: (t: T) => void;\n  reject: (e: any) => void;\n};\n\nexport default <T = void>(): Resolvable<T> => {\n  let resolve: (val: T) => void;\n  let reject: (err: any) => void;\n  const promise = new Promise<T>((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  }) as Resolvable<T>;\n  promise.resolve = resolve!;\n  promise.reject = reject!;\n  return promise;\n};\n"],"names":[],"mappings":";;;uCAmBe,GAA4B,EAAE;IAC3C,IAAI,OAAyB,CAAC;IAC9B,IAAI,MAA0B,CAAC;IAC/B,MAAM,OAAO,GAAG,IAAI,OAAO,CAAI,CAAC,QAAQ,EAAE,OAAO,EAAE,EAAE;QACnD,OAAO,GAAG,QAAQ,CAAC;QACnB,MAAM,GAAG,OAAO,CAAC;IACnB,CAAC,CAAkB,CAAC;IACpB,OAAO,CAAC,OAAO,GAAG,OAAQ,CAAC;IAC3B,OAAO,CAAC,MAAM,GAAG,MAAO,CAAC;IACzB,OAAO,OAAO,CAAC;AACjB,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 22, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"file":"cachePolicy.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/cachePolicy.ts"],"sourcesContent":["import type { CacheHint, CachePolicy } from '@apollo/cache-control-types';\n\nexport function newCachePolicy(): CachePolicy {\n  return {\n    maxAge: undefined,\n    scope: undefined,\n    restrict(hint: CacheHint) {\n      if (\n        hint.maxAge !== undefined &&\n        (this.maxAge === undefined || hint.maxAge < this.maxAge)\n      ) {\n        this.maxAge = hint.maxAge;\n      }\n      if (hint.scope !== undefined && this.scope !== 'PRIVATE') {\n        this.scope = hint.scope;\n      }\n    },\n    replace(hint: CacheHint) {\n      if (hint.maxAge !== undefined) {\n        this.maxAge = hint.maxAge;\n      }\n      if (hint.scope !== undefined) {\n        this.scope = hint.scope;\n      }\n    },\n    policyIfCacheable() {\n      if (this.maxAge === undefined || this.maxAge === 0) {\n        return null;\n      }\n      return { maxAge: this.maxAge, scope: this.scope ?? 'PUBLIC' };\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAEM,SAAU,cAAc;IAC5B,OAAO;QACL,MAAM,EAAE,SAAS;QACjB,KAAK,EAAE,SAAS;QAChB,QAAQ,EAAC,IAAe;YACtB,IACE,IAAI,CAAC,MAAM,KAAK,SAAS,IACzB,CAAC,IAAI,CAAC,MAAM,KAAK,SAAS,IAAI,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,EACxD,CAAC;gBACD,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;YAC5B,CAAC;YACD,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,EAAE,CAAC;gBACzD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;YAC1B,CAAC;QACH,CAAC;QACD,OAAO,EAAC,IAAe;YACrB,IAAI,IAAI,CAAC,MAAM,KAAK,SAAS,EAAE,CAAC;gBAC9B,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;YAC5B,CAAC;YACD,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,EAAE,CAAC;gBAC7B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;YAC1B,CAAC;QACH,CAAC;QACD,iBAAiB;YACf,IAAI,IAAI,CAAC,MAAM,KAAK,SAAS,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;gBACnD,OAAO,IAAI,CAAC;YACd,CAAC;YACD,OAAO;gBAAE,MAAM,EAAE,IAAI,CAAC,MAAM;gBAAE,KAAK,EAAE,IAAI,CAAC,KAAK,IAAI,QAAQ;YAAA,CAAE,CAAC;QAChE,CAAC;KACF,CAAC;AACJ,CAAC","ignoreList":[0]}},
    {"offset": {"line": 62, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"file":"determineApolloConfig.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/determineApolloConfig.ts"],"sourcesContent":["import { createHash } from '@apollo/utils.createhash';\nimport type { ApolloConfig, ApolloConfigInput } from './externalTypes/index.js';\nimport type { Logger } from '@apollo/utils.logger';\n\n// This function combines the `apollo` constructor argument and some environment\n// variables to come up with a full ApolloConfig.\nexport function determineApolloConfig(\n  input: ApolloConfigInput | undefined,\n  logger: Logger,\n): ApolloConfig {\n  const apolloConfig: ApolloConfig = {};\n\n  const {\n    APOLLO_KEY,\n    APOLLO_GRAPH_REF,\n    APOLLO_GRAPH_ID,\n    APOLLO_GRAPH_VARIANT,\n  } = process.env;\n\n  // Determine key.\n  if (input?.key) {\n    apolloConfig.key = input.key.trim();\n  } else if (APOLLO_KEY) {\n    apolloConfig.key = APOLLO_KEY.trim();\n  }\n  if ((input?.key ?? APOLLO_KEY) !== apolloConfig.key) {\n    logger.warn(\n      'The provided API key has unexpected leading or trailing whitespace. ' +\n        'Apollo Server will trim the key value before use.',\n    );\n  }\n\n  // Assert API key is a valid header value, since it's going to be used as one\n  // throughout.\n  if (apolloConfig.key) {\n    assertValidHeaderValue(apolloConfig.key);\n  }\n\n  // Determine key hash.\n  if (apolloConfig.key) {\n    apolloConfig.keyHash = createHash('sha512')\n      .update(apolloConfig.key)\n      .digest('hex');\n  }\n\n  // Determine graph ref, if provided together.\n  if (input?.graphRef) {\n    apolloConfig.graphRef = input.graphRef;\n  } else if (APOLLO_GRAPH_REF) {\n    apolloConfig.graphRef = APOLLO_GRAPH_REF;\n  }\n\n  // See if graph ID and variant were provided separately.\n  const graphId = input?.graphId ?? APOLLO_GRAPH_ID;\n  const graphVariant = input?.graphVariant ?? APOLLO_GRAPH_VARIANT;\n\n  if (apolloConfig.graphRef) {\n    if (graphId) {\n      throw new Error(\n        'Cannot specify both graph ref and graph ID. Please use ' +\n          '`apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph ID.',\n      );\n    }\n    if (graphVariant) {\n      throw new Error(\n        'Cannot specify both graph ref and graph variant. Please use ' +\n          '`apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph variant.',\n      );\n    }\n  } else if (graphId) {\n    // Graph ref is not specified, but the ID is. We can construct the ref\n    // from the ID and variant. Note that after this, we stop tracking the ID\n    // and variant, because Apollo Server 3 does not assume that all graph refs\n    // can be decomposed into ID and variant (except in the op reg plugin).\n    apolloConfig.graphRef = graphVariant\n      ? `${graphId}@${graphVariant}`\n      : graphId;\n  }\n\n  return apolloConfig;\n}\n\nfunction assertValidHeaderValue(value: string) {\n  // Ref: node-fetch@2.x `Headers` validation\n  // https://github.com/node-fetch/node-fetch/blob/9b9d45881e5ca68757077726b3c0ecf8fdca1f29/src/headers.js#L18\n  const invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/g;\n  if (invalidHeaderCharRegex.test(value)) {\n    const invalidChars = value.match(invalidHeaderCharRegex)!;\n    throw new Error(\n      `The API key provided to Apollo Server contains characters which are invalid as HTTP header values. The following characters found in the key are invalid: ${invalidChars.join(\n        ', ',\n      )}. Valid header values may only contain ASCII visible characters. If you think there is an issue with your key, please contact Apollo support.`,\n    );\n  }\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,0BAA0B,CAAC;;AAMhD,SAAU,qBAAqB,CACnC,KAAoC,EACpC,MAAc;IAEd,MAAM,YAAY,GAAiB,CAAA,CAAE,CAAC;IAEtC,MAAM,EACJ,UAAU,EACV,gBAAgB,EAChB,eAAe,EACf,oBAAoB,EACrB,GAAG,OAAO,CAAC,GAAG,CAAC;IAGhB,IAAI,KAAK,EAAE,GAAG,EAAE,CAAC;QACf,YAAY,CAAC,GAAG,GAAG,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC;IACtC,CAAC,MAAM,IAAI,UAAU,EAAE,CAAC;QACtB,YAAY,CAAC,GAAG,GAAG,UAAU,CAAC,IAAI,EAAE,CAAC;IACvC,CAAC;IACD,IAAI,CAAC,KAAK,EAAE,GAAG,IAAI,UAAU,CAAC,KAAK,YAAY,CAAC,GAAG,EAAE,CAAC;QACpD,MAAM,CAAC,IAAI,CACT,sEAAsE,GACpE,mDAAmD,CACtD,CAAC;IACJ,CAAC;IAID,IAAI,YAAY,CAAC,GAAG,EAAE,CAAC;QACrB,sBAAsB,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC;IAC3C,CAAC;IAGD,IAAI,YAAY,CAAC,GAAG,EAAE,CAAC;QACrB,YAAY,CAAC,OAAO,0KAAG,aAAA,AAAU,EAAC,QAAQ,CAAC,CACxC,MAAM,CAAC,YAAY,CAAC,GAAG,CAAC,CACxB,MAAM,CAAC,KAAK,CAAC,CAAC;IACnB,CAAC;IAGD,IAAI,KAAK,EAAE,QAAQ,EAAE,CAAC;QACpB,YAAY,CAAC,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC;IACzC,CAAC,MAAM,IAAI,gBAAgB,EAAE,CAAC;QAC5B,YAAY,CAAC,QAAQ,GAAG,gBAAgB,CAAC;IAC3C,CAAC;IAGD,MAAM,OAAO,GAAG,KAAK,EAAE,OAAO,IAAI,eAAe,CAAC;IAClD,MAAM,YAAY,GAAG,KAAK,EAAE,YAAY,IAAI,oBAAoB,CAAC;IAEjE,IAAI,YAAY,CAAC,QAAQ,EAAE,CAAC;QAC1B,IAAI,OAAO,EAAE,CAAC;YACZ,MAAM,IAAI,KAAK,CACb,yDAAyD,GACvD,4EAA4E,CAC/E,CAAC;QACJ,CAAC;QACD,IAAI,YAAY,EAAE,CAAC;YACjB,MAAM,IAAI,KAAK,CACb,8DAA8D,GAC5D,iFAAiF,CACpF,CAAC;QACJ,CAAC;IACH,CAAC,MAAM,IAAI,OAAO,EAAE,CAAC;QAKnB,YAAY,CAAC,QAAQ,GAAG,YAAY,GAChC,GAAG,OAAO,CAAA,CAAA,EAAI,YAAY,EAAE,GAC5B,OAAO,CAAC;IACd,CAAC;IAED,OAAO,YAAY,CAAC;AACtB,CAAC;AAED,SAAS,sBAAsB,CAAC,KAAa;IAG3C,MAAM,sBAAsB,GAAG,0BAA0B,CAAC;IAC1D,IAAI,sBAAsB,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;QACvC,MAAM,YAAY,GAAG,KAAK,CAAC,KAAK,CAAC,sBAAsB,CAAE,CAAC;QAC1D,MAAM,IAAI,KAAK,CACb,CAAA,0JAAA,EAA6J,YAAY,CAAC,IAAI,CAC5K,IAAI,CACL,CAAA,6IAAA,CAA+I,CACjJ,CAAC;IACJ,CAAC;AACH,CAAC","ignoreList":[0]}},
    {"offset": {"line": 116, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 122, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/errors/index.ts"],"sourcesContent":["import { GraphQLError } from 'graphql';\n\nexport enum ApolloServerErrorCode {\n  INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR',\n  GRAPHQL_PARSE_FAILED = 'GRAPHQL_PARSE_FAILED',\n  GRAPHQL_VALIDATION_FAILED = 'GRAPHQL_VALIDATION_FAILED',\n  PERSISTED_QUERY_NOT_FOUND = 'PERSISTED_QUERY_NOT_FOUND',\n  PERSISTED_QUERY_NOT_SUPPORTED = 'PERSISTED_QUERY_NOT_SUPPORTED',\n  BAD_USER_INPUT = 'BAD_USER_INPUT',\n  OPERATION_RESOLUTION_FAILURE = 'OPERATION_RESOLUTION_FAILURE',\n  BAD_REQUEST = 'BAD_REQUEST',\n}\n\nexport enum ApolloServerValidationErrorCode {\n  INTROSPECTION_DISABLED = 'INTROSPECTION_DISABLED',\n}\n\n/**\n * unwrapResolverError is a useful helper function for `formatError` hooks.\n * Errors thrown in resolvers are wrapped by graphql-js in a GraphQLError that\n * adds context such as the `path` to the field in the operation. If you'd like\n * to look directly at the original error thrown in the resolver (with whatever\n * data is on that error object, but without fields like `path`), you can use\n * this function. Note that other GraphQLErrors that contain `originalError`\n * (like parse errors) are not unwrapped by this function.\n */\nexport function unwrapResolverError(error: unknown): unknown {\n  if (error instanceof GraphQLError && error.path && error.originalError) {\n    return error.originalError;\n  }\n  return error;\n}\n"],"names":[],"mappings":";;;;;AAAA,OAAO,EAAE,YAAY,EAAE,MAAM,SAAS,CAAC;;AAEvC,IAAY,qBASX;AATD,CAAA,SAAY,qBAAqB;IAC/B,qBAAA,CAAA,wBAAA,GAAA,uBAA+C,CAAA;IAC/C,qBAAA,CAAA,uBAAA,GAAA,sBAA6C,CAAA;IAC7C,qBAAA,CAAA,4BAAA,GAAA,2BAAuD,CAAA;IACvD,qBAAA,CAAA,4BAAA,GAAA,2BAAuD,CAAA;IACvD,qBAAA,CAAA,gCAAA,GAAA,+BAA+D,CAAA;IAC/D,qBAAA,CAAA,iBAAA,GAAA,gBAAiC,CAAA;IACjC,qBAAA,CAAA,+BAAA,GAAA,8BAA6D,CAAA;IAC7D,qBAAA,CAAA,cAAA,GAAA,aAA2B,CAAA;AAC7B,CAAC,EATW,qBAAqB,IAAA,CAArB,qBAAqB,GAAA,CAAA,CAAA,GAShC;AAED,IAAY,+BAEX;AAFD,CAAA,SAAY,+BAA+B;IACzC,+BAAA,CAAA,yBAAA,GAAA,wBAAiD,CAAA;AACnD,CAAC,EAFW,+BAA+B,IAAA,CAA/B,+BAA+B,GAAA,CAAA,CAAA,GAE1C;AAWK,SAAU,mBAAmB,CAAC,KAAc;IAChD,IAAI,KAAK,gKAAY,eAAY,IAAI,KAAK,CAAC,IAAI,IAAI,KAAK,CAAC,aAAa,EAAE,CAAC;QACvE,OAAO,KAAK,CAAC,aAAa,CAAC;IAC7B,CAAC;IACD,OAAO,KAAK,CAAC;AACf,CAAC","ignoreList":[0]}},
    {"offset": {"line": 150, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 156, "column": 0}, "map": {"version":3,"file":"HeaderMap.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/utils/HeaderMap.ts"],"sourcesContent":["export class HeaderMap extends Map<string, string> {\n  // In order for TypeScript to prevent a standard `Map` from being compatible\n  // with a `HeaderMap`, we need some additional property on the class.\n  // @ts-ignore (this is just unused)\n  private __identity = Symbol('HeaderMap');\n\n  override set(key: string, value: string): this {\n    return super.set(key.toLowerCase(), value);\n  }\n\n  override get(key: string) {\n    return super.get(key.toLowerCase());\n  }\n\n  override delete(key: string) {\n    return super.delete(key.toLowerCase());\n  }\n\n  override has(key: string) {\n    return super.has(key.toLowerCase());\n  }\n}\n"],"names":[],"mappings":";;;AAAM,MAAO,SAAU,SAAQ,GAAmB;IAAlD,aAAA;;QAIU,IAAA,CAAA,UAAU,GAAG,MAAM,CAAC,WAAW,CAAC,CAAC;IAiB3C,CAAC;IAfU,GAAG,CAAC,GAAW,EAAE,KAAa,EAAA;QACrC,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,WAAW,EAAE,EAAE,KAAK,CAAC,CAAC;IAC7C,CAAC;IAEQ,GAAG,CAAC,GAAW,EAAA;QACtB,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,CAAC;IACtC,CAAC;IAEQ,MAAM,CAAC,GAAW,EAAA;QACzB,OAAO,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,CAAC;IACzC,CAAC;IAEQ,GAAG,CAAC,GAAW,EAAA;QACtB,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,CAAC;IACtC,CAAC;CACF","ignoreList":[0]}},
    {"offset": {"line": 177, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 183, "column": 0}, "map": {"version":3,"file":"internalErrorClasses.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/internalErrorClasses.ts"],"sourcesContent":["import { GraphQLError, type GraphQLErrorOptions } from 'graphql';\nimport { ApolloServerErrorCode } from './errors/index.js';\nimport { newHTTPGraphQLHead } from './runHttpQuery.js';\nimport { HeaderMap } from './utils/HeaderMap.js';\n\n// These error classes are not part of Apollo Server's external API; the\n// ApolloServerErrorCode enum is (exported from `@apollo/server/errors`).\n\nclass GraphQLErrorWithCode extends GraphQLError {\n  constructor(\n    message: string,\n    code: ApolloServerErrorCode,\n    options?: GraphQLErrorOptions,\n  ) {\n    super(message, {\n      ...options,\n      extensions: { ...options?.extensions, code },\n    });\n    this.name = this.constructor.name;\n  }\n}\n\nexport class SyntaxError extends GraphQLErrorWithCode {\n  constructor(graphqlError: GraphQLError) {\n    super(graphqlError.message, ApolloServerErrorCode.GRAPHQL_PARSE_FAILED, {\n      source: graphqlError.source,\n      positions: graphqlError.positions,\n      extensions: { http: newHTTPGraphQLHead(400), ...graphqlError.extensions },\n      originalError: graphqlError,\n    });\n  }\n}\n\nexport class ValidationError extends GraphQLErrorWithCode {\n  constructor(graphqlError: GraphQLError) {\n    super(\n      graphqlError.message,\n      ApolloServerErrorCode.GRAPHQL_VALIDATION_FAILED,\n      {\n        nodes: graphqlError.nodes,\n        extensions: {\n          http: newHTTPGraphQLHead(400),\n          ...graphqlError.extensions,\n        },\n        originalError: graphqlError.originalError ?? graphqlError,\n      },\n    );\n  }\n}\n\n// Persisted query errors (especially \"not found\") need to be uncached, because\n// hopefully we're about to fill in the APQ cache and the same request will\n// succeed next time. We also want a 200 response to avoid any error handling\n// that may mask the contents of an error response. (Otherwise, the default\n// status code for a response with `errors` but no `data` (even null) is 400.)\nconst getPersistedQueryErrorHttp = () => ({\n  status: 200,\n  headers: new HeaderMap([\n    ['cache-control', 'private, no-cache, must-revalidate'],\n  ]),\n});\n\nexport class PersistedQueryNotFoundError extends GraphQLErrorWithCode {\n  constructor() {\n    super(\n      'PersistedQueryNotFound',\n      ApolloServerErrorCode.PERSISTED_QUERY_NOT_FOUND,\n      { extensions: { http: getPersistedQueryErrorHttp() } },\n    );\n  }\n}\n\nexport class PersistedQueryNotSupportedError extends GraphQLErrorWithCode {\n  constructor() {\n    super(\n      'PersistedQueryNotSupported',\n      ApolloServerErrorCode.PERSISTED_QUERY_NOT_SUPPORTED,\n      // Not super clear why we need this to be uncached (makes sense for\n      // PersistedQueryNotFoundError, because there we're about to fill the\n      // cache and make the next copy of the same request succeed) but we've\n      // been doing it for years so :shrug:\n      { extensions: { http: getPersistedQueryErrorHttp() } },\n    );\n  }\n}\n\nexport class UserInputError extends GraphQLErrorWithCode {\n  constructor(graphqlError: GraphQLError) {\n    super(graphqlError.message, ApolloServerErrorCode.BAD_USER_INPUT, {\n      nodes: graphqlError.nodes,\n      originalError: graphqlError.originalError ?? graphqlError,\n      extensions: graphqlError.extensions,\n    });\n  }\n}\n\nexport class OperationResolutionError extends GraphQLErrorWithCode {\n  constructor(graphqlError: GraphQLError) {\n    super(\n      graphqlError.message,\n      ApolloServerErrorCode.OPERATION_RESOLUTION_FAILURE,\n      {\n        nodes: graphqlError.nodes,\n        originalError: graphqlError.originalError ?? graphqlError,\n        extensions: {\n          http: newHTTPGraphQLHead(400),\n          ...graphqlError.extensions,\n        },\n      },\n    );\n  }\n}\n\nexport class BadRequestError extends GraphQLErrorWithCode {\n  constructor(message: string, options?: GraphQLErrorOptions) {\n    super(message, ApolloServerErrorCode.BAD_REQUEST, {\n      ...options,\n      // Default to 400 status code, but caller can override. (If caller just\n      // wants to override headers... well, they can't, sorry.)\n      extensions: { http: newHTTPGraphQLHead(400), ...options?.extensions },\n    });\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 296, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 302, "column": 0}, "map": {"version":3,"file":"runHttpQuery.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/runHttpQuery.ts"],"sourcesContent":["import type {\n  BaseContext,\n  GraphQLExperimentalFormattedIncrementalResult,\n  GraphQLExperimentalFormattedInitialIncrementalExecutionResult,\n  GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult,\n  GraphQLRequest,\n  HTTPGraphQLHead,\n  HTTPGraphQLRequest,\n  HTTPGraphQLResponse,\n} from './externalTypes/index.js';\nimport {\n  type ApolloServer,\n  type ApolloServerInternals,\n  chooseContentTypeForSingleResultResponse,\n  internalExecuteOperation,\n  MEDIA_TYPES,\n  type SchemaDerivedData,\n} from './ApolloServer.js';\nimport { type FormattedExecutionResult, Kind } from 'graphql';\nimport { BadRequestError } from './internalErrorClasses.js';\nimport Negotiator from 'negotiator';\nimport { HeaderMap } from './utils/HeaderMap.js';\n\nfunction fieldIfString(\n  o: Record<string, unknown>,\n  fieldName: string,\n): string | undefined {\n  const value = o[fieldName];\n  if (typeof value === 'string') {\n    return value;\n  }\n  return undefined;\n}\n\nfunction searchParamIfSpecifiedOnce(\n  searchParams: URLSearchParams,\n  paramName: string,\n) {\n  const values = searchParams.getAll(paramName);\n  switch (values.length) {\n    case 0:\n      return undefined;\n    case 1:\n      return values[0];\n    default:\n      throw new BadRequestError(\n        `The '${paramName}' search parameter may only be specified once.`,\n      );\n  }\n}\n\nfunction jsonParsedSearchParamIfSpecifiedOnce(\n  searchParams: URLSearchParams,\n  fieldName: string,\n): Record<string, unknown> | undefined {\n  const value = searchParamIfSpecifiedOnce(searchParams, fieldName);\n  if (value === undefined) {\n    return undefined;\n  }\n  let hopefullyRecord;\n  try {\n    hopefullyRecord = JSON.parse(value);\n  } catch {\n    throw new BadRequestError(\n      `The ${fieldName} search parameter contains invalid JSON.`,\n    );\n  }\n  if (!isStringRecord(hopefullyRecord)) {\n    throw new BadRequestError(\n      `The ${fieldName} search parameter should contain a JSON-encoded object.`,\n    );\n  }\n  return hopefullyRecord;\n}\n\nfunction fieldIfRecord(\n  o: Record<string, unknown>,\n  fieldName: string,\n): Record<string, unknown> | undefined {\n  const value = o[fieldName];\n  if (isStringRecord(value)) {\n    return value;\n  }\n  return undefined;\n}\n\nfunction isStringRecord(o: unknown): o is Record<string, unknown> {\n  return (\n    !!o && typeof o === 'object' && !Buffer.isBuffer(o) && !Array.isArray(o)\n  );\n}\n\nfunction isNonEmptyStringRecord(o: unknown): o is Record<string, unknown> {\n  return isStringRecord(o) && Object.keys(o).length > 0;\n}\n\nfunction ensureQueryIsStringOrMissing(query: unknown) {\n  if (!query || typeof query === 'string') {\n    return;\n  }\n  // Check for a common error first.\n  if ((query as any).kind === Kind.DOCUMENT) {\n    throw new BadRequestError(\n      \"GraphQL queries must be strings. It looks like you're sending the \" +\n        'internal graphql-js representation of a parsed query in your ' +\n        'request instead of a request in the GraphQL query language. You ' +\n        'can convert an AST to a string using the `print` function from ' +\n        '`graphql`, or use a client like `apollo-client` which converts ' +\n        'the internal representation to a string for you.',\n    );\n  } else {\n    throw new BadRequestError('GraphQL queries must be strings.');\n  }\n}\n\nexport async function runHttpQuery<TContext extends BaseContext>({\n  server,\n  httpRequest,\n  contextValue,\n  schemaDerivedData,\n  internals,\n  sharedResponseHTTPGraphQLHead,\n}: {\n  server: ApolloServer<TContext>;\n  httpRequest: HTTPGraphQLRequest;\n  contextValue: TContext;\n  schemaDerivedData: SchemaDerivedData;\n  internals: ApolloServerInternals<TContext>;\n  sharedResponseHTTPGraphQLHead: HTTPGraphQLHead | null;\n}): Promise<HTTPGraphQLResponse> {\n  let graphQLRequest: GraphQLRequest;\n\n  switch (httpRequest.method) {\n    case 'POST': {\n      if (!isNonEmptyStringRecord(httpRequest.body)) {\n        throw new BadRequestError(\n          'POST body missing, invalid Content-Type, or JSON object has no keys.',\n        );\n      }\n\n      ensureQueryIsStringOrMissing(httpRequest.body.query);\n\n      if (typeof httpRequest.body.variables === 'string') {\n        throw new BadRequestError(\n          '`variables` in a POST body should be provided as an object, not a recursively JSON-encoded string.',\n        );\n      }\n\n      if (typeof httpRequest.body.extensions === 'string') {\n        throw new BadRequestError(\n          '`extensions` in a POST body should be provided as an object, not a recursively JSON-encoded string.',\n        );\n      }\n\n      if (\n        'extensions' in httpRequest.body &&\n        httpRequest.body.extensions !== null &&\n        !isStringRecord(httpRequest.body.extensions)\n      ) {\n        throw new BadRequestError(\n          '`extensions` in a POST body must be an object if provided.',\n        );\n      }\n\n      if (\n        'variables' in httpRequest.body &&\n        httpRequest.body.variables !== null &&\n        !isStringRecord(httpRequest.body.variables)\n      ) {\n        throw new BadRequestError(\n          '`variables` in a POST body must be an object if provided.',\n        );\n      }\n\n      if (\n        'operationName' in httpRequest.body &&\n        httpRequest.body.operationName !== null &&\n        typeof httpRequest.body.operationName !== 'string'\n      ) {\n        throw new BadRequestError(\n          '`operationName` in a POST body must be a string if provided.',\n        );\n      }\n\n      graphQLRequest = {\n        query: fieldIfString(httpRequest.body, 'query'),\n        operationName: fieldIfString(httpRequest.body, 'operationName'),\n        variables: fieldIfRecord(httpRequest.body, 'variables'),\n        extensions: fieldIfRecord(httpRequest.body, 'extensions'),\n        http: httpRequest,\n      };\n\n      break;\n    }\n\n    case 'GET': {\n      const searchParams = new URLSearchParams(httpRequest.search);\n\n      graphQLRequest = {\n        query: searchParamIfSpecifiedOnce(searchParams, 'query'),\n        operationName: searchParamIfSpecifiedOnce(\n          searchParams,\n          'operationName',\n        ),\n        variables: jsonParsedSearchParamIfSpecifiedOnce(\n          searchParams,\n          'variables',\n        ),\n        extensions: jsonParsedSearchParamIfSpecifiedOnce(\n          searchParams,\n          'extensions',\n        ),\n        http: httpRequest,\n      };\n\n      break;\n    }\n    default:\n      throw new BadRequestError(\n        'Apollo Server supports only GET/POST requests.',\n        {\n          extensions: {\n            http: {\n              status: 405,\n              headers: new HeaderMap([['allow', 'GET, POST']]),\n            },\n          },\n        },\n      );\n  }\n\n  const graphQLResponse = await internalExecuteOperation(\n    {\n      server,\n      graphQLRequest,\n      internals,\n      schemaDerivedData,\n      sharedResponseHTTPGraphQLHead,\n    },\n    { contextValue },\n  );\n\n  if (graphQLResponse.body.kind === 'single') {\n    if (!graphQLResponse.http.headers.get('content-type')) {\n      // If we haven't already set the content-type (via a plugin or something),\n      // decide which content-type to use based on the accept header.\n      const contentType = chooseContentTypeForSingleResultResponse(httpRequest);\n      if (contentType === null) {\n        throw new BadRequestError(\n          `An 'accept' header was provided for this request which does not accept ` +\n            `${MEDIA_TYPES.APPLICATION_JSON} or ${MEDIA_TYPES.APPLICATION_GRAPHQL_RESPONSE_JSON}`,\n          // Use 406 Not Accepted\n          { extensions: { http: { status: 406 } } },\n        );\n      }\n      graphQLResponse.http.headers.set('content-type', contentType);\n    }\n\n    return {\n      ...graphQLResponse.http,\n      body: {\n        kind: 'complete',\n        string: await internals.stringifyResult(\n          orderExecutionResultFields(graphQLResponse.body.singleResult),\n        ),\n      },\n    };\n  }\n\n  // Note that incremental delivery is not yet part of the official GraphQL\n  // spec. We are implementing a proposed version of the spec, and require\n  // clients to explicitly state `deferSpec=20220824`. Once incremental delivery\n  // has been added to the GraphQL spec, we will support `accept` headers\n  // without `deferSpec` as well (perhaps with slightly different behavior if\n  // anything has changed).\n  const acceptHeader = httpRequest.headers.get('accept');\n  if (\n    !(\n      acceptHeader &&\n      new Negotiator({\n        headers: { accept: httpRequest.headers.get('accept') },\n      }).mediaType([\n        // mediaType() will return the first one that matches, so if the client\n        // doesn't include the deferSpec parameter it will match this one here,\n        // which isn't good enough.\n        MEDIA_TYPES.MULTIPART_MIXED_NO_DEFER_SPEC,\n        MEDIA_TYPES.MULTIPART_MIXED_EXPERIMENTAL,\n      ]) === MEDIA_TYPES.MULTIPART_MIXED_EXPERIMENTAL\n    )\n  ) {\n    // The client ran an operation that would yield multiple parts, but didn't\n    // specify `accept: multipart/mixed`. We return an error.\n    throw new BadRequestError(\n      'Apollo server received an operation that uses incremental delivery ' +\n        '(@defer or @stream), but the client does not accept multipart/mixed ' +\n        'HTTP responses. To enable incremental delivery support, add the HTTP ' +\n        \"header 'Accept: multipart/mixed; deferSpec=20220824'.\",\n      // Use 406 Not Accepted\n      { extensions: { http: { status: 406 } } },\n    );\n  }\n\n  graphQLResponse.http.headers.set(\n    'content-type',\n    'multipart/mixed; boundary=\"-\"; deferSpec=20220824',\n  );\n  return {\n    ...graphQLResponse.http,\n    body: {\n      kind: 'chunked',\n      asyncIterator: writeMultipartBody(\n        graphQLResponse.body.initialResult,\n        graphQLResponse.body.subsequentResults,\n      ),\n    },\n  };\n}\n\nasync function* writeMultipartBody(\n  initialResult: GraphQLExperimentalFormattedInitialIncrementalExecutionResult,\n  subsequentResults: AsyncIterable<GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult>,\n): AsyncGenerator<string> {\n  // Note: we assume in this function that every result other than the last has\n  // hasNext=true and the last has hasNext=false. That is, we choose which kind\n  // of delimiter to place at the end of each block based on the contents of the\n  // message, not the structure of the async iterator. This makes sense because\n  // we want to write the delimiter as soon as each block is done (so the client\n  // can parse it immediately) but we may not know whether a general async\n  // iterator is finished until we do async work.\n\n  yield `\\r\\n---\\r\\ncontent-type: application/json; charset=utf-8\\r\\n\\r\\n${JSON.stringify(\n    orderInitialIncrementalExecutionResultFields(initialResult),\n  )}\\r\\n---${initialResult.hasNext ? '' : '--'}\\r\\n`;\n\n  for await (const result of subsequentResults) {\n    yield `content-type: application/json; charset=utf-8\\r\\n\\r\\n${JSON.stringify(\n      orderSubsequentIncrementalExecutionResultFields(result),\n    )}\\r\\n---${result.hasNext ? '' : '--'}\\r\\n`;\n  }\n}\n\n// See https://github.com/facebook/graphql/pull/384 for why\n// errors comes first.\nfunction orderExecutionResultFields(\n  result: FormattedExecutionResult,\n): FormattedExecutionResult {\n  return {\n    errors: result.errors,\n    data: result.data,\n    extensions: result.extensions,\n  };\n}\nfunction orderInitialIncrementalExecutionResultFields(\n  result: GraphQLExperimentalFormattedInitialIncrementalExecutionResult,\n): GraphQLExperimentalFormattedInitialIncrementalExecutionResult {\n  return {\n    hasNext: result.hasNext,\n    errors: result.errors,\n    data: result.data,\n    incremental: orderIncrementalResultFields(result.incremental),\n    extensions: result.extensions,\n  };\n}\nfunction orderSubsequentIncrementalExecutionResultFields(\n  result: GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult,\n): GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult {\n  return {\n    hasNext: result.hasNext,\n    incremental: orderIncrementalResultFields(result.incremental),\n    extensions: result.extensions,\n  };\n}\n\nfunction orderIncrementalResultFields(\n  incremental?: readonly GraphQLExperimentalFormattedIncrementalResult[],\n): undefined | GraphQLExperimentalFormattedIncrementalResult[] {\n  return incremental?.map((i: any) => ({\n    hasNext: i.hasNext,\n    errors: i.errors,\n    path: i.path,\n    label: i.label,\n    data: i.data,\n    items: i.items,\n    extensions: i.extensions,\n  }));\n}\n\n// The result of a curl does not appear well in the terminal, so we add an extra new line\nexport function prettyJSONStringify(value: FormattedExecutionResult) {\n  return JSON.stringify(value) + '\\n';\n}\n\nexport function newHTTPGraphQLHead(status?: number): HTTPGraphQLHead {\n  return {\n    status,\n    headers: new HeaderMap(),\n  };\n}\n\n// Updates `target` with status code and headers from `source`. For now let's\n// consider it undefined what happens if both have a status code set or both set\n// the same header.\nexport function mergeHTTPGraphQLHead(\n  target: HTTPGraphQLHead,\n  source: HTTPGraphQLHead,\n) {\n  if (source.status) {\n    target.status = source.status;\n  }\n  if (source.headers) {\n    for (const [name, value] of source.headers) {\n      // If source.headers contains non-lowercase header names, this will\n      // catch that case as long as target.headers is a HeaderMap.\n      target.headers.set(name, value);\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 551, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 557, "column": 0}, "map": {"version":3,"file":"errorNormalize.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/errorNormalize.ts"],"sourcesContent":["// The functions in this file are not part of Apollo Server's external API.\n\nimport {\n  GraphQLError,\n  type GraphQLErrorExtensions,\n  type GraphQLFormattedError,\n} from 'graphql';\nimport { ApolloServerErrorCode } from './errors/index.js';\nimport type { HTTPGraphQLHead } from './externalTypes/http.js';\nimport { mergeHTTPGraphQLHead, newHTTPGraphQLHead } from './runHttpQuery.js';\nimport { HeaderMap } from './utils/HeaderMap.js';\n\n// This function accepts any value that were thrown and convert it to GraphQLFormattedError.\n// It also add default extensions.code and copy stack trace onto an extension if requested.\n// Additionally, it returns an `HTTPGraphQLHead` created from combining the values of any\n// `HTTPGraphqlHead` objects found on `extensions.http` (the behavior when multiple errors\n// set a status code or set the same header should be treated as undefined); these extensions\n// are removed from the formatted error.\n//\n// This function should not throw.\nexport function normalizeAndFormatErrors(\n  errors: ReadonlyArray<unknown>,\n  options: {\n    formatError?: (\n      formattedError: GraphQLFormattedError,\n      error: unknown,\n    ) => GraphQLFormattedError;\n    includeStacktraceInErrorResponses?: boolean;\n  } = {},\n): {\n  formattedErrors: Array<GraphQLFormattedError>;\n  httpFromErrors: HTTPGraphQLHead;\n} {\n  const formatError = options.formatError ?? ((error) => error);\n  const httpFromErrors = newHTTPGraphQLHead();\n\n  return {\n    httpFromErrors,\n    formattedErrors: errors.map((error) => {\n      try {\n        return formatError(enrichError(error), error);\n      } catch (formattingError) {\n        if (options.includeStacktraceInErrorResponses) {\n          // includeStacktraceInErrorResponses is used in development\n          // so it will be helpful to show errors thrown by formatError hooks in that mode\n          return enrichError(formattingError);\n        } else {\n          // obscure error\n          return {\n            message: 'Internal server error',\n            extensions: { code: ApolloServerErrorCode.INTERNAL_SERVER_ERROR },\n          };\n        }\n      }\n    }),\n  };\n\n  function enrichError(maybeError: unknown): GraphQLFormattedError {\n    const graphqlError = ensureGraphQLError(maybeError);\n\n    const extensions: GraphQLErrorExtensions = {\n      ...graphqlError.extensions,\n      code:\n        graphqlError.extensions.code ??\n        ApolloServerErrorCode.INTERNAL_SERVER_ERROR,\n    };\n\n    if (isPartialHTTPGraphQLHead(extensions.http)) {\n      mergeHTTPGraphQLHead(httpFromErrors, {\n        headers: new HeaderMap(),\n        ...extensions.http,\n      });\n      delete extensions.http;\n    }\n\n    if (options.includeStacktraceInErrorResponses) {\n      // Note that if ensureGraphQLError created graphqlError from an\n      // originalError, graphqlError.stack will be the same as\n      // originalError.stack due to some special code in the GraphQLError\n      // constructor.\n      extensions.stacktrace = graphqlError.stack?.split('\\n');\n    }\n\n    return { ...graphqlError.toJSON(), extensions };\n  }\n}\n\nexport function ensureError(maybeError: unknown): Error {\n  return maybeError instanceof Error\n    ? maybeError\n    : new GraphQLError('Unexpected error value: ' + String(maybeError));\n}\n\nexport function ensureGraphQLError(\n  maybeError: unknown,\n  messagePrefixIfNotGraphQLError: string = '',\n): GraphQLError {\n  const error: Error = ensureError(maybeError);\n\n  return error instanceof GraphQLError\n    ? error\n    : new GraphQLError(messagePrefixIfNotGraphQLError + error.message, {\n        originalError: error,\n      });\n}\n\nfunction isPartialHTTPGraphQLHead(x: unknown): x is Partial<HTTPGraphQLHead> {\n  return (\n    !!x &&\n    typeof x === 'object' &&\n    (!('status' in x) || typeof (x as any).status === 'number') &&\n    (!('headers' in x) || (x as any).headers instanceof Map)\n  );\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 627, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 633, "column": 0}, "map": {"version":3,"file":"httpBatching.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/httpBatching.ts"],"sourcesContent":["import type {\n  BaseContext,\n  HTTPGraphQLRequest,\n  HTTPGraphQLResponse,\n} from './externalTypes/index.js';\nimport type {\n  ApolloServer,\n  ApolloServerInternals,\n  SchemaDerivedData,\n} from './ApolloServer';\nimport { newHTTPGraphQLHead, runHttpQuery } from './runHttpQuery.js';\nimport { BadRequestError } from './internalErrorClasses.js';\n\nasync function runBatchedHttpQuery<TContext extends BaseContext>({\n  server,\n  batchRequest,\n  body,\n  contextValue,\n  schemaDerivedData,\n  internals,\n}: {\n  server: ApolloServer<TContext>;\n  batchRequest: HTTPGraphQLRequest;\n  body: unknown[];\n  contextValue: TContext;\n  schemaDerivedData: SchemaDerivedData;\n  internals: ApolloServerInternals<TContext>;\n}): Promise<HTTPGraphQLResponse> {\n  if (body.length === 0) {\n    throw new BadRequestError('No operations found in request.');\n  }\n\n  // This single HTTPGraphQLHead is shared across all the operations in the\n  // batch. This means that any changes to response headers or status code from\n  // one operation can be immediately seen by other operations. Plugins that set\n  // response headers or status code can then choose to combine the data they\n  // are setting with data that may already be there from another operation as\n  // they choose.\n  const sharedResponseHTTPGraphQLHead = newHTTPGraphQLHead();\n  const responseBodies = await Promise.all(\n    body.map(async (bodyPiece: unknown) => {\n      const singleRequest: HTTPGraphQLRequest = {\n        ...batchRequest,\n        body: bodyPiece,\n      };\n\n      const response = await runHttpQuery({\n        server,\n        httpRequest: singleRequest,\n        contextValue,\n        schemaDerivedData,\n        internals,\n        sharedResponseHTTPGraphQLHead,\n      });\n\n      if (response.body.kind === 'chunked') {\n        throw Error(\n          'Incremental delivery is not implemented for batch requests',\n        );\n      }\n      return response.body.string;\n    }),\n  );\n  return {\n    ...sharedResponseHTTPGraphQLHead,\n    body: { kind: 'complete', string: `[${responseBodies.join(',')}]` },\n  };\n}\n\nexport async function runPotentiallyBatchedHttpQuery<\n  TContext extends BaseContext,\n>(\n  server: ApolloServer<TContext>,\n  httpGraphQLRequest: HTTPGraphQLRequest,\n  contextValue: TContext,\n  schemaDerivedData: SchemaDerivedData,\n  internals: ApolloServerInternals<TContext>,\n): Promise<HTTPGraphQLResponse> {\n  if (\n    !(\n      httpGraphQLRequest.method === 'POST' &&\n      Array.isArray(httpGraphQLRequest.body)\n    )\n  ) {\n    return await runHttpQuery({\n      server,\n      httpRequest: httpGraphQLRequest,\n      contextValue,\n      schemaDerivedData,\n      internals,\n      sharedResponseHTTPGraphQLHead: null,\n    });\n  }\n  if (internals.allowBatchedHttpRequests) {\n    return await runBatchedHttpQuery({\n      server,\n      batchRequest: httpGraphQLRequest,\n      body: httpGraphQLRequest.body as unknown[],\n      contextValue,\n      schemaDerivedData,\n      internals,\n    });\n  }\n  throw new BadRequestError('Operation batching disabled.');\n}\n"],"names":[],"mappings":";;;AAUA,OAAO,EAAE,kBAAkB,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AACrE,OAAO,EAAE,eAAe,EAAE,MAAM,2BAA2B,CAAC;;;AAE5D,KAAK,UAAU,mBAAmB,CAA+B,EAC/D,MAAM,EACN,YAAY,EACZ,IAAI,EACJ,YAAY,EACZ,iBAAiB,EACjB,SAAS,EAQV;IACC,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACtB,MAAM,gLAAI,kBAAe,CAAC,iCAAiC,CAAC,CAAC;IAC/D,CAAC;IAQD,MAAM,6BAA6B,2KAAG,qBAAA,AAAkB,EAAE,CAAC;IAC3D,MAAM,cAAc,GAAG,MAAM,OAAO,CAAC,GAAG,CACtC,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,SAAkB,EAAE,EAAE;QACpC,MAAM,aAAa,GAAuB;YACxC,GAAG,YAAY;YACf,IAAI,EAAE,SAAS;SAChB,CAAC;QAEF,MAAM,QAAQ,GAAG,8KAAM,eAAA,AAAY,EAAC;YAClC,MAAM;YACN,WAAW,EAAE,aAAa;YAC1B,YAAY;YACZ,iBAAiB;YACjB,SAAS;YACT,6BAA6B;SAC9B,CAAC,CAAC;QAEH,IAAI,QAAQ,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,EAAE,CAAC;YACrC,MAAM,KAAK,CACT,4DAA4D,CAC7D,CAAC;QACJ,CAAC;QACD,OAAO,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC;IAC9B,CAAC,CAAC,CACH,CAAC;IACF,OAAO;QACL,GAAG,6BAA6B;QAChC,IAAI,EAAE;YAAE,IAAI,EAAE,UAAU;YAAE,MAAM,EAAE,CAAA,CAAA,EAAI,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA,CAAA,CAAG;QAAA,CAAE;KACpE,CAAC;AACJ,CAAC;AAEM,KAAK,UAAU,8BAA8B,CAGlD,MAA8B,EAC9B,kBAAsC,EACtC,YAAsB,EACtB,iBAAoC,EACpC,SAA0C;IAE1C,IACE,CAAC,CACC,kBAAkB,CAAC,MAAM,KAAK,MAAM,IACpC,KAAK,CAAC,OAAO,CAAC,kBAAkB,CAAC,IAAI,CAAC,CACvC,EACD,CAAC;QACD,OAAO,8KAAM,eAAA,AAAY,EAAC;YACxB,MAAM;YACN,WAAW,EAAE,kBAAkB;YAC/B,YAAY;YACZ,iBAAiB;YACjB,SAAS;YACT,6BAA6B,EAAE,IAAI;SACpC,CAAC,CAAC;IACL,CAAC;IACD,IAAI,SAAS,CAAC,wBAAwB,EAAE,CAAC;QACvC,OAAO,MAAM,mBAAmB,CAAC;YAC/B,MAAM;YACN,YAAY,EAAE,kBAAkB;YAChC,IAAI,EAAE,kBAAkB,CAAC,IAAiB;YAC1C,YAAY;YACZ,iBAAiB;YACjB,SAAS;SACV,CAAC,CAAC;IACL,CAAC;IACD,MAAM,gLAAI,kBAAe,CAAC,8BAA8B,CAAC,CAAC;AAC5D,CAAC","ignoreList":[0]}},
    {"offset": {"line": 694, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 700, "column": 0}, "map": {"version":3,"file":"internalPlugin.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/internalPlugin.ts"],"sourcesContent":["import type { BaseContext, ApolloServerPlugin } from './externalTypes/index.js';\n\n// This file's exports should not be exported from the overall\n// @apollo/server module.\n\n// The internal plugins implement this interface which\n// ApolloServer.ensurePluginInstantiation uses to figure out if the plugins have\n// already been installed (or explicitly disabled via the matching Disable\n// plugins).\nexport interface InternalApolloServerPlugin<TContext extends BaseContext>\n  extends ApolloServerPlugin<TContext> {\n  // Used to identify a few specific plugins that are instantiated\n  // by default if not explicitly used or disabled.\n  __internal_plugin_id__: InternalPluginId;\n  __is_disabled_plugin__: boolean;\n}\n\n// Helper function for writing internal plugins which lets you write an object\n// that is type-checked as InternalApolloServerPlugin but is still only of type\n// ApolloServerPlugin (as appropriate for externally-exported plugin-returning\n// functions).\nexport function internalPlugin<TContext extends BaseContext>(\n  p: InternalApolloServerPlugin<TContext>,\n): ApolloServerPlugin<TContext> {\n  return p;\n}\n\nexport type InternalPluginId =\n  | 'CacheControl'\n  | 'LandingPageDisabled'\n  | 'SchemaReporting'\n  | 'InlineTrace'\n  | 'UsageReporting'\n  | 'DisableSuggestions';\n\nexport function pluginIsInternal<TContext extends BaseContext>(\n  plugin: ApolloServerPlugin<TContext>,\n): plugin is InternalApolloServerPlugin<TContext> {\n  // We could call the function and compare it to the list above, but this seems\n  // good enough.\n  return '__internal_plugin_id__' in plugin;\n}\n"],"names":[],"mappings":";;;;AAqBM,SAAU,cAAc,CAC5B,CAAuC;IAEvC,OAAO,CAAC,CAAC;AACX,CAAC;AAUK,SAAU,gBAAgB,CAC9B,MAAoC;IAIpC,OAAO,wBAAwB,IAAI,MAAM,CAAC;AAC5C,CAAC","ignoreList":[0]}},
    {"offset": {"line": 710, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 716, "column": 0}, "map": {"version":3,"file":"preventCsrf.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/preventCsrf.ts"],"sourcesContent":["import MIMEType from 'whatwg-mimetype';\nimport { BadRequestError } from './internalErrorClasses.js';\nimport type { HeaderMap } from './utils/HeaderMap.js';\n\n// Our recommended set of CSRF prevention headers. Operations that do not\n// provide a content-type such as `application/json` (in practice, this\n// means GET operations) must include at least one of these headers.\n// Apollo Client Web's default behavior is to always sends a\n// `content-type` even for `GET`, and Apollo iOS and Apollo Kotlin always\n// send `x-apollo-operation-name`. So if you set\n// `csrfPreventionRequestHeaders: true` then any `GET` operation from these\n// three client projects and any `POST` operation at all should work\n// successfully; if you need `GET`s from another kind of client to work,\n// just add `apollo-require-preflight: true` to their requests.\nexport const recommendedCsrfPreventionRequestHeaders = [\n  'x-apollo-operation-name',\n  'apollo-require-preflight',\n];\n\n// See https://fetch.spec.whatwg.org/#cors-safelisted-request-header\nconst NON_PREFLIGHTED_CONTENT_TYPES = [\n  'application/x-www-form-urlencoded',\n  'multipart/form-data',\n  'text/plain',\n];\n\n// We don't want random websites to be able to execute actual GraphQL operations\n// from a user's browser unless our CORS policy supports it. It's not good\n// enough just to ensure that the browser can't read the response from the\n// operation; we also want to prevent CSRF, where the attacker can cause side\n// effects with an operation or can measure the timing of a read operation. Our\n// goal is to ensure that we don't run the context function or execute the\n// GraphQL operation until the browser has evaluated the CORS policy, which\n// means we want all operations to be pre-flighted. We can do that by only\n// processing operations that have at least one header set that appears to be\n// manually set by the JS code rather than by the browser automatically.\n//\n// POST requests generally have a content-type `application/json`, which is\n// sufficient to trigger preflighting. So we take extra care with requests that\n// specify no content-type or that specify one of the three non-preflighted\n// content types. For those operations, we require (if this feature is enabled)\n// one of a set of specific headers to be set. By ensuring that every operation\n// either has a custom content-type or sets one of these headers, we know we\n// won't execute operations at the request of origins who our CORS policy will\n// block.\nexport function preventCsrf(\n  headers: HeaderMap,\n  csrfPreventionRequestHeaders: string[],\n) {\n  const contentType = headers.get('content-type');\n\n  // We have to worry about CSRF if it looks like this may have been a\n  // non-preflighted request. If we see a content-type header that is not one of\n  // the three CORS-safelisted MIME types (see\n  // https://fetch.spec.whatwg.org/#cors-safelisted-request-header) then we know\n  // it was preflighted and we don't have to worry.\n  if (contentType !== undefined) {\n    const contentTypeParsed = MIMEType.parse(contentType);\n    if (contentTypeParsed === null) {\n      // If we got null, then parsing the content-type failed... which is\n      // actually *ok* because that would lead to a preflight. (For example, the\n      // header is empty, or doesn't have a slash, or has bad characters.) The\n      // scary CSRF case is only if there's *not* an error. So it is actually\n      // fine for us to just `return` here. (That said, it would also be\n      // reasonable to reject such requests with provided yet unparsable\n      // Content-Type here.)\n      return;\n    }\n    if (!NON_PREFLIGHTED_CONTENT_TYPES.includes(contentTypeParsed.essence)) {\n      // We managed to parse a MIME type that was not one of the\n      // CORS-safelisted ones. (Probably application/json!) That means that if\n      // the client is a browser, the browser must have applied CORS\n      // preflighting and we don't have to worry about CSRF.\n      return;\n    }\n  }\n\n  // Either there was no content-type, or the content-type parsed properly as\n  // one of the three CORS-safelisted values. Let's look for another header that\n  // (if this was a browser) must have been set by the user's code and would\n  // have caused a preflight.\n  if (\n    csrfPreventionRequestHeaders.some((header) => {\n      const value = headers.get(header);\n      return value !== undefined && value.length > 0;\n    })\n  ) {\n    return;\n  }\n\n  throw new BadRequestError(\n    `This operation has been blocked as a potential Cross-Site Request Forgery ` +\n      `(CSRF). Please either specify a 'content-type' header (with a type that ` +\n      `is not one of ${NON_PREFLIGHTED_CONTENT_TYPES.join(', ')}) or provide ` +\n      `a non-empty value for one of the following headers: ${csrfPreventionRequestHeaders.join(\n        ', ',\n      )}\\n`,\n  );\n}\n"],"names":[],"mappings":";;;;AAAA,OAAO,QAAQ,MAAM,iBAAiB,CAAC;AACvC,OAAO,EAAE,eAAe,EAAE,MAAM,2BAA2B,CAAC;;;AAarD,MAAM,uCAAuC,GAAG;IACrD,yBAAyB;IACzB,0BAA0B;CAC3B,CAAC;AAGF,MAAM,6BAA6B,GAAG;IACpC,mCAAmC;IACnC,qBAAqB;IACrB,YAAY;CACb,CAAC;AAqBI,SAAU,WAAW,CACzB,OAAkB,EAClB,4BAAsC;IAEtC,MAAM,WAAW,GAAG,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;IAOhD,IAAI,WAAW,KAAK,SAAS,EAAE,CAAC;QAC9B,MAAM,iBAAiB,+JAAG,UAAQ,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;QACtD,IAAI,iBAAiB,KAAK,IAAI,EAAE,CAAC;YAQ/B,OAAO;QACT,CAAC;QACD,IAAI,CAAC,6BAA6B,CAAC,QAAQ,CAAC,iBAAiB,CAAC,OAAO,CAAC,EAAE,CAAC;YAKvE,OAAO;QACT,CAAC;IACH,CAAC;IAMD,IACE,4BAA4B,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,EAAE;QAC3C,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAClC,OAAO,KAAK,KAAK,SAAS,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;IACjD,CAAC,CAAC,EACF,CAAC;QACD,OAAO;IACT,CAAC;IAED,MAAM,gLAAI,kBAAe,CACvB,CAAA,0EAAA,CAA4E,GAC1E,CAAA,wEAAA,CAA0E,GAC1E,CAAA,cAAA,EAAiB,6BAA6B,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA,aAAA,CAAe,GACxE,CAAA,oDAAA,EAAuD,4BAA4B,CAAC,IAAI,CACtF,IAAI,CACL,CAAA,EAAA,CAAI,CACR,CAAC;AACJ,CAAC","ignoreList":[0]}},
    {"offset": {"line": 752, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 758, "column": 0}, "map": {"version":3,"file":"schemaInstrumentation.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/utils/schemaInstrumentation.ts"],"sourcesContent":["import {\n  type GraphQLSchema,\n  type GraphQLField,\n  getNamedType,\n  GraphQLObjectType,\n  type GraphQLFieldResolver,\n  defaultFieldResolver,\n} from 'graphql';\nimport type {\n  BaseContext,\n  GraphQLRequestExecutionListener,\n} from '../externalTypes/index.js';\n\nexport const symbolExecutionDispatcherWillResolveField = Symbol(\n  'apolloServerExecutionDispatcherWillResolveField',\n);\nexport const symbolUserFieldResolver = Symbol('apolloServerUserFieldResolver');\nconst symbolPluginsEnabled = Symbol('apolloServerPluginsEnabled');\n\nexport function enablePluginsForSchemaResolvers<TContext extends BaseContext>(\n  schema: GraphQLSchema & { [symbolPluginsEnabled]?: boolean },\n) {\n  if (pluginsEnabledForSchemaResolvers(schema)) {\n    return schema;\n  }\n  Object.defineProperty(schema, symbolPluginsEnabled, {\n    value: true,\n  });\n\n  const typeMap = schema.getTypeMap();\n  Object.values(typeMap).forEach((type) => {\n    if (\n      !getNamedType(type).name.startsWith('__') &&\n      type instanceof GraphQLObjectType\n    ) {\n      const fields = type.getFields();\n      Object.values(fields).forEach((field) => {\n        wrapField<TContext>(field);\n      });\n    }\n  });\n\n  return schema;\n}\n\nexport function pluginsEnabledForSchemaResolvers(\n  schema: GraphQLSchema & { [symbolPluginsEnabled]?: boolean },\n): boolean {\n  return !!schema[symbolPluginsEnabled];\n}\n\nfunction wrapField<TContext extends BaseContext>(\n  field: GraphQLField<any, any>,\n): void {\n  const originalFieldResolve = field.resolve;\n\n  field.resolve = (source, args, contextValue, info) => {\n    const willResolveField = contextValue?.[\n      symbolExecutionDispatcherWillResolveField\n    ] as\n      | GraphQLRequestExecutionListener<TContext>['willResolveField']\n      | undefined;\n\n    const userFieldResolver = contextValue?.[symbolUserFieldResolver] as\n      | GraphQLFieldResolver<any, any>\n      | undefined;\n\n    // The technique for implementing a  \"did resolve field\" is accomplished by\n    // returning a function from the `willResolveField` handler.  While there\n    // may be several callbacks, depending on the number of plugins which have\n    // implemented a `willResolveField` hook, this hook will call them all\n    // as dictated by the dispatcher.  We will call this when object\n    // resolution is complete.\n    const didResolveField =\n      typeof willResolveField === 'function' &&\n      willResolveField({ source, args, contextValue, info });\n\n    const fieldResolver =\n      originalFieldResolve || userFieldResolver || defaultFieldResolver;\n\n    try {\n      const result = fieldResolver(source, args, contextValue, info);\n\n      // Call the stack's handlers either immediately (if result is not a\n      // Promise) or once the Promise is done. Then return that same\n      // maybe-Promise value.\n      if (typeof didResolveField === 'function') {\n        whenResultIsFinished(result, didResolveField);\n      }\n      return result;\n    } catch (error) {\n      // Normally it's a bad sign to see an error both handled and\n      // re-thrown. But it is useful to allow extensions to track errors while\n      // still handling them in the normal GraphQL way.\n      if (typeof didResolveField === 'function') {\n        didResolveField(error as Error);\n      }\n      throw error;\n    }\n  };\n}\n\nfunction isPromise(x: any): boolean {\n  return x && typeof x.then === 'function';\n}\n\n// Given result (which may be a Promise or an array some of whose elements are\n// promises) Promises, set up 'callback' to be invoked when result is fully\n// resolved. (Unfortunately, this does not perfectly handle every possible\n// return value shape, such as arrays of arrays of Promises.)\nexport function whenResultIsFinished(\n  result: any,\n  callback: (err: Error | null, result?: any) => void,\n) {\n  if (isPromise(result)) {\n    result.then(\n      (r: any) => whenResultIsFinished(r, callback),\n      (err: Error) => callback(err),\n    );\n  } else if (Array.isArray(result)) {\n    if (result.some(isPromise)) {\n      Promise.all(result).then(\n        (r: any) => callback(null, r),\n        (err: Error) => callback(err),\n      );\n    } else {\n      callback(null, result);\n    }\n  } else {\n    callback(null, result);\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 834, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 840, "column": 0}, "map": {"version":3,"file":"isDefined.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/utils/isDefined.ts"],"sourcesContent":["export function isDefined<T>(t: T | undefined | null | void): t is T {\n  return t != null;\n}\n"],"names":[],"mappings":";;;AAAM,SAAU,SAAS,CAAI,CAA8B;IACzD,OAAO,CAAC,IAAI,IAAI,CAAC;AACnB,CAAC","ignoreList":[0]}},
    {"offset": {"line": 846, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 852, "column": 0}, "map": {"version":3,"file":"invokeHooks.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/utils/invokeHooks.ts"],"sourcesContent":["import { isDefined } from './isDefined.js';\n\ntype AsyncDidEndHook<TArgs extends any[]> = (...args: TArgs) => Promise<void>;\ntype SyncDidEndHook<TArgs extends any[]> = (...args: TArgs) => void;\n\nexport async function invokeDidStartHook<T, TEndHookArgs extends unknown[]>(\n  targets: T[],\n  hook: (t: T) => Promise<AsyncDidEndHook<TEndHookArgs> | undefined | void>,\n): Promise<AsyncDidEndHook<TEndHookArgs>> {\n  const didEndHooks = (\n    await Promise.all(targets.map((target) => hook(target)))\n  ).filter(isDefined);\n\n  didEndHooks.reverse();\n\n  return async (...args: TEndHookArgs) => {\n    for (const didEndHook of didEndHooks) {\n      didEndHook(...args);\n    }\n  };\n}\n\n// Almost all hooks are async, but as a special case, willResolveField is sync\n// due to performance concerns.\nexport function invokeSyncDidStartHook<T, TEndHookArgs extends unknown[]>(\n  targets: T[],\n  hook: (t: T) => SyncDidEndHook<TEndHookArgs> | undefined | void,\n): SyncDidEndHook<TEndHookArgs> {\n  const didEndHooks: SyncDidEndHook<TEndHookArgs>[] = targets\n    .map((target) => hook(target))\n    .filter(isDefined);\n\n  didEndHooks.reverse();\n\n  return (...args: TEndHookArgs) => {\n    for (const didEndHook of didEndHooks) {\n      didEndHook(...args);\n    }\n  };\n}\n\nexport async function invokeHooksUntilDefinedAndNonNull<T, TOut>(\n  targets: T[],\n  hook: (t: T) => Promise<TOut | null | undefined>,\n): Promise<TOut | null> {\n  for (const target of targets) {\n    const value = await hook(target);\n    if (value != null) {\n      return value;\n    }\n  }\n  return null;\n}\n"],"names":[],"mappings":";;;;;AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAC;;AAKpC,KAAK,UAAU,kBAAkB,CACtC,OAAY,EACZ,IAAyE;IAEzE,MAAM,WAAW,GAAG,CAClB,MAAM,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAG,CAAD,GAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CACzD,CAAC,MAAM,2KAAC,YAAS,CAAC,CAAC;IAEpB,WAAW,CAAC,OAAO,EAAE,CAAC;IAEtB,OAAO,KAAK,EAAE,GAAG,IAAkB,EAAE,EAAE;QACrC,KAAK,MAAM,UAAU,IAAI,WAAW,CAAE,CAAC;YACrC,UAAU,CAAC,GAAG,IAAI,CAAC,CAAC;QACtB,CAAC;IACH,CAAC,CAAC;AACJ,CAAC;AAIK,SAAU,sBAAsB,CACpC,OAAY,EACZ,IAA+D;IAE/D,MAAM,WAAW,GAAmC,OAAO,CACxD,GAAG,CAAC,CAAC,MAAM,EAAE,CAAG,CAAD,GAAK,CAAC,MAAM,CAAC,CAAC,CAC7B,MAAM,2KAAC,YAAS,CAAC,CAAC;IAErB,WAAW,CAAC,OAAO,EAAE,CAAC;IAEtB,OAAO,CAAC,GAAG,IAAkB,EAAE,EAAE;QAC/B,KAAK,MAAM,UAAU,IAAI,WAAW,CAAE,CAAC;YACrC,UAAU,CAAC,GAAG,IAAI,CAAC,CAAC;QACtB,CAAC;IACH,CAAC,CAAC;AACJ,CAAC;AAEM,KAAK,UAAU,iCAAiC,CACrD,OAAY,EACZ,IAAgD;IAEhD,KAAK,MAAM,MAAM,IAAI,OAAO,CAAE,CAAC;QAC7B,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,CAAC;QACjC,IAAI,KAAK,IAAI,IAAI,EAAE,CAAC;YAClB,OAAO,KAAK,CAAC;QACf,CAAC;IACH,CAAC;IACD,OAAO,IAAI,CAAC;AACd,CAAC","ignoreList":[0]}},
    {"offset": {"line": 886, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 892, "column": 0}, "map": {"version":3,"file":"makeGatewayGraphQLRequestContext.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/utils/makeGatewayGraphQLRequestContext.ts"],"sourcesContent":["import type {\n  GatewayGraphQLRequest,\n  GatewayGraphQLRequestContext,\n  GatewayGraphQLResponse,\n  GatewaySchemaHash,\n} from '@apollo/server-gateway-interface';\nimport type { FetcherHeaders } from '@apollo/utils.fetcher';\nimport type { ApolloServer, ApolloServerInternals } from '../ApolloServer';\nimport type {\n  BaseContext,\n  GraphQLRequestContextExecutionDidStart,\n} from '../externalTypes';\nimport type { HeaderMap } from './HeaderMap';\n\n// Apollo Gateway's API included `GraphQLRequestContext` from AS2/AS3.\n// Specifically, a request context is passed to the main executor method, which\n// it then exposes to user-configurable `GraphQLDataSource`s.\n// `GraphQLRequestContext` has changed in incompatible ways in AS4; for example,\n// we represent HTTP messages using our own data structures rather than Fetches,\n// and some fields have been removed because they relate to features that don't\n// exist any more.\n//\n// In general, the future of Apollo's development is in Apollo Router, not\n// Gateway. So rather than have a big transition where a new version of Gateway\n// supports AS4's GraphQLRequestContext instead of AS3's, we simply teach AS4\n// how to produce AS3-style GraphQLRequestContext objects specifically for use\n// by Gateway. We have changed Gateway to get its TS type definitions from a new\n// package rather than from AS3 itself, so that Gateway no longer needs to\n// depend on Apollo Server.\n//\n// This function turn an AS4 GraphQLRequestContext into a\n// GatewayGraphQLRequestContext (which is basically an AS3\n// GraphQLRequestContext).\n//\n// You might think that *after* invoking the executor, we would then need to\n// propagate any changes made by the gateway back onto the \"real\"\n// GraphQLRequestContext. It turns out that for each bit of data on the request\n// context, this is either unnecessary or impossible. (We don't need to support\n// use cases where people break type safe, eg by changing the values of readonly\n// fields.) Here's why:\n//\n// Many fields on GatewayGraphQLRequestContext are declared readonly and their\n// values are taken directly from the real GraphQLRequestContext. This means\n// that gateways should not change the field's value, and any mutations of the\n// object stored in the field (say, calling\n// `requestContext.overallCachePolicy.restrict`, as RemoteGraphQLDataSource\n// does) already take effect.\n//\n//  The only two fields not declared as readonly are `logger` and `debug`.\n//\n// Technically, a gateway implementation could set `requestContext.logger` to a\n// different Logger without breaking the TypeScript declarations. In AS4 we\n// don't actually have a requestContext.logger; we have `readonly\n// requestContext.server` and `readonly server.logger`. So there's not an easy\n// way for us to carry out this change: AS4 just doesn't let gateway or plugins\n// override the server's logger (and generally doesn't allow the logger to\n// change after the server is created), which seems like a simpler model. If it\n// turns out there is a real use case for the gateway to be able to change the\n// overall logger for the request as seen by plugins, we can fix that later.\n//\n// Similarly, it's not clear what the intended use case of mutating `debug` in\n// gateway would be. `debug` has now mostly changed into\n// `includeStacktraceInErrorResponses`. So perhaps this could be used to let you\n// decide whether or not to include the stacktrace on a per-operation basis...\n// but you can also use `formatError` or `didEncounterErrors` for this perhaps?\n// In any case, AS4 doesn't track `includeStacktraceInErrorResponses` on a\n// per-operation basis; if we find a use case for this we can add it later.\n//\n// So we'll just ignore changes to `logger` and `debug`.\n//\n// Next, there's `request`. We don't know of a use case for mutating the\n// *request* at execution time. If there was a real use case, we could add a\n// function that copies pieces back from the gateway `request` to the AS4\n// request, but we're not bothering to yet.\n//\n// Finally, there's `response`. Sure, the executor *could* mutate `response`.\n// But the main thing the executor is doing is *returning* a response, which\n// then semi-overwrites `requestContext.response` anyway. So it doesn't seem\n// like we need to support `executor` *also* overwriting response. Yet again, we\n// can fix this if it turns out it's necessary. (That said, the executor could\n// in theory write HTTP response headers or status, so we make sure to hook them\n// up directly to the appropriate data in the real GraphQLRequestContext.)\n//\n// So all in all, it looks like it's OK for this to be a \"one-way\" conversion.\nexport function makeGatewayGraphQLRequestContext<TContext extends BaseContext>(\n  as4RequestContext: GraphQLRequestContextExecutionDidStart<TContext>,\n  server: ApolloServer<TContext>,\n  internals: ApolloServerInternals<TContext>,\n): GatewayGraphQLRequestContext {\n  const request: GatewayGraphQLRequest = {};\n  if ('query' in as4RequestContext.request) {\n    request.query = as4RequestContext.request.query;\n  }\n  if ('operationName' in as4RequestContext.request) {\n    request.operationName = as4RequestContext.request.operationName;\n  }\n  if ('variables' in as4RequestContext.request) {\n    request.variables = as4RequestContext.request.variables;\n  }\n  if ('extensions' in as4RequestContext.request) {\n    request.extensions = as4RequestContext.request.extensions;\n  }\n  if (as4RequestContext.request.http) {\n    const as4http = as4RequestContext.request.http;\n    const needQuestion =\n      as4http.search !== '' && !as4http.search.startsWith('?');\n    request.http = {\n      method: as4http.method,\n      // As of AS4, we no longer attempt to track complete URLs (just the search\n      // parameters used in GET requests). So we have to fake them for Gateway.\n      url: `https://unknown-url.invalid/${needQuestion ? '?' : ''}${\n        as4http.search\n      }`,\n      headers: new FetcherHeadersForHeaderMap(as4http.headers),\n    };\n  }\n\n  const response: GatewayGraphQLResponse = {\n    http: {\n      headers: new FetcherHeadersForHeaderMap(\n        as4RequestContext.response.http.headers,\n      ),\n      get status() {\n        return as4RequestContext.response.http.status;\n      },\n      set status(newStatus) {\n        as4RequestContext.response.http.status = newStatus;\n      },\n    },\n    // We leave off `body` because it hasn't been set yet.\n  };\n\n  return {\n    request,\n    response,\n    logger: server.logger,\n    schema: as4RequestContext.schema,\n    // For the sake of typechecking, we still provide this field, but we don't\n    // calculate it. If somebody really needs it in their gateway\n    // implementation, they're welcome to copy\n    // https://github.com/apollographql/apollo-server/blob/3f218e78/packages/apollo-server-core/src/utils/schemaHash.ts\n    // into their code.\n    schemaHash:\n      'schemaHash no longer exists in Apollo Server 4' as GatewaySchemaHash,\n    context: as4RequestContext.contextValue,\n    cache: server.cache,\n    queryHash: as4RequestContext.queryHash,\n    document: as4RequestContext.document,\n    source: as4RequestContext.source,\n    operationName: as4RequestContext.operationName,\n    operation: as4RequestContext.operation,\n    errors: as4RequestContext.errors,\n    metrics: as4RequestContext.metrics,\n    debug: internals.includeStacktraceInErrorResponses,\n    overallCachePolicy: as4RequestContext.overallCachePolicy,\n    requestIsBatched: as4RequestContext.requestIsBatched,\n  };\n}\n\n// An implementation of the W3C-style headers class used by Gateway (and AS3),\n// backed by AS4's HeaderMap. Changes are written directly to the HeaderMap, so\n// any concurrent writes to the underlying HeaderMap (eg from a plugin) can be\n// seen immediately by the gateway and vice versa.\nclass FetcherHeadersForHeaderMap implements FetcherHeaders {\n  constructor(private map: HeaderMap) {}\n  append(name: string, value: string) {\n    if (this.map.has(name)) {\n      this.map.set(name, this.map.get(name) + ', ' + value);\n    } else {\n      this.map.set(name, value);\n    }\n  }\n  delete(name: string) {\n    this.map.delete(name);\n  }\n  get(name: string): string | null {\n    return this.map.get(name) ?? null;\n  }\n  has(name: string): boolean {\n    return this.map.has(name);\n  }\n  set(name: string, value: string) {\n    this.map.set(name, value);\n  }\n  entries(): Iterator<[string, string]> {\n    return this.map.entries();\n  }\n  keys(): Iterator<string> {\n    return this.map.keys();\n  }\n  values(): Iterator<string> {\n    return this.map.values();\n  }\n  [Symbol.iterator](): Iterator<[string, string]> {\n    return this.map.entries();\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 985, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 991, "column": 0}, "map": {"version":3,"file":"incrementalDeliveryPolyfill.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/incrementalDeliveryPolyfill.ts"],"sourcesContent":["import {\n  execute,\n  type ExecutionArgs,\n  type ExecutionResult,\n  type GraphQLError,\n} from 'graphql';\n\n// This file \"polyfills\" graphql@17's experimentalExecuteIncrementally (by\n// returning a function that does not understand incremental directives if\n// you're using graphql@16). The types defined in this file are largely copied\n// from graphql-js.\n\ninterface ObjMap<T> {\n  [key: string]: T;\n}\nexport interface GraphQLExperimentalInitialIncrementalExecutionResult<\n  TData = ObjMap<unknown>,\n  TExtensions = ObjMap<unknown>,\n> extends ExecutionResult<TData, TExtensions> {\n  hasNext: boolean;\n  incremental?: ReadonlyArray<\n    GraphQLExperimentalIncrementalResult<TData, TExtensions>\n  >;\n  extensions?: TExtensions;\n}\n\nexport interface GraphQLExperimentalSubsequentIncrementalExecutionResult<\n  TData = ObjMap<unknown>,\n  TExtensions = ObjMap<unknown>,\n> {\n  hasNext: boolean;\n  incremental?: ReadonlyArray<\n    GraphQLExperimentalIncrementalResult<TData, TExtensions>\n  >;\n  extensions?: TExtensions;\n}\n\ntype GraphQLExperimentalIncrementalResult<\n  TData = ObjMap<unknown>,\n  TExtensions = ObjMap<unknown>,\n> =\n  | GraphQLExperimentalIncrementalDeferResult<TData, TExtensions>\n  | GraphQLExperimentalIncrementalStreamResult<TData, TExtensions>;\n\ninterface GraphQLExperimentalIncrementalDeferResult<\n  TData = ObjMap<unknown>,\n  TExtensions = ObjMap<unknown>,\n> extends ExecutionResult<TData, TExtensions> {\n  path?: ReadonlyArray<string | number>;\n  label?: string;\n}\n\ninterface GraphQLExperimentalIncrementalStreamResult<\n  TData = Array<unknown>,\n  TExtensions = ObjMap<unknown>,\n> {\n  errors?: ReadonlyArray<GraphQLError>;\n  items?: TData | null;\n  path?: ReadonlyArray<string | number>;\n  label?: string;\n  extensions?: TExtensions;\n}\n\nexport interface GraphQLExperimentalIncrementalExecutionResults<\n  TData = ObjMap<unknown>,\n  TExtensions = ObjMap<unknown>,\n> {\n  initialResult: GraphQLExperimentalInitialIncrementalExecutionResult<\n    TData,\n    TExtensions\n  >;\n  subsequentResults: AsyncGenerator<\n    GraphQLExperimentalSubsequentIncrementalExecutionResult<TData, TExtensions>,\n    void,\n    void\n  >;\n}\n\ntype PromiseOrValue<T> = Promise<T> | T;\n\n// This starts as undefined and is set to a function or null by running\n// tryToLoadGraphQL17(). If graphql-js 17 is installed, it is set to the\n// experimentalExecuteIncrementally function from that package; otherwise it is\n// set to null.\nlet graphqlExperimentalExecuteIncrementally:\n  | ((\n      args: ExecutionArgs,\n    ) => PromiseOrValue<\n      ExecutionResult | GraphQLExperimentalIncrementalExecutionResults\n    >)\n  | null\n  | undefined = undefined;\n\nasync function tryToLoadGraphQL17() {\n  if (graphqlExperimentalExecuteIncrementally !== undefined) {\n    return;\n  }\n  const graphql = await import('graphql');\n  if ('experimentalExecuteIncrementally' in graphql) {\n    graphqlExperimentalExecuteIncrementally = (graphql as any)\n      .experimentalExecuteIncrementally;\n  } else {\n    graphqlExperimentalExecuteIncrementally = null;\n  }\n}\n\nexport async function executeIncrementally(\n  args: ExecutionArgs,\n): Promise<ExecutionResult | GraphQLExperimentalIncrementalExecutionResults> {\n  await tryToLoadGraphQL17();\n  if (graphqlExperimentalExecuteIncrementally) {\n    return graphqlExperimentalExecuteIncrementally(args);\n  }\n  return execute(args);\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EACL,OAAO,GAIR,MAAM,SAAS,CAAC;;AA+EjB,IAAI,uCAAuC,GAO3B,SAAS,CAAC;AAE1B,KAAK,UAAU,kBAAkB;IAC/B,IAAI,uCAAuC,KAAK,SAAS,EAAE,CAAC;QAC1D,OAAO;IACT,CAAC;IACD,MAAM,OAAO,GAAG,MAAM,MAAM,CAAC,SAAS,CAAC,CAAC;IACxC,IAAI,kCAAkC,IAAI,OAAO,EAAE,CAAC;QAClD,uCAAuC,GAAI,OAAe,CACvD,gCAAgC,CAAC;IACtC,CAAC,MAAM,CAAC;QACN,uCAAuC,GAAG,IAAI,CAAC;IACjD,CAAC;AACH,CAAC;AAEM,KAAK,UAAU,oBAAoB,CACxC,IAAmB;IAEnB,MAAM,kBAAkB,EAAE,CAAC;IAC3B,IAAI,uCAAuC,EAAE,CAAC;QAC5C,OAAO,uCAAuC,CAAC,IAAI,CAAC,CAAC;IACvD,CAAC;IACD,8JAAO,UAAA,AAAO,EAAC,IAAI,CAAC,CAAC;AACvB,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1015, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1021, "column": 0}, "map": {"version":3,"file":"requestPipeline.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/requestPipeline.ts"],"sourcesContent":["import { createHash } from '@apollo/utils.createhash';\nimport {\n  specifiedRules,\n  getOperationAST,\n  GraphQLError,\n  validate,\n  parse,\n  Kind,\n  type ExecutionResult,\n} from 'graphql';\nimport {\n  symbolExecutionDispatcherWillResolveField,\n  enablePluginsForSchemaResolvers,\n  symbolUserFieldResolver,\n} from './utils/schemaInstrumentation.js';\nimport {\n  PersistedQueryNotSupportedError,\n  PersistedQueryNotFoundError,\n  UserInputError,\n  BadRequestError,\n  ValidationError,\n  SyntaxError,\n  OperationResolutionError,\n} from './internalErrorClasses.js';\nimport {\n  ensureError,\n  normalizeAndFormatErrors,\n  ensureGraphQLError,\n} from './errorNormalize.js';\nimport type {\n  GraphQLRequestContext,\n  GraphQLRequestContextDidResolveSource,\n  GraphQLRequestContextExecutionDidStart,\n  GraphQLRequestContextResponseForOperation,\n  GraphQLRequestContextDidResolveOperation,\n  GraphQLRequestContextParsingDidStart,\n  GraphQLRequestContextValidationDidStart,\n  GraphQLRequestContextWillSendResponse,\n  GraphQLRequestContextDidEncounterErrors,\n  GraphQLRequestExecutionListener,\n  BaseContext,\n  GraphQLResponse,\n  GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult,\n} from './externalTypes/index.js';\n\nimport {\n  invokeDidStartHook,\n  invokeHooksUntilDefinedAndNonNull,\n  invokeSyncDidStartHook,\n} from './utils/invokeHooks.js';\n\nimport { makeGatewayGraphQLRequestContext } from './utils/makeGatewayGraphQLRequestContext.js';\n\nimport { mergeHTTPGraphQLHead, newHTTPGraphQLHead } from './runHttpQuery.js';\nimport type {\n  ApolloServer,\n  ApolloServerInternals,\n  SchemaDerivedData,\n} from './ApolloServer.js';\nimport { isDefined } from './utils/isDefined.js';\nimport type {\n  GraphQLRequestContextDidEncounterSubsequentErrors,\n  GraphQLRequestContextWillSendSubsequentPayload,\n} from './externalTypes/requestPipeline.js';\nimport {\n  executeIncrementally,\n  type GraphQLExperimentalInitialIncrementalExecutionResult,\n  type GraphQLExperimentalSubsequentIncrementalExecutionResult,\n} from './incrementalDeliveryPolyfill.js';\nimport { HeaderMap } from './utils/HeaderMap.js';\n\nexport const APQ_CACHE_PREFIX = 'apq:';\n\nfunction computeQueryHash(query: string) {\n  return createHash('sha256').update(query).digest('hex');\n}\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] };\n\nfunction isBadUserInputGraphQLError(error: GraphQLError): boolean {\n  return (\n    error.nodes?.length === 1 &&\n    error.nodes[0].kind === Kind.VARIABLE_DEFINITION &&\n    (error.message.startsWith(\n      `Variable \"$${error.nodes[0].variable.name.value}\" got invalid value `,\n    ) ||\n      error.message.startsWith(\n        `Variable \"$${error.nodes[0].variable.name.value}\" of required type `,\n      ) ||\n      error.message.startsWith(\n        `Variable \"$${error.nodes[0].variable.name.value}\" of non-null type `,\n      ))\n  );\n}\n\n// This is \"semi-formatted\" because the initial result has not yet been\n// formatted but the subsequent results \"have been\" --- in the sense that they\n// are an async iterable that will format them as they come in.\ntype SemiFormattedExecuteIncrementallyResults =\n  | {\n      singleResult: ExecutionResult;\n    }\n  | {\n      initialResult: GraphQLExperimentalInitialIncrementalExecutionResult;\n      subsequentResults: AsyncIterable<GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult>;\n    };\n\nexport async function processGraphQLRequest<TContext extends BaseContext>(\n  schemaDerivedData: SchemaDerivedData,\n  server: ApolloServer<TContext>,\n  internals: ApolloServerInternals<TContext>,\n  requestContext: Mutable<GraphQLRequestContext<TContext>>,\n): Promise<GraphQLResponse> {\n  const requestListeners = (\n    await Promise.all(\n      internals.plugins.map((p) => p.requestDidStart?.(requestContext)),\n    )\n  ).filter(isDefined);\n\n  const request = requestContext.request;\n\n  let { query, extensions } = request;\n\n  let queryHash: string;\n\n  requestContext.metrics.persistedQueryHit = false;\n  requestContext.metrics.persistedQueryRegister = false;\n\n  if (extensions?.persistedQuery) {\n    // It looks like we've received a persisted query. Check if we\n    // support them.\n    if (!internals.persistedQueries) {\n      return await sendErrorResponse([new PersistedQueryNotSupportedError()]);\n    } else if (extensions.persistedQuery.version !== 1) {\n      return await sendErrorResponse([\n        new GraphQLError('Unsupported persisted query version', {\n          extensions: { http: newHTTPGraphQLHead(400) },\n        }),\n      ]);\n    }\n\n    queryHash = extensions.persistedQuery.sha256Hash;\n\n    if (query === undefined) {\n      query = await internals.persistedQueries.cache.get(queryHash);\n      if (query) {\n        requestContext.metrics.persistedQueryHit = true;\n      } else {\n        return await sendErrorResponse([new PersistedQueryNotFoundError()]);\n      }\n    } else {\n      const computedQueryHash = computeQueryHash(query);\n\n      // The provided hash must exactly match the SHA-256 hash of\n      // the query string. This prevents hash hijacking, where a\n      // new and potentially malicious query is associated with\n      // an existing hash.\n      if (queryHash !== computedQueryHash) {\n        return await sendErrorResponse([\n          new GraphQLError('provided sha does not match query', {\n            extensions: { http: newHTTPGraphQLHead(400) },\n          }),\n        ]);\n      }\n\n      // We won't write to the persisted query cache until later.\n      // Deferring the writing gives plugins the ability to \"win\" from use of\n      // the cache, but also have their say in whether or not the cache is\n      // written to (by interrupting the request with an error).\n      requestContext.metrics.persistedQueryRegister = true;\n    }\n  } else if (query) {\n    queryHash = computeQueryHash(query);\n  } else {\n    return await sendErrorResponse([\n      new BadRequestError(\n        'GraphQL operations must contain a non-empty `query` or a `persistedQuery` extension.',\n      ),\n    ]);\n  }\n\n  requestContext.queryHash = queryHash;\n  requestContext.source = query;\n\n  // Let the plugins know that we now have a STRING of what we hope will\n  // parse and validate into a document we can execute on.  Unless we have\n  // retrieved this from our APQ cache, there's no guarantee that it is\n  // syntactically correct, so this string should not be trusted as a valid\n  // document until after it's parsed and validated.\n  await Promise.all(\n    requestListeners.map((l) =>\n      l.didResolveSource?.(\n        requestContext as GraphQLRequestContextDidResolveSource<TContext>,\n      ),\n    ),\n  );\n\n  // If we're configured with a document store (by default, we are), we'll\n  // utilize the operation's hash to lookup the AST from the previously\n  // parsed-and-validated operation.  Failure to retrieve anything from the\n  // cache just means we're committed to doing the parsing and validation.\n  if (schemaDerivedData.documentStore) {\n    try {\n      requestContext.document = await schemaDerivedData.documentStore.get(\n        schemaDerivedData.documentStoreKeyPrefix + queryHash,\n      );\n    } catch (err: unknown) {\n      server.logger.warn(\n        'An error occurred while attempting to read from the documentStore. ' +\n          ensureError(err).message,\n      );\n    }\n  }\n\n  // If we still don't have a document, we'll need to parse and validate it.\n  // With success, we'll attempt to save it into the store for future use.\n  if (!requestContext.document) {\n    const parsingDidEnd = await invokeDidStartHook(\n      requestListeners,\n      async (l) =>\n        l.parsingDidStart?.(\n          requestContext as GraphQLRequestContextParsingDidStart<TContext>,\n        ),\n    );\n\n    try {\n      requestContext.document = parse(query, internals.parseOptions);\n    } catch (syntaxMaybeError: unknown) {\n      const error = ensureError(syntaxMaybeError);\n      await parsingDidEnd(error);\n      return await sendErrorResponse([\n        new SyntaxError(ensureGraphQLError(error)),\n      ]);\n    }\n    await parsingDidEnd();\n\n    if (internals.dangerouslyDisableValidation !== true) {\n      const validationDidEnd = await invokeDidStartHook(\n        requestListeners,\n        async (l) =>\n          l.validationDidStart?.(\n            requestContext as GraphQLRequestContextValidationDidStart<TContext>,\n          ),\n      );\n\n      const validationErrors = validate(\n        schemaDerivedData.schema,\n        requestContext.document,\n        [...specifiedRules, ...internals.validationRules],\n      );\n\n      if (validationErrors.length === 0) {\n        await validationDidEnd();\n      } else {\n        await validationDidEnd(validationErrors);\n        return await sendErrorResponse(\n          validationErrors.map((error) => new ValidationError(error)),\n        );\n      }\n    }\n\n    if (schemaDerivedData.documentStore) {\n      // The underlying cache store behind the `documentStore` returns a\n      // `Promise` which is resolved (or rejected), eventually, based on the\n      // success or failure (respectively) of the cache save attempt.  While\n      // it's certainly possible to `await` this `Promise`, we don't care about\n      // whether or not it's successful at this point.  We'll instead proceed\n      // to serve the rest of the request and just hope that this works out.\n      // If it doesn't work, the next request will have another opportunity to\n      // try again.  Errors will surface as warnings, as appropriate.\n      //\n      // While it shouldn't normally be necessary to wrap this `Promise` in a\n      // `Promise.resolve` invocation, it seems that the underlying cache store\n      // is returning a non-native `Promise` (e.g. Bluebird, etc.).\n      Promise.resolve(\n        schemaDerivedData.documentStore.set(\n          schemaDerivedData.documentStoreKeyPrefix + queryHash,\n          requestContext.document,\n        ),\n      ).catch((err) =>\n        server.logger.warn(\n          'Could not store validated document. ' + err?.message || err,\n        ),\n      );\n    }\n  }\n\n  // TODO: If we want to guarantee an operation has been set when invoking\n  // `willExecuteOperation` and executionDidStart`, we need to throw an\n  // error here and not leave this to `buildExecutionContext` in\n  // `graphql-js`.\n  const operation = getOperationAST(\n    requestContext.document,\n    request.operationName,\n  );\n\n  requestContext.operation = operation || undefined;\n  // We'll set `operationName` to `null` for anonymous operations.\n  requestContext.operationName = operation?.name?.value || null;\n\n  // Special case: GET operations should only be queries (not mutations). We\n  // want to throw a particular HTTP error in that case. (This matters because\n  // it's generally how HTTP requests should work, and additionally it makes us\n  // less vulnerable to mutations running over CSRF, if you turn off our CSRF\n  // prevention feature.)\n  if (\n    request.http?.method === 'GET' &&\n    operation?.operation &&\n    operation.operation !== 'query'\n  ) {\n    return await sendErrorResponse([\n      new BadRequestError(\n        `GET requests only support query operations, not ${operation.operation} operations`,\n        {\n          extensions: {\n            http: { status: 405, headers: new HeaderMap([['allow', 'POST']]) },\n          },\n        },\n      ),\n    ]);\n  }\n\n  try {\n    await Promise.all(\n      requestListeners.map((l) =>\n        l.didResolveOperation?.(\n          requestContext as GraphQLRequestContextDidResolveOperation<TContext>,\n        ),\n      ),\n    );\n  } catch (err: unknown) {\n    // Note that we explicitly document throwing `GraphQLError`s from\n    // `didResolveOperation` as a good way to do validation that depends on the\n    // validated operation and the request context. (It will have status 500 by\n    // default.)\n    return await sendErrorResponse([ensureGraphQLError(err)]);\n  }\n\n  // Now that we've gone through the pre-execution phases of the request\n  // pipeline, and given plugins appropriate ability to object (by throwing\n  // an error) and not actually write, we'll write to the cache if it was\n  // determined earlier in the request pipeline that we should do so.\n  if (\n    requestContext.metrics.persistedQueryRegister &&\n    internals.persistedQueries\n  ) {\n    // While it shouldn't normally be necessary to wrap this `Promise` in a\n    // `Promise.resolve` invocation, it seems that the underlying cache store\n    // is returning a non-native `Promise` (e.g. Bluebird, etc.).\n    const ttl = internals.persistedQueries?.ttl;\n    Promise.resolve(\n      internals.persistedQueries.cache.set(\n        queryHash,\n        query,\n        // Explicitly checking for `undefined` which means \"not set\" vs 0 or\n        // null which means \"no TTL\".\n        ttl !== undefined\n          ? { ttl: internals.persistedQueries?.ttl }\n          : undefined,\n      ),\n    ).catch(server.logger.warn);\n  }\n\n  const responseFromPlugin = await invokeHooksUntilDefinedAndNonNull(\n    requestListeners,\n    async (l) =>\n      await l.responseForOperation?.(\n        requestContext as GraphQLRequestContextResponseForOperation<TContext>,\n      ),\n  );\n  if (responseFromPlugin !== null) {\n    requestContext.response.body = responseFromPlugin.body;\n    mergeHTTPGraphQLHead(requestContext.response.http, responseFromPlugin.http);\n  } else {\n    const executionListeners = (\n      await Promise.all(\n        requestListeners.map((l) =>\n          l.executionDidStart?.(\n            requestContext as GraphQLRequestContextExecutionDidStart<TContext>,\n          ),\n        ),\n      )\n    ).filter(isDefined);\n    executionListeners.reverse();\n\n    if (executionListeners.some((l) => l.willResolveField)) {\n      // Create a callback that will trigger the execution dispatcher's\n      // `willResolveField` hook.  We will attach this to the context on a\n      // symbol so it can be invoked by our `wrapField` method during execution.\n      const invokeWillResolveField: GraphQLRequestExecutionListener<TContext>['willResolveField'] =\n        (...args) =>\n          invokeSyncDidStartHook(executionListeners, (l) =>\n            l.willResolveField?.(...args),\n          );\n\n      Object.defineProperty(\n        requestContext.contextValue,\n        symbolExecutionDispatcherWillResolveField,\n        { value: invokeWillResolveField },\n      );\n\n      // If the user has provided a custom field resolver, we will attach\n      // it to the context so we can still invoke it after we've wrapped the\n      // fields with `wrapField` within `enablePluginsForSchemaResolvers` of\n      // the `schemaInstrumentation` module.\n      if (internals.fieldResolver) {\n        Object.defineProperty(\n          requestContext.contextValue,\n          symbolUserFieldResolver,\n          {\n            value: internals.fieldResolver,\n          },\n        );\n      }\n\n      // If the schema is already enabled, this is a no-op.  Otherwise, the\n      // schema will be augmented so it is able to invoke willResolveField. Note\n      // that if we never see a plugin with willResolveField then we will never\n      // need to instrument the schema, which might be a small performance gain.\n      // (For example, this can happen if you pass `fieldLevelInstrumentation:\n      // () => false` to the usage reporting plugin and disable the cache\n      // control plugin. We can consider changing the cache control plugin to\n      // have a \"static cache control only\" mode that doesn't use\n      // willResolveField too if this proves to be helpful in practice.)\n      enablePluginsForSchemaResolvers(schemaDerivedData.schema);\n    }\n\n    try {\n      const fullResult = await execute(\n        requestContext as GraphQLRequestContextExecutionDidStart<TContext>,\n      );\n      const result =\n        'singleResult' in fullResult\n          ? fullResult.singleResult\n          : fullResult.initialResult;\n\n      // If we don't have an operation, there's no reason to go further. We know\n      // `result` will consist of one error (returned by `graphql-js`'s\n      // `buildExecutionContext`).\n      if (!requestContext.operation) {\n        if (!result.errors?.length) {\n          throw new Error(\n            'Unexpected error: Apollo Server did not resolve an operation but execute did not return errors',\n          );\n        }\n        throw new OperationResolutionError(result.errors[0]);\n      }\n\n      // The first thing that execution does is coerce the request's variables\n      // to the types declared in the operation, which can lead to errors if\n      // they are of the wrong type. It also makes sure that all non-null\n      // variables are required and get non-null values. If any of these things\n      // lead to errors, we change them into UserInputError so that their code\n      // doesn't end up being INTERNAL_SERVER_ERROR, since these are client\n      // errors. (But if the error already has a code, perhaps because the\n      // original error was thrown from a custom scalar parseValue, we leave it\n      // alone. We check that here instead of as part of\n      // isBadUserInputGraphQLError since perhaps that function will one day be\n      // changed to something we can get directly from graphql-js, but the\n      // `code` check is AS-specific.)\n      //\n      // This is hacky! Hopefully graphql-js will give us a way to separate\n      // variable resolution from execution later; see\n      // https://github.com/graphql/graphql-js/issues/3169\n      const resultErrors = result.errors?.map((e) => {\n        if (isBadUserInputGraphQLError(e) && e.extensions?.code == null) {\n          return new UserInputError(e);\n        }\n        return e;\n      });\n\n      if (resultErrors) {\n        await didEncounterErrors(resultErrors);\n      }\n\n      const { formattedErrors, httpFromErrors } = resultErrors\n        ? formatErrors(resultErrors)\n        : { formattedErrors: undefined, httpFromErrors: newHTTPGraphQLHead() };\n\n      // TODO(AS5) This becomes the default behavior and the\n      // `status400ForVariableCoercionErrors` configuration option is removed /\n      // ignored.\n      if (\n        internals.status400ForVariableCoercionErrors &&\n        resultErrors?.length &&\n        result.data === undefined &&\n        !httpFromErrors.status\n      ) {\n        httpFromErrors.status = 400;\n      }\n\n      mergeHTTPGraphQLHead(requestContext.response.http, httpFromErrors);\n\n      if ('singleResult' in fullResult) {\n        requestContext.response.body = {\n          kind: 'single',\n          singleResult: {\n            ...result,\n            errors: formattedErrors,\n          },\n        };\n      } else {\n        requestContext.response.body = {\n          kind: 'incremental',\n          initialResult: {\n            ...fullResult.initialResult,\n            errors: formattedErrors,\n          },\n          subsequentResults: fullResult.subsequentResults,\n        };\n      }\n    } catch (executionMaybeError: unknown) {\n      const executionError = ensureError(executionMaybeError);\n      await Promise.all(\n        executionListeners.map((l) => l.executionDidEnd?.(executionError)),\n      );\n\n      return await sendErrorResponse([ensureGraphQLError(executionError)]);\n    }\n\n    await Promise.all(executionListeners.map((l) => l.executionDidEnd?.()));\n  }\n\n  await invokeWillSendResponse();\n  if (!requestContext.response.body) {\n    throw Error('got to end of processGraphQLRequest without setting body?');\n  }\n  return requestContext.response as GraphQLResponse; // cast checked on previous line\n\n  async function execute(\n    requestContext: GraphQLRequestContextExecutionDidStart<TContext>,\n  ): Promise<SemiFormattedExecuteIncrementallyResults> {\n    const { request, document } = requestContext;\n\n    if (internals.__testing_incrementalExecutionResults) {\n      return internals.__testing_incrementalExecutionResults;\n    } else if (internals.gatewayExecutor) {\n      const result = await internals.gatewayExecutor(\n        makeGatewayGraphQLRequestContext(requestContext, server, internals),\n      );\n      return { singleResult: result };\n    } else {\n      const resultOrResults = await executeIncrementally({\n        schema: schemaDerivedData.schema,\n        document,\n        rootValue:\n          typeof internals.rootValue === 'function'\n            ? internals.rootValue(document)\n            : internals.rootValue,\n        contextValue: requestContext.contextValue,\n        variableValues: request.variables,\n        operationName: request.operationName,\n        fieldResolver: internals.fieldResolver,\n      });\n      if ('initialResult' in resultOrResults) {\n        return {\n          initialResult: resultOrResults.initialResult,\n          subsequentResults: formatErrorsInSubsequentResults(\n            resultOrResults.subsequentResults,\n          ),\n        };\n      } else {\n        return { singleResult: resultOrResults };\n      }\n    }\n  }\n\n  async function* formatErrorsInSubsequentResults(\n    results: AsyncIterable<GraphQLExperimentalSubsequentIncrementalExecutionResult>,\n  ): AsyncIterable<GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult> {\n    for await (const result of results) {\n      const payload: GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult =\n        result.incremental\n          ? {\n              ...result,\n              incremental: await seriesAsyncMap(\n                result.incremental,\n                async (incrementalResult) => {\n                  const { errors } = incrementalResult;\n                  if (errors) {\n                    await Promise.all(\n                      requestListeners.map((l) =>\n                        l.didEncounterSubsequentErrors?.(\n                          requestContext as GraphQLRequestContextDidEncounterSubsequentErrors<TContext>,\n                          errors,\n                        ),\n                      ),\n                    );\n\n                    return {\n                      ...incrementalResult,\n                      // Note that any `http` extensions in errors have no\n                      // effect, because we've already sent the status code\n                      // and response headers.\n                      errors: formatErrors(errors).formattedErrors,\n                    };\n                  }\n                  return incrementalResult;\n                },\n              ),\n            }\n          : result;\n\n      // Invoke hook, which is allowed to mutate payload if it really wants to.\n      await Promise.all(\n        requestListeners.map((l) =>\n          l.willSendSubsequentPayload?.(\n            requestContext as GraphQLRequestContextWillSendSubsequentPayload<TContext>,\n            payload,\n          ),\n        ),\n      );\n\n      yield payload;\n    }\n  }\n\n  async function invokeWillSendResponse() {\n    await Promise.all(\n      requestListeners.map((l) =>\n        l.willSendResponse?.(\n          requestContext as GraphQLRequestContextWillSendResponse<TContext>,\n        ),\n      ),\n    );\n  }\n\n  // Note that we ensure that all calls to didEncounterErrors are followed by\n  // calls to willSendResponse. (The usage reporting plugin depends on this.)\n  async function didEncounterErrors(errors: ReadonlyArray<GraphQLError>) {\n    requestContext.errors = errors;\n\n    return await Promise.all(\n      requestListeners.map((l) =>\n        l.didEncounterErrors?.(\n          requestContext as GraphQLRequestContextDidEncounterErrors<TContext>,\n        ),\n      ),\n    );\n  }\n\n  // This function \"sends\" a response that contains errors and no data (not even\n  // `data: null`) because the pipeline does not make it to a successful\n  // `execute` call. (It is *not* called for execution that happens to return\n  // some errors.) In this case \"send\" means \"update requestContext.response and\n  // invoke willSendResponse hooks\".\n  //\n  // If any errors have `extensions.http` set, it sets the response's status code\n  // and errors from them.\n  //\n  // Then, if the HTTP status code is not yet set, it sets it to 500.\n  async function sendErrorResponse(\n    errors: ReadonlyArray<GraphQLError>,\n  ): Promise<GraphQLResponse> {\n    await didEncounterErrors(errors);\n\n    const { formattedErrors, httpFromErrors } = formatErrors(errors);\n\n    requestContext.response.body = {\n      kind: 'single',\n      singleResult: {\n        errors: formattedErrors,\n      },\n    };\n\n    mergeHTTPGraphQLHead(requestContext.response.http, httpFromErrors);\n\n    if (!requestContext.response.http.status) {\n      requestContext.response.http.status = 500;\n    }\n\n    await invokeWillSendResponse();\n\n    // cast safe because we assigned to `body` above\n    return requestContext.response as GraphQLResponse;\n  }\n\n  function formatErrors(\n    errors: ReadonlyArray<GraphQLError>,\n  ): ReturnType<typeof normalizeAndFormatErrors> {\n    return normalizeAndFormatErrors(errors, {\n      formatError: internals.formatError,\n      includeStacktraceInErrorResponses:\n        internals.includeStacktraceInErrorResponses,\n    });\n  }\n}\n\nasync function seriesAsyncMap<T, U>(\n  ts: readonly T[],\n  fn: (value: T) => Promise<U>,\n): Promise<U[]> {\n  const us: U[] = [];\n  for (const t of ts) {\n    const u = await fn(t);\n    us.push(u);\n  }\n  return us;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1349, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1355, "column": 0}, "map": {"version":3,"file":"UnreachableCaseError.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/utils/UnreachableCaseError.ts"],"sourcesContent":["/**\n * Throw this in places that should be unreachable (because all other cases have\n * been handled, reducing the type of the argument to `never`). TypeScript will\n * complain if in fact there is a valid type for the argument.\n */\nexport class UnreachableCaseError extends Error {\n  constructor(val: never) {\n    super(`Unreachable case: ${val}`);\n  }\n}\n"],"names":[],"mappings":";;;AAKM,MAAO,oBAAqB,SAAQ,KAAK;IAC7C,YAAY,GAAU,CAAA;QACpB,KAAK,CAAC,CAAA,kBAAA,EAAqB,GAAG,EAAE,CAAC,CAAC;IACpC,CAAC;CACF","ignoreList":[0]}},
    {"offset": {"line": 1363, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1369, "column": 0}, "map": {"version":3,"file":"computeCoreSchemaHash.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/utils/computeCoreSchemaHash.ts"],"sourcesContent":["import { createHash } from '@apollo/utils.createhash';\n\n// This hash function is used in both the schema reporting and usage reporting\n// plugins. Making sure we use the same hash function hypothetically allows the\n// two reporting features to work well together, though in practice nothing on\n// the Studio side currently correlates this ID across both features.\nexport function computeCoreSchemaHash(schema: string): string {\n  return createHash('sha256').update(schema).digest('hex');\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,0BAA0B,CAAC;;AAMhD,SAAU,qBAAqB,CAAC,MAAc;IAClD,8KAAO,aAAA,AAAU,EAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AAC3D,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1377, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1383, "column": 0}, "map": {"version":3,"file":"schemaManager.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/utils/schemaManager.ts"],"sourcesContent":["import type { Logger } from '@apollo/utils.logger';\nimport type { GraphQLSchema } from 'graphql';\nimport type {\n  GatewayExecutor,\n  GatewayInterface,\n  GatewayUnsubscriber,\n} from '@apollo/server-gateway-interface';\nimport type { SchemaDerivedData } from '../ApolloServer.js';\nimport type {\n  ApolloConfig,\n  GraphQLSchemaContext,\n} from '../externalTypes/index.js';\n\ntype SchemaDerivedDataProvider = (\n  apiSchema: GraphQLSchema,\n) => SchemaDerivedData;\n\n/**\n * An async-safe class for tracking changes in schemas and schema-derived data.\n *\n * Specifically, as long as start() is called (and completes) before stop() is\n * called, any set of executions of public methods is linearizable.\n *\n * Note that linearizability in Javascript is trivial if all public methods are\n * non-async, but increasingly difficult to guarantee if public methods become\n * async. Accordingly, if you believe a public method should be async, think\n * carefully on whether it's worth the mental overhead. (E.g. if you wished that\n * a callback was async, consider instead resolving a Promise in a non-async\n * callback and having your async code wait on the Promise in setTimeout().)\n */\nexport class SchemaManager {\n  private readonly logger: Logger;\n  private readonly schemaDerivedDataProvider: SchemaDerivedDataProvider;\n  private readonly onSchemaLoadOrUpdateListeners = new Set<\n    (schemaContext: GraphQLSchemaContext) => void\n  >();\n  private isStopped = false;\n  private schemaDerivedData?: SchemaDerivedData;\n  private schemaContext?: GraphQLSchemaContext;\n\n  // For state that's specific to the mode of operation.\n  private readonly modeSpecificState:\n    | {\n        readonly mode: 'gateway';\n        readonly gateway: GatewayInterface;\n        readonly apolloConfig: ApolloConfig;\n        unsubscribeFromGateway?: GatewayUnsubscriber;\n      }\n    | {\n        readonly mode: 'schema';\n        readonly apiSchema: GraphQLSchema;\n        readonly schemaDerivedData: SchemaDerivedData;\n      };\n\n  constructor(\n    options: (\n      | { gateway: GatewayInterface; apolloConfig: ApolloConfig }\n      | { apiSchema: GraphQLSchema }\n    ) & {\n      logger: Logger;\n      schemaDerivedDataProvider: SchemaDerivedDataProvider;\n    },\n  ) {\n    this.logger = options.logger;\n    this.schemaDerivedDataProvider = options.schemaDerivedDataProvider;\n    if ('gateway' in options) {\n      this.modeSpecificState = {\n        mode: 'gateway',\n        gateway: options.gateway,\n        apolloConfig: options.apolloConfig,\n      };\n    } else {\n      this.modeSpecificState = {\n        mode: 'schema',\n        apiSchema: options.apiSchema,\n        // The caller of the constructor expects us to fail early if the schema\n        // given is invalid/has errors, so we call the provider here. We also\n        // pass the result to start(), as the provider can be expensive to call.\n        schemaDerivedData: options.schemaDerivedDataProvider(options.apiSchema),\n      };\n    }\n  }\n\n  /**\n   * Calling start() will:\n   * - Start gateway schema fetching (if a gateway was provided).\n   * - Initialize schema-derived data.\n   * - Synchronously notify onSchemaLoadOrUpdate() listeners of schema load, and\n   *   asynchronously notify them of schema updates.\n   * - If we started a gateway, returns the gateway's executor; otherwise null.\n   */\n  public async start(): Promise<GatewayExecutor | null> {\n    if (this.modeSpecificState.mode === 'gateway') {\n      const gateway = this.modeSpecificState.gateway;\n      if (gateway.onSchemaLoadOrUpdate) {\n        // Use onSchemaLoadOrUpdate, as it reports the core supergraph SDL and\n        // always reports the initial schema load.\n        this.modeSpecificState.unsubscribeFromGateway =\n          gateway.onSchemaLoadOrUpdate((schemaContext) => {\n            this.processSchemaLoadOrUpdateEvent(schemaContext);\n          });\n      } else {\n        throw new Error(\n          \"Unexpectedly couldn't find onSchemaLoadOrUpdate on gateway\",\n        );\n      }\n\n      const config = await this.modeSpecificState.gateway.load({\n        apollo: this.modeSpecificState.apolloConfig,\n      });\n\n      return config.executor;\n    } else {\n      this.processSchemaLoadOrUpdateEvent(\n        {\n          apiSchema: this.modeSpecificState.apiSchema,\n        },\n        this.modeSpecificState.schemaDerivedData,\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Registers a listener for schema load/update events. Note that the latest\n   * event is buffered, i.e.\n   * - If registered before start(), this method will throw. (We have no need\n   *   for registration before start(), but this is easy enough to change.)\n   * - If registered after start() but before stop(), the callback will be first\n   *   called in this method (for whatever the current schema is), and then\n   *   later for updates.\n   * - If registered after stop(), the callback will never be called.\n   *\n   * For gateways, a core supergraph SDL will be provided to the callback.\n   *\n   * @param callback The listener to execute on schema load/updates.\n   */\n  public onSchemaLoadOrUpdate(\n    callback: (schemaContext: GraphQLSchemaContext) => void,\n  ): GatewayUnsubscriber {\n    if (!this.schemaContext) {\n      throw new Error('You must call start() before onSchemaLoadOrUpdate()');\n    }\n    if (!this.isStopped) {\n      try {\n        callback(this.schemaContext);\n      } catch (e) {\n        // Note that onSchemaLoadOrUpdate() is currently only called from\n        // ApolloServer._start(), so we throw here to alert the user early\n        // that their callback is failing.\n        throw new Error(\n          `An error was thrown from an 'onSchemaLoadOrUpdate' listener: ${\n            (e as Error).message\n          }`,\n        );\n      }\n    }\n    this.onSchemaLoadOrUpdateListeners.add(callback);\n\n    return () => {\n      this.onSchemaLoadOrUpdateListeners.delete(callback);\n    };\n  }\n\n  /**\n   * Get the schema-derived state for the current schema. This throws if called\n   * before start() is called.\n   */\n  public getSchemaDerivedData(): SchemaDerivedData {\n    if (!this.schemaDerivedData) {\n      throw new Error('You must call start() before getSchemaDerivedData()');\n    }\n    return this.schemaDerivedData;\n  }\n\n  /**\n   * Calling stop() will:\n   * - Stop gateway schema fetching (if a gateway was provided).\n   *   - Note that this specific step may not succeed if gateway is old.\n   * - Stop updating schema-derived data.\n   * - Stop notifying onSchemaLoadOrUpdate() listeners.\n   */\n  public async stop(): Promise<void> {\n    this.isStopped = true;\n    if (this.modeSpecificState.mode === 'gateway') {\n      this.modeSpecificState.unsubscribeFromGateway?.();\n      await this.modeSpecificState.gateway.stop?.();\n    }\n  }\n\n  private processSchemaLoadOrUpdateEvent(\n    schemaContext: GraphQLSchemaContext,\n    schemaDerivedData?: SchemaDerivedData,\n  ): void {\n    if (!this.isStopped) {\n      this.schemaDerivedData =\n        schemaDerivedData ??\n        this.schemaDerivedDataProvider(schemaContext.apiSchema);\n      this.schemaContext = schemaContext;\n      this.onSchemaLoadOrUpdateListeners.forEach((listener) => {\n        try {\n          listener(schemaContext);\n        } catch (e) {\n          this.logger.error(\n            \"An error was thrown from an 'onSchemaLoadOrUpdate' listener\",\n          );\n          this.logger.error(e);\n        }\n      });\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1471, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1477, "column": 0}, "map": {"version":3,"file":"ApolloServer.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/ApolloServer.ts"],"sourcesContent":["import type { GatewayExecutor } from '@apollo/server-gateway-interface';\nimport { isNodeLike } from '@apollo/utils.isnodelike';\nimport {\n  InMemoryLRUCache,\n  PrefixingKeyValueCache,\n  type KeyValueCache,\n} from '@apollo/utils.keyvaluecache';\nimport type { Logger } from '@apollo/utils.logger';\nimport type { WithRequired } from '@apollo/utils.withrequired';\nimport { makeExecutableSchema } from '@graphql-tools/schema';\nimport resolvable, { type Resolvable } from './utils/resolvable.js';\nimport {\n  GraphQLError,\n  assertValidSchema,\n  print,\n  printSchema,\n  type DocumentNode,\n  type FormattedExecutionResult,\n  type GraphQLFieldResolver,\n  type GraphQLFormattedError,\n  type GraphQLSchema,\n  type ParseOptions,\n  type TypedQueryDocumentNode,\n  type ValidationContext,\n  type ValidationRule,\n} from 'graphql';\nimport loglevel from 'loglevel';\nimport Negotiator from 'negotiator';\nimport { newCachePolicy } from './cachePolicy.js';\nimport { determineApolloConfig } from './determineApolloConfig.js';\nimport {\n  ensureError,\n  ensureGraphQLError,\n  normalizeAndFormatErrors,\n} from './errorNormalize.js';\nimport {\n  ApolloServerErrorCode,\n  ApolloServerValidationErrorCode,\n} from './errors/index.js';\nimport type { ApolloServerOptionsWithStaticSchema } from './externalTypes/constructor.js';\nimport type {\n  ExecuteOperationOptions,\n  VariableValues,\n} from './externalTypes/graphql.js';\nimport type {\n  ApolloConfig,\n  ApolloServerOptions,\n  ApolloServerPlugin,\n  BaseContext,\n  ContextThunk,\n  DocumentStore,\n  GraphQLRequest,\n  GraphQLRequestContext,\n  GraphQLResponse,\n  GraphQLServerContext,\n  GraphQLServerListener,\n  HTTPGraphQLHead,\n  HTTPGraphQLRequest,\n  HTTPGraphQLResponse,\n  LandingPage,\n  PersistedQueryOptions,\n} from './externalTypes/index.js';\nimport { runPotentiallyBatchedHttpQuery } from './httpBatching.js';\nimport type { GraphQLExperimentalIncrementalExecutionResults } from './incrementalDeliveryPolyfill.js';\nimport { pluginIsInternal, type InternalPluginId } from './internalPlugin.js';\nimport {\n  preventCsrf,\n  recommendedCsrfPreventionRequestHeaders,\n} from './preventCsrf.js';\nimport { APQ_CACHE_PREFIX, processGraphQLRequest } from './requestPipeline.js';\nimport { newHTTPGraphQLHead, prettyJSONStringify } from './runHttpQuery.js';\nimport { HeaderMap } from './utils/HeaderMap.js';\nimport { UnreachableCaseError } from './utils/UnreachableCaseError.js';\nimport { computeCoreSchemaHash } from './utils/computeCoreSchemaHash.js';\nimport { isDefined } from './utils/isDefined.js';\nimport { SchemaManager } from './utils/schemaManager.js';\n\nconst NoIntrospection: ValidationRule = (context: ValidationContext) => ({\n  Field(node) {\n    if (node.name.value === '__schema' || node.name.value === '__type') {\n      context.reportError(\n        new GraphQLError(\n          'GraphQL introspection is not allowed by Apollo Server, but the query contained __schema or __type. To enable introspection, pass introspection: true to ApolloServer in production',\n          {\n            nodes: [node],\n            extensions: {\n              validationErrorCode:\n                ApolloServerValidationErrorCode.INTROSPECTION_DISABLED,\n            },\n          },\n        ),\n      );\n    }\n  },\n});\n\nexport type SchemaDerivedData = {\n  schema: GraphQLSchema;\n  // A store that, when enabled (default), will store the parsed and validated\n  // versions of operations in-memory, allowing subsequent parses/validates\n  // on the same operation to be executed immediately.\n  documentStore: DocumentStore | null;\n  // Prefix for keys in the DocumentStore if a custom one is provided (to\n  // separate the cache for different schema versions). This is vital to\n  // security so we do it explicitly so that\n  // PrefixingKeyValueCache.cacheDangerouslyDoesNotNeedPrefixesForIsolation\n  // doesn't affect it.\n  documentStoreKeyPrefix: string;\n};\n\ntype RunningServerState = {\n  schemaManager: SchemaManager;\n  landingPage: LandingPage | null;\n};\n\ntype ServerState =\n  | {\n      phase: 'initialized';\n      schemaManager: SchemaManager;\n    }\n  | {\n      phase: 'starting';\n      barrier: Resolvable<void>;\n      schemaManager: SchemaManager;\n      // This is set to true if you called\n      // startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests\n      // instead of start. The main purpose is that assertStarted allows you to\n      // still be in the starting phase if this is set. (This is the serverless\n      // use case.)\n      startedInBackground: boolean;\n    }\n  | {\n      phase: 'failed to start';\n      error: Error;\n    }\n  | ({\n      phase: 'started';\n      drainServers: (() => Promise<void>) | null;\n      toDispose: (() => Promise<void>)[];\n      toDisposeLast: (() => Promise<void>)[];\n    } & RunningServerState)\n  | ({\n      phase: 'draining';\n      barrier: Resolvable<void>;\n    } & RunningServerState)\n  | {\n      phase: 'stopping';\n      barrier: Resolvable<void>;\n    }\n  | {\n      phase: 'stopped';\n      stopError: Error | null;\n    };\n\nexport interface ApolloServerInternals<TContext extends BaseContext> {\n  state: ServerState;\n  gatewayExecutor: GatewayExecutor | null;\n  dangerouslyDisableValidation?: boolean;\n  formatError?: (\n    formattedError: GraphQLFormattedError,\n    error: unknown,\n  ) => GraphQLFormattedError;\n  includeStacktraceInErrorResponses: boolean;\n  persistedQueries?: WithRequired<PersistedQueryOptions, 'cache'>;\n  nodeEnv: string;\n  allowBatchedHttpRequests: boolean;\n  apolloConfig: ApolloConfig;\n  plugins: ApolloServerPlugin<TContext>[];\n  parseOptions: ParseOptions;\n  // `undefined` means we figure out what to do during _start (because\n  // the default depends on whether or not we used the background version\n  // of start).\n  stopOnTerminationSignals: boolean | undefined;\n  csrfPreventionRequestHeaders: string[] | null;\n\n  rootValue?: ((parsedQuery: DocumentNode) => unknown) | unknown;\n  validationRules: Array<ValidationRule>;\n  hideSchemaDetailsFromClientErrors: boolean;\n  fieldResolver?: GraphQLFieldResolver<any, TContext>;\n  // TODO(AS5): remove OR warn + ignore with this option set, ignore option and\n  // flip default behavior.\n  status400ForVariableCoercionErrors?: boolean;\n  __testing_incrementalExecutionResults?: GraphQLExperimentalIncrementalExecutionResults;\n  stringifyResult: (\n    value: FormattedExecutionResult,\n  ) => string | Promise<string>;\n}\n\nfunction defaultLogger(): Logger {\n  const loglevelLogger = loglevel.getLogger('apollo-server');\n  loglevelLogger.setLevel(loglevel.levels.INFO);\n  return loglevelLogger;\n}\n\n// We really want to prevent this from being legal:\n//\n//     const s: ApolloServer<{}> =\n//       new ApolloServer<{importantContextField: boolean}>({ ... });\n//     s.executeOperation({query}, {contextValue: {}});\n//\n// ie, if you declare an ApolloServer whose context values must be of a certain\n// type, you can't assign it to a variable whose context values are less\n// constrained and then pass in a context value missing important fields.\n//\n// We also want this to be illegal:\n//\n//     const sBase = new ApolloServer<{}>({ ... });\n//     const s: ApolloServer<{importantContextField: boolean}> = sBase;\n//     s.addPlugin({async requestDidStart({contextValue: {importantContextField}}) { ... }})\n//     sBase.executeOperation({query}, {contextValue: {}});\n//\n// so you shouldn't be able to assign an ApolloServer to a variable whose\n// context values are more constrained, either. So we want to declare that\n// ApolloServer is *invariant* in TContext, which we do with `in out` (a\n// TypeScript 4.7 feature).\nexport class ApolloServer<in out TContext extends BaseContext = BaseContext> {\n  private internals: ApolloServerInternals<TContext>;\n\n  public readonly cache: KeyValueCache<string>;\n  public readonly logger: Logger;\n\n  constructor(config: ApolloServerOptions<TContext>) {\n    const nodeEnv = config.nodeEnv ?? process.env.NODE_ENV ?? '';\n\n    this.logger = config.logger ?? defaultLogger();\n\n    const apolloConfig = determineApolloConfig(config.apollo, this.logger);\n\n    const isDev = nodeEnv !== 'production';\n\n    if (\n      config.cache &&\n      config.cache !== 'bounded' &&\n      PrefixingKeyValueCache.prefixesAreUnnecessaryForIsolation(config.cache)\n    ) {\n      throw new Error(\n        'You cannot pass a cache returned from ' +\n          '`PrefixingKeyValueCache.cacheDangerouslyDoesNotNeedPrefixesForIsolation`' +\n          'to `new ApolloServer({ cache })`, because Apollo Server may use it for ' +\n          'multiple features whose cache keys must be distinct from each other.',\n      );\n    }\n\n    const state: ServerState = config.gateway\n      ? // ApolloServer has been initialized but we have not yet tried to load the\n        // schema from the gateway. That will wait until `start()` or\n        // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests()`\n        // is called. (These may be called by other helpers; for example,\n        // `standaloneServer` calls `start` for you inside its `listen` method,\n        // and a serverless framework integration would call\n        // startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests\n        // for you.)\n        {\n          phase: 'initialized',\n          schemaManager: new SchemaManager({\n            gateway: config.gateway,\n            apolloConfig,\n            schemaDerivedDataProvider: (schema) =>\n              ApolloServer.generateSchemaDerivedData(\n                schema,\n                config.documentStore,\n              ),\n            logger: this.logger,\n          }),\n        }\n      : // We construct the schema synchronously so that we can fail fast if the\n        // schema can't be constructed. (This used to be more important because we\n        // used to have a 'schema' field that was publicly accessible immediately\n        // after construction, though that field never actually worked with\n        // gateways.)\n        {\n          phase: 'initialized',\n          schemaManager: new SchemaManager({\n            apiSchema: ApolloServer.constructSchema(config),\n            schemaDerivedDataProvider: (schema) =>\n              ApolloServer.generateSchemaDerivedData(\n                schema,\n                config.documentStore,\n              ),\n            logger: this.logger,\n          }),\n        };\n\n    const introspectionEnabled = config.introspection ?? isDev;\n    const hideSchemaDetailsFromClientErrors =\n      config.hideSchemaDetailsFromClientErrors ?? false;\n\n    // We continue to allow 'bounded' for backwards-compatibility with the AS3.9\n    // API.\n    this.cache =\n      config.cache === undefined || config.cache === 'bounded'\n        ? new InMemoryLRUCache()\n        : config.cache;\n\n    // Note that we avoid calling methods on `this` before `this.internals` is assigned\n    // (thus a bunch of things being static methods above).\n    this.internals = {\n      formatError: config.formatError,\n      rootValue: config.rootValue,\n      validationRules: [\n        ...(config.validationRules ?? []),\n        ...(introspectionEnabled ? [] : [NoIntrospection]),\n      ],\n      hideSchemaDetailsFromClientErrors,\n      dangerouslyDisableValidation:\n        config.dangerouslyDisableValidation ?? false,\n      fieldResolver: config.fieldResolver,\n      includeStacktraceInErrorResponses:\n        config.includeStacktraceInErrorResponses ??\n        (nodeEnv !== 'production' && nodeEnv !== 'test'),\n      persistedQueries:\n        config.persistedQueries === false\n          ? undefined\n          : {\n              ...config.persistedQueries,\n              cache: new PrefixingKeyValueCache(\n                config.persistedQueries?.cache ?? this.cache,\n                APQ_CACHE_PREFIX,\n              ),\n            },\n      nodeEnv,\n      allowBatchedHttpRequests: config.allowBatchedHttpRequests ?? false,\n      apolloConfig,\n      // Note that more plugins can be added before `start()` with `addPlugin()`\n      // (eg, plugins that want to take this ApolloServer as an argument), and\n      // `start()` will call `addDefaultPlugins` to add default plugins.\n      plugins: config.plugins ?? [],\n      parseOptions: config.parseOptions ?? {},\n      state,\n      stopOnTerminationSignals: config.stopOnTerminationSignals,\n\n      gatewayExecutor: null, // set by _start\n\n      csrfPreventionRequestHeaders:\n        config.csrfPrevention === true || config.csrfPrevention === undefined\n          ? recommendedCsrfPreventionRequestHeaders\n          : config.csrfPrevention === false\n            ? null\n            : (config.csrfPrevention.requestHeaders ??\n              recommendedCsrfPreventionRequestHeaders),\n      status400ForVariableCoercionErrors:\n        config.status400ForVariableCoercionErrors ?? false,\n      __testing_incrementalExecutionResults:\n        config.__testing_incrementalExecutionResults,\n      stringifyResult: config.stringifyResult ?? prettyJSONStringify,\n    };\n  }\n\n  // Awaiting a call to `start` ensures that a schema has been loaded and that\n  // all plugin `serverWillStart` hooks have been called. If either of these\n  // processes throw, `start` will (async) throw as well.\n  //\n  // If you're using `standaloneServer`, you don't need to call `start` yourself\n  // (in fact, it will throw if you do so); its `listen` method takes care of\n  // that for you.\n  //\n  // If instead you're using an integration package for a non-serverless\n  // framework (like Express), you must await a call to `start` immediately\n  // after creating your `ApolloServer`, before attaching it to your web\n  // framework and starting to accept requests. `start` should only be called\n  // once; if it throws and you'd like to retry, just create another\n  // `ApolloServer`. (Calling `start` was optional in Apollo Server 2, but in\n  // Apollo Server 3+ the functions like `expressMiddleware` use `assertStarted`\n  // to throw if `start` hasn't successfully completed.)\n  //\n  // Serverless integrations like Lambda do not support calling `start()`,\n  // because their lifecycle doesn't allow you to wait before assigning a\n  // handler or allowing the handler to be called. So they call\n  // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests()`\n  // instead, and don't really differentiate between startup failures and\n  // request failures. This is hopefully appropriate for a \"serverless\"\n  // framework. Serverless startup failures result in returning a redacted error\n  // to the end user and logging the more detailed error.\n  public async start(): Promise<void> {\n    return await this._start(false);\n  }\n\n  public startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests(): void {\n    this._start(true).catch((e) => this.logStartupError(e));\n  }\n\n  private async _start(startedInBackground: boolean): Promise<void> {\n    if (this.internals.state.phase !== 'initialized') {\n      // If we wanted we could make this error detectable and change\n      // `standaloneServer` to change the message to say not to call start() at\n      // all.\n      throw new Error(\n        `You should only call 'start()' or ` +\n          `'startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests()' ` +\n          `once on your ApolloServer.`,\n      );\n    }\n    const schemaManager = this.internals.state.schemaManager;\n    const barrier = resolvable();\n    this.internals.state = {\n      phase: 'starting',\n      barrier,\n      schemaManager,\n      startedInBackground,\n    };\n    try {\n      // Now that you can't call addPlugin any more, add default plugins like\n      // usage reporting if they're not already added.\n      await this.addDefaultPlugins();\n\n      const toDispose: (() => Promise<void>)[] = [];\n      const executor = await schemaManager.start();\n      if (executor) {\n        this.internals.gatewayExecutor = executor;\n      }\n      toDispose.push(async () => {\n        await schemaManager.stop();\n      });\n\n      const schemaDerivedData = schemaManager.getSchemaDerivedData();\n      const service: GraphQLServerContext = {\n        logger: this.logger,\n        cache: this.cache,\n        schema: schemaDerivedData.schema,\n        apollo: this.internals.apolloConfig,\n        startedInBackground,\n      };\n\n      const taggedServerListeners = (\n        await Promise.all(\n          this.internals.plugins.map(async (plugin) => ({\n            serverListener:\n              plugin.serverWillStart && (await plugin.serverWillStart(service)),\n            installedImplicitly:\n              isImplicitlyInstallablePlugin(plugin) &&\n              plugin.__internal_installed_implicitly__,\n          })),\n        )\n      ).filter(\n        (\n          maybeTaggedServerListener,\n        ): maybeTaggedServerListener is {\n          serverListener: GraphQLServerListener;\n          installedImplicitly: boolean;\n        } => typeof maybeTaggedServerListener.serverListener === 'object',\n      );\n\n      taggedServerListeners.forEach(\n        ({ serverListener: { schemaDidLoadOrUpdate } }) => {\n          if (schemaDidLoadOrUpdate) {\n            schemaManager.onSchemaLoadOrUpdate(schemaDidLoadOrUpdate);\n          }\n        },\n      );\n\n      const serverWillStops = taggedServerListeners\n        .map((l) => l.serverListener.serverWillStop)\n        .filter(isDefined);\n      if (serverWillStops.length) {\n        toDispose.push(async () => {\n          await Promise.all(\n            serverWillStops.map((serverWillStop) => serverWillStop()),\n          );\n        });\n      }\n\n      const drainServerCallbacks = taggedServerListeners\n        .map((l) => l.serverListener.drainServer)\n        .filter(isDefined);\n      const drainServers = drainServerCallbacks.length\n        ? async () => {\n            await Promise.all(\n              drainServerCallbacks.map((drainServer) => drainServer()),\n            );\n          }\n        : null;\n\n      // Find the renderLandingPage callback, if one is provided. If the user\n      // installed ApolloServerPluginLandingPageDisabled then there may be none\n      // found. On the other hand, if the user installed a landingPage plugin,\n      // then both the implicit installation of\n      // ApolloServerPluginLandingPage*Default and the other plugin will be\n      // found; we skip the implicit plugin.\n      let taggedServerListenersWithRenderLandingPage =\n        taggedServerListeners.filter((l) => l.serverListener.renderLandingPage);\n      if (taggedServerListenersWithRenderLandingPage.length > 1) {\n        taggedServerListenersWithRenderLandingPage =\n          taggedServerListenersWithRenderLandingPage.filter(\n            (l) => !l.installedImplicitly,\n          );\n      }\n      let landingPage: LandingPage | null = null;\n      if (taggedServerListenersWithRenderLandingPage.length > 1) {\n        throw Error('Only one plugin can implement renderLandingPage.');\n      } else if (taggedServerListenersWithRenderLandingPage.length) {\n        landingPage =\n          await taggedServerListenersWithRenderLandingPage[0].serverListener\n            .renderLandingPage!();\n      }\n\n      const toDisposeLast = this.maybeRegisterTerminationSignalHandlers(\n        ['SIGINT', 'SIGTERM'],\n        startedInBackground,\n      );\n\n      this.internals.state = {\n        phase: 'started',\n        schemaManager,\n        drainServers,\n        landingPage,\n        toDispose,\n        toDisposeLast,\n      };\n    } catch (maybeError: unknown) {\n      const error = ensureError(maybeError);\n\n      try {\n        await Promise.all(\n          this.internals.plugins.map(async (plugin) =>\n            plugin.startupDidFail?.({ error }),\n          ),\n        );\n      } catch (pluginError) {\n        this.logger.error(`startupDidFail hook threw: ${pluginError}`);\n      }\n\n      this.internals.state = {\n        phase: 'failed to start',\n        error,\n      };\n      throw error;\n    } finally {\n      barrier.resolve();\n    }\n  }\n\n  private maybeRegisterTerminationSignalHandlers(\n    signals: NodeJS.Signals[],\n    startedInBackground: boolean,\n  ): (() => Promise<void>)[] {\n    const toDisposeLast: (() => Promise<void>)[] = [];\n\n    // We handle signals if it was explicitly requested\n    // (stopOnTerminationSignals === true), or if we're in Node, not in a test,\n    // not in a serverless framework (which we guess based on whether they\n    // called\n    // startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests),\n    // and it wasn't explicitly turned off. (We only actually register the\n    // signal handlers once we've successfully started up, because there's\n    // nothing to stop otherwise.)\n    if (\n      this.internals.stopOnTerminationSignals === false ||\n      (this.internals.stopOnTerminationSignals === undefined &&\n        !(\n          isNodeLike &&\n          this.internals.nodeEnv !== 'test' &&\n          !startedInBackground\n        ))\n    ) {\n      return toDisposeLast;\n    }\n\n    let receivedSignal = false;\n    const signalHandler: NodeJS.SignalsListener = async (signal) => {\n      if (receivedSignal) {\n        // If we receive another SIGINT or SIGTERM while we're waiting\n        // for the server to stop, just ignore it.\n        return;\n      }\n      receivedSignal = true;\n      try {\n        await this.stop();\n      } catch (e) {\n        this.logger.error(`stop() threw during ${signal} shutdown`);\n        this.logger.error(e);\n        // Can't rely on the signal handlers being removed.\n        process.exit(1);\n      }\n      // Note: this.stop will call the toDisposeLast handlers below, so at\n      // this point this handler will have been removed and we can re-kill\n      // ourself to die with the appropriate signal exit status. this.stop\n      // takes care to call toDisposeLast last, so the signal handler isn't\n      // removed until after the rest of shutdown happens.\n      process.kill(process.pid, signal);\n    };\n\n    signals.forEach((signal) => {\n      process.on(signal, signalHandler);\n      toDisposeLast.push(async () => {\n        process.removeListener(signal, signalHandler);\n      });\n    });\n    return toDisposeLast;\n  }\n\n  // This method is called at the beginning of each GraphQL request by\n  // `executeHTTPGraphQLRequest` and `executeOperation`. Most of its logic is\n  // only helpful if you started the server in the background (ie, for\n  // serverless frameworks): unless you're in a serverless framework, you should\n  // have called `await server.start()` before the server got to the point of\n  // running GraphQL requests (`assertStarted` calls in the framework\n  // integrations verify that) and so the only cases for non-serverless\n  // frameworks that this should hit are 'started', 'stopping', and 'stopped'.\n  // But if you started the server in the background (with\n  // startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests), this\n  // lets the server wait until fully started before serving operations.\n  private async _ensureStarted(): Promise<RunningServerState> {\n    while (true) {\n      switch (this.internals.state.phase) {\n        case 'initialized':\n          // This error probably won't happen: serverless framework integrations\n          // should call\n          // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests`\n          // for you, and other frameworks call `assertStarted` before setting\n          // things up enough to make calling this function possible.\n          throw new Error(\n            'You need to call `server.start()` before using your Apollo Server.',\n          );\n        case 'starting':\n          await this.internals.state.barrier;\n          // continue the while loop\n          break;\n        case 'failed to start':\n          // First we log the error that prevented startup (which means it will\n          // get logged once for every GraphQL operation).\n          this.logStartupError(this.internals.state.error);\n          // Now make the operation itself fail.\n          // We intentionally do not re-throw actual startup error as it may contain\n          // implementation details and this error will propagate to the client.\n          throw new Error(\n            'This data graph is missing a valid configuration. More details may be available in the server logs.',\n          );\n        case 'started':\n        case 'draining': // We continue to run operations while draining.\n          return this.internals.state;\n        case 'stopping':\n        case 'stopped':\n          this.logger.warn(\n            'A GraphQL operation was received during server shutdown. The ' +\n              'operation will fail. Consider draining the HTTP server on shutdown; ' +\n              'see https://go.apollo.dev/s/drain for details.',\n          );\n          throw new Error(\n            `Cannot execute GraphQL operations ${\n              this.internals.state.phase === 'stopping'\n                ? 'while the server is stopping'\n                : 'after the server has stopped'\n            }.'`,\n          );\n        default:\n          throw new UnreachableCaseError(this.internals.state);\n      }\n    }\n  }\n\n  // Framework integrations should call this to ensure that you've properly\n  // started your server before you get anywhere close to actually listening for\n  // incoming requests.\n  //\n  // There's a special case that if you called\n  // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests` and\n  // it hasn't finished starting up yet, this works too. This is intended for\n  // cases like a serverless integration (say, Google Cloud Functions) that\n  // calls\n  // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests` for\n  // you and then immediately sets up an integration based on another middleware\n  // like `expressMiddleware` which calls this function. We'd like this to be\n  // OK, but we still want normal Express users to start their ApolloServer\n  // before setting up their HTTP server unless they know what they are doing\n  // well enough to call the function with the long name themselves.\n  public assertStarted(expressionForError: string) {\n    if (\n      this.internals.state.phase !== 'started' &&\n      this.internals.state.phase !== 'draining' &&\n      !(\n        this.internals.state.phase === 'starting' &&\n        this.internals.state.startedInBackground\n      )\n    ) {\n      throw new Error(\n        'You must `await server.start()` before calling `' +\n          expressionForError +\n          '`',\n      );\n    }\n  }\n\n  // Given an error that occurred during Apollo Server startup, log it with a\n  // helpful message. This should happen when you call\n  // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests` (ie,\n  // in serverless frameworks); with other frameworks, you must `await\n  // server.start()` which will throw the startup error directly instead of\n  // logging. This gets called both immediately when the startup error happens,\n  // and on all subsequent requests.\n  private logStartupError(err: Error) {\n    this.logger.error(\n      'An error occurred during Apollo Server startup. All GraphQL requests ' +\n        'will now fail. The startup error was: ' +\n        (err?.message || err),\n    );\n  }\n\n  private static constructSchema<TContext extends BaseContext>(\n    config: ApolloServerOptionsWithStaticSchema<TContext>,\n  ): GraphQLSchema {\n    if (config.schema) {\n      return config.schema;\n    }\n\n    const { typeDefs, resolvers } = config;\n    const augmentedTypeDefs = Array.isArray(typeDefs) ? typeDefs : [typeDefs];\n\n    // For convenience, we allow you to pass a few options that we pass through\n    // to a particular version of `@graphql-tools/schema`'s\n    // `makeExecutableSchema`. If you want to use more of this function's\n    // features or have more control over the version of the packages used, just\n    // call it yourself like `new ApolloServer({schema:\n    // makeExecutableSchema(...)})`.\n    return makeExecutableSchema({\n      typeDefs: augmentedTypeDefs,\n      resolvers,\n    });\n  }\n\n  private static generateSchemaDerivedData(\n    schema: GraphQLSchema,\n    // null means don't use a documentStore at all.\n    // missing/undefined means use the default (creating a new one each\n    // time).\n    // defined means wrap this one in a random prefix for each new schema.\n    providedDocumentStore: DocumentStore | null | undefined,\n  ): SchemaDerivedData {\n    // Instead of waiting for the first operation execution against the schema\n    // to find out if it's a valid schema or not, check right now. In the\n    // non-gateway case, if this throws then the `new ApolloServer` call will\n    // throw. In the gateway case if this throws then it will log a message and\n    // just not update the schema (although oddly the message will claim that\n    // the schema is updating).\n    assertValidSchema(schema);\n\n    return {\n      schema,\n      // The DocumentStore is schema-derived because we put documents in it\n      // after checking that they pass GraphQL validation against the schema and\n      // use this to skip validation as well as parsing. So we can't reuse the\n      // same DocumentStore for different schemas because that might make us\n      // treat invalid operations as valid. If we're using the default\n      // DocumentStore, then we just create it from scratch each time we get a\n      // new schema. If we're using a user-provided DocumentStore, then we use\n      // the schema hash as a prefix.\n      documentStore:\n        providedDocumentStore === undefined\n          ? new InMemoryLRUCache<DocumentNode>()\n          : providedDocumentStore,\n      documentStoreKeyPrefix: providedDocumentStore\n        ? `${computeCoreSchemaHash(printSchema(schema))}:`\n        : '',\n    };\n  }\n\n  public async stop() {\n    switch (this.internals.state.phase) {\n      case 'initialized':\n      case 'starting':\n      case 'failed to start':\n        throw Error(\n          'apolloServer.stop() should only be called after `await apolloServer.start()` has succeeded',\n        );\n\n      // Calling stop more than once should have the same result as the first time.\n      case 'stopped':\n        if (this.internals.state.stopError) {\n          throw this.internals.state.stopError;\n        }\n        return;\n\n      // Two parallel calls to stop; just wait for the other one to finish and\n      // do whatever it did.\n      case 'stopping':\n      case 'draining': {\n        await this.internals.state.barrier;\n        // The cast here is because TS doesn't understand that this.state can\n        // change during the await\n        // (https://github.com/microsoft/TypeScript/issues/9998).\n        const state = this.internals.state as ServerState;\n        if (state.phase !== 'stopped') {\n          throw Error(`Surprising post-stopping state ${state.phase}`);\n        }\n        if (state.stopError) {\n          throw state.stopError;\n        }\n        return;\n      }\n\n      case 'started':\n        // This is handled by the rest of the function.\n        break;\n\n      default:\n        throw new UnreachableCaseError(this.internals.state);\n    }\n\n    const barrier = resolvable();\n\n    const {\n      schemaManager,\n      drainServers,\n      landingPage,\n      toDispose,\n      toDisposeLast,\n    } = this.internals.state;\n\n    // Commit to stopping and start draining servers.\n    this.internals.state = {\n      phase: 'draining',\n      barrier,\n      schemaManager,\n      landingPage,\n    };\n\n    try {\n      await drainServers?.();\n\n      // Servers are drained. Prevent further operations from starting and call\n      // stop handlers.\n      this.internals.state = { phase: 'stopping', barrier };\n\n      // We run shutdown handlers in two phases because we don't want to turn\n      // off our signal listeners (ie, allow signals to kill the process) until\n      // we've done the important parts of shutdown like running serverWillStop\n      // handlers. (We can make this more generic later if it's helpful.)\n      await Promise.all([...toDispose].map((dispose) => dispose()));\n      await Promise.all([...toDisposeLast].map((dispose) => dispose()));\n    } catch (stopError) {\n      this.internals.state = {\n        phase: 'stopped',\n        stopError: stopError as Error,\n      };\n      barrier.resolve();\n      throw stopError;\n    }\n    this.internals.state = { phase: 'stopped', stopError: null };\n  }\n\n  private async addDefaultPlugins() {\n    const {\n      plugins,\n      apolloConfig,\n      nodeEnv,\n      hideSchemaDetailsFromClientErrors,\n    } = this.internals;\n    const isDev = nodeEnv !== 'production';\n\n    const alreadyHavePluginWithInternalId = (id: InternalPluginId) =>\n      plugins.some(\n        (p) => pluginIsInternal(p) && p.__internal_plugin_id__ === id,\n      );\n\n    // Make sure we're not trying to explicitly enable and disable the same\n    // feature. (Be careful: we are not trying to stop people from installing\n    // the same plugin twice if they have a use case for it, like two usage\n    // reporting plugins for different variants.)\n    //\n    // Note that this check doesn't work for the landing page plugin, because\n    // users can write their own landing page plugins and we don't know if a\n    // given plugin is a landing page plugin until the server has started.\n    const pluginsByInternalID = new Map<\n      InternalPluginId,\n      { sawDisabled: boolean; sawNonDisabled: boolean }\n    >();\n    for (const p of plugins) {\n      if (pluginIsInternal(p)) {\n        const id = p.__internal_plugin_id__;\n        if (!pluginsByInternalID.has(id)) {\n          pluginsByInternalID.set(id, {\n            sawDisabled: false,\n            sawNonDisabled: false,\n          });\n        }\n        const seen = pluginsByInternalID.get(id)!;\n        if (p.__is_disabled_plugin__) {\n          seen.sawDisabled = true;\n        } else {\n          seen.sawNonDisabled = true;\n        }\n\n        if (seen.sawDisabled && seen.sawNonDisabled) {\n          throw new Error(\n            `You have tried to install both ApolloServerPlugin${id} and ` +\n              `ApolloServerPlugin${id}Disabled in your server. Please choose ` +\n              `whether or not you want to disable the feature and install the ` +\n              `appropriate plugin for your use case.`,\n          );\n        }\n      }\n    }\n\n    // Special case: cache control is on unless you explicitly disable it.\n    {\n      if (!alreadyHavePluginWithInternalId('CacheControl')) {\n        const { ApolloServerPluginCacheControl } = await import(\n          './plugin/cacheControl/index.js'\n        );\n        plugins.push(ApolloServerPluginCacheControl());\n      }\n    }\n\n    // Special case: usage reporting is on by default (and first!) if you\n    // configure an API key.\n    {\n      const alreadyHavePlugin =\n        alreadyHavePluginWithInternalId('UsageReporting');\n      if (!alreadyHavePlugin && apolloConfig.key) {\n        if (apolloConfig.graphRef) {\n          // Keep this plugin first so it wraps everything. (Unfortunately despite\n          // the fact that the person who wrote this line also was the original\n          // author of the comment above in #1105, they don't quite understand why this was important.)\n          const { ApolloServerPluginUsageReporting } = await import(\n            './plugin/usageReporting/index.js'\n          );\n          plugins.unshift(\n            ApolloServerPluginUsageReporting({\n              __onlyIfSchemaIsNotSubgraph: true,\n            }),\n          );\n        } else {\n          this.logger.warn(\n            'You have specified an Apollo key but have not specified a graph ref; usage ' +\n              'reporting is disabled. To enable usage reporting, set the `APOLLO_GRAPH_REF` ' +\n              'environment variable to `your-graph-id@your-graph-variant`. To disable this ' +\n              'warning, install `ApolloServerPluginUsageReportingDisabled`.',\n          );\n        }\n      }\n    }\n\n    // Special case: schema reporting can be turned on via environment variable.\n    {\n      const alreadyHavePlugin =\n        alreadyHavePluginWithInternalId('SchemaReporting');\n      const enabledViaEnvVar = process.env.APOLLO_SCHEMA_REPORTING === 'true';\n      if (!alreadyHavePlugin && enabledViaEnvVar) {\n        if (apolloConfig.key) {\n          const { ApolloServerPluginSchemaReporting } = await import(\n            './plugin/schemaReporting/index.js'\n          );\n          plugins.push(ApolloServerPluginSchemaReporting());\n        } else {\n          throw new Error(\n            \"You've enabled schema reporting by setting the APOLLO_SCHEMA_REPORTING \" +\n              'environment variable to true, but you also need to provide your ' +\n              'Apollo API key, via the APOLLO_KEY environment ' +\n              'variable or via `new ApolloServer({apollo: {key})',\n          );\n        }\n      }\n    }\n\n    // Special case: inline tracing is on by default for federated schemas.\n    {\n      const alreadyHavePlugin = alreadyHavePluginWithInternalId('InlineTrace');\n      if (!alreadyHavePlugin) {\n        // If we haven't explicitly disabled inline tracing via\n        // ApolloServerPluginInlineTraceDisabled or explicitly installed our own\n        // ApolloServerPluginInlineTrace, we set up inline tracing in \"only if\n        // federated\" mode.  (This is slightly different than the\n        // pre-ApolloServerPluginInlineTrace where we would also avoid doing\n        // this if an API key was configured and log a warning.)\n        const { ApolloServerPluginInlineTrace } = await import(\n          './plugin/inlineTrace/index.js'\n        );\n        plugins.push(\n          ApolloServerPluginInlineTrace({ __onlyIfSchemaIsSubgraph: true }),\n        );\n      }\n    }\n\n    // Special case: If we're not in production, show our default landing page.\n    //\n    // This works a bit differently from the other implicitly installed plugins,\n    // which rely entirely on the __internal_plugin_id__ to decide whether the\n    // plugin takes effect. That's because we want third-party plugins to be\n    // able to provide a landing page that overrides the default landing page,\n    // without them having to know about __internal_plugin_id__. So unless we\n    // actively disable the default landing page with\n    // ApolloServerPluginLandingPageDisabled, we install the default landing\n    // page, but with a special flag that _start() uses to ignore it if some\n    // other plugin defines a renderLandingPage callback. (We can't just look\n    // now to see if the plugin defines renderLandingPage because we haven't run\n    // serverWillStart yet.)\n    const alreadyHavePlugin = alreadyHavePluginWithInternalId(\n      'LandingPageDisabled',\n    );\n    if (!alreadyHavePlugin) {\n      const {\n        ApolloServerPluginLandingPageLocalDefault,\n        ApolloServerPluginLandingPageProductionDefault,\n      } = await import('./plugin/landingPage/default/index.js');\n      const plugin: ApolloServerPlugin<TContext> = isDev\n        ? ApolloServerPluginLandingPageLocalDefault()\n        : ApolloServerPluginLandingPageProductionDefault();\n      if (!isImplicitlyInstallablePlugin(plugin)) {\n        throw Error(\n          'default landing page plugin should be implicitly installable?',\n        );\n      }\n      plugin.__internal_installed_implicitly__ = true;\n      plugins.push(plugin);\n    }\n\n    {\n      const alreadyHavePlugin =\n        alreadyHavePluginWithInternalId('DisableSuggestions');\n      if (hideSchemaDetailsFromClientErrors && !alreadyHavePlugin) {\n        const { ApolloServerPluginDisableSuggestions } = await import(\n          './plugin/disableSuggestions/index.js'\n        );\n        plugins.push(ApolloServerPluginDisableSuggestions());\n      }\n    }\n  }\n\n  public addPlugin(plugin: ApolloServerPlugin<TContext>) {\n    if (this.internals.state.phase !== 'initialized') {\n      throw new Error(\"Can't add plugins after the server has started\");\n    }\n    this.internals.plugins.push(plugin);\n  }\n\n  public async executeHTTPGraphQLRequest({\n    httpGraphQLRequest,\n    context,\n  }: {\n    httpGraphQLRequest: HTTPGraphQLRequest;\n    context: ContextThunk<TContext>;\n  }): Promise<HTTPGraphQLResponse> {\n    try {\n      let runningServerState;\n      try {\n        runningServerState = await this._ensureStarted();\n      } catch (error: unknown) {\n        // This is typically either the masked error from when background startup\n        // failed, or related to invoking this function before startup or\n        // during/after shutdown (due to lack of draining).\n        return await this.errorResponse(error, httpGraphQLRequest);\n      }\n\n      if (\n        runningServerState.landingPage &&\n        this.prefersHTML(httpGraphQLRequest)\n      ) {\n        let renderedHtml;\n        if (typeof runningServerState.landingPage.html === 'string') {\n          renderedHtml = runningServerState.landingPage.html;\n        } else {\n          try {\n            renderedHtml = await runningServerState.landingPage.html();\n          } catch (maybeError: unknown) {\n            const error = ensureError(maybeError);\n            this.logger.error(`Landing page \\`html\\` function threw: ${error}`);\n            return await this.errorResponse(error, httpGraphQLRequest);\n          }\n        }\n\n        return {\n          headers: new HeaderMap([['content-type', 'text/html']]),\n          body: {\n            kind: 'complete',\n            string: renderedHtml,\n          },\n        };\n      }\n\n      // If enabled, check to ensure that this request was preflighted before doing\n      // anything real (such as running the context function).\n      if (this.internals.csrfPreventionRequestHeaders) {\n        preventCsrf(\n          httpGraphQLRequest.headers,\n          this.internals.csrfPreventionRequestHeaders,\n        );\n      }\n\n      let contextValue: TContext;\n      try {\n        contextValue = await context();\n      } catch (maybeError: unknown) {\n        const error = ensureError(maybeError);\n        try {\n          await Promise.all(\n            this.internals.plugins.map(async (plugin) =>\n              plugin.contextCreationDidFail?.({\n                error,\n              }),\n            ),\n          );\n        } catch (pluginError) {\n          this.logger.error(\n            `contextCreationDidFail hook threw: ${pluginError}`,\n          );\n        }\n\n        // If some random function threw, add a helpful prefix when converting\n        // to GraphQLError. If it was already a GraphQLError, trust that the\n        // message was chosen thoughtfully and leave off the prefix.\n        return await this.errorResponse(\n          ensureGraphQLError(error, 'Context creation failed: '),\n          httpGraphQLRequest,\n        );\n      }\n\n      return await runPotentiallyBatchedHttpQuery(\n        this,\n        httpGraphQLRequest,\n        contextValue,\n        runningServerState.schemaManager.getSchemaDerivedData(),\n        this.internals,\n      );\n    } catch (maybeError_: unknown) {\n      const maybeError = maybeError_; // fixes inference because catch vars are not const\n      if (\n        maybeError instanceof GraphQLError &&\n        maybeError.extensions.code === ApolloServerErrorCode.BAD_REQUEST\n      ) {\n        try {\n          await Promise.all(\n            this.internals.plugins.map(async (plugin) =>\n              plugin.invalidRequestWasReceived?.({ error: maybeError }),\n            ),\n          );\n        } catch (pluginError) {\n          this.logger.error(\n            `invalidRequestWasReceived hook threw: ${pluginError}`,\n          );\n        }\n      }\n      return await this.errorResponse(maybeError, httpGraphQLRequest);\n    }\n  }\n\n  private async errorResponse(\n    error: unknown,\n    requestHead: HTTPGraphQLHead,\n  ): Promise<HTTPGraphQLResponse> {\n    const { formattedErrors, httpFromErrors } = normalizeAndFormatErrors(\n      [error],\n      {\n        includeStacktraceInErrorResponses:\n          this.internals.includeStacktraceInErrorResponses,\n        formatError: this.internals.formatError,\n      },\n    );\n\n    return {\n      status: httpFromErrors.status ?? 500,\n      headers: new HeaderMap([\n        ...httpFromErrors.headers,\n        [\n          'content-type',\n          // Note that we may change the default to\n          // 'application/graphql-response+json' by 2025 as encouraged by the\n          // graphql-over-http spec. It's maybe a bit bad for us to provide\n          // an application/json response if they send `accept: foo/bar`,\n          // but we're already providing some sort of bad request error, and\n          // it's probably more useful for them to fix the other error before\n          // they deal with the `accept` header.\n          chooseContentTypeForSingleResultResponse(requestHead) ??\n            MEDIA_TYPES.APPLICATION_JSON,\n        ],\n      ]),\n      body: {\n        kind: 'complete',\n        string: await this.internals.stringifyResult({\n          errors: formattedErrors,\n        }),\n      },\n    };\n  }\n\n  private prefersHTML(request: HTTPGraphQLRequest): boolean {\n    const acceptHeader = request.headers.get('accept');\n    return (\n      request.method === 'GET' &&\n      !!acceptHeader &&\n      new Negotiator({\n        headers: { accept: acceptHeader },\n      }).mediaType([\n        // We need it to actively prefer text/html over less browser-y types;\n        // eg, `accept: */*' should still go for JSON. Negotiator does tiebreak\n        // by the order in the list we provide, so we put text/html last.\n        MEDIA_TYPES.APPLICATION_JSON,\n        MEDIA_TYPES.APPLICATION_GRAPHQL_RESPONSE_JSON,\n        MEDIA_TYPES.MULTIPART_MIXED_EXPERIMENTAL,\n        MEDIA_TYPES.MULTIPART_MIXED_NO_DEFER_SPEC,\n        MEDIA_TYPES.TEXT_HTML,\n      ]) === MEDIA_TYPES.TEXT_HTML\n    );\n  }\n\n  /**\n   * This method is primarily meant for testing: it allows you to execute a\n   * GraphQL operation via the request pipeline without going through the HTTP\n   * layer. Note that this means that any handling you do in your server at the\n   * HTTP level will not affect this call!\n   *\n   * For convenience, you can provide `request.query` either as a string or a\n   * DocumentNode, in case you choose to use the gql tag in your tests. This is\n   * just a convenience, not an optimization (we convert provided ASTs back into\n   * string).\n   *\n   * The second object is an optional options object which includes the optional\n   * `contextValue` object available in resolvers.\n   *\n   * You may specify the TData and TVariables generic types when calling this\n   * method; Apollo Server does not validate that the returned data actually\n   * matches the structure of TData. (Typically these types are created by a\n   * code generation tool.) Note that this does not enforce that `variables` is\n   * provided at all, just that it has the right type if provided.\n   */\n  public async executeOperation<\n    TData = Record<string, unknown>,\n    TVariables extends VariableValues = VariableValues,\n  >(\n    this: ApolloServer<BaseContext>,\n    request: Omit<GraphQLRequest<TVariables>, 'query'> & {\n      query?: string | DocumentNode | TypedQueryDocumentNode<TData, TVariables>;\n    },\n  ): Promise<GraphQLResponse<TData>>;\n  public async executeOperation<\n    TData = Record<string, unknown>,\n    TVariables extends VariableValues = VariableValues,\n  >(\n    request: Omit<GraphQLRequest<TVariables>, 'query'> & {\n      query?: string | DocumentNode | TypedQueryDocumentNode<TData, TVariables>;\n    },\n    options?: ExecuteOperationOptions<TContext>,\n  ): Promise<GraphQLResponse<TData>>;\n\n  async executeOperation<\n    TData = Record<string, unknown>,\n    TVariables extends VariableValues = VariableValues,\n  >(\n    request: Omit<GraphQLRequest<TVariables>, 'query'> & {\n      // We should consider supporting TypedDocumentNode from\n      // `@graphql-typed-document-node/core` as well, as it is more popular than\n      // the newer built-in type.\n      query?: string | DocumentNode | TypedQueryDocumentNode<TData, TVariables>;\n    },\n    options: ExecuteOperationOptions<TContext> = {},\n  ): Promise<GraphQLResponse<TData>> {\n    // Since this function is mostly for testing, you don't need to explicitly\n    // start your server before calling it. (That also means you can use it with\n    // `apollo-server` which doesn't support `start()`.)\n    if (this.internals.state.phase === 'initialized') {\n      await this.start();\n    }\n\n    const schemaDerivedData = (\n      await this._ensureStarted()\n    ).schemaManager.getSchemaDerivedData();\n\n    // For convenience, this function lets you pass either a string or an AST,\n    // but we normalize to string.\n    const graphQLRequest: GraphQLRequest = {\n      ...request,\n      query:\n        request.query && typeof request.query !== 'string'\n          ? print(request.query)\n          : request.query,\n    };\n\n    const response: GraphQLResponse = await internalExecuteOperation(\n      {\n        server: this,\n        graphQLRequest,\n        internals: this.internals,\n        schemaDerivedData,\n        sharedResponseHTTPGraphQLHead: null,\n      },\n      options,\n    );\n\n    // It's your job to set an appropriate TData (perhaps using codegen); we\n    // don't validate it.\n    return response as GraphQLResponse<TData>;\n  }\n}\n\n// Shared code between runHttpQuery (ie executeHTTPGraphQLRequest) and\n// executeOperation to set up a request context and invoke the request pipeline.\nexport async function internalExecuteOperation<TContext extends BaseContext>(\n  {\n    server,\n    graphQLRequest,\n    internals,\n    schemaDerivedData,\n    sharedResponseHTTPGraphQLHead,\n  }: {\n    server: ApolloServer<TContext>;\n    graphQLRequest: GraphQLRequest;\n    internals: ApolloServerInternals<TContext>;\n    schemaDerivedData: SchemaDerivedData;\n    sharedResponseHTTPGraphQLHead: HTTPGraphQLHead | null;\n  },\n  options: ExecuteOperationOptions<TContext>,\n): Promise<GraphQLResponse> {\n  const requestContext: GraphQLRequestContext<TContext> = {\n    logger: server.logger,\n    cache: server.cache,\n    schema: schemaDerivedData.schema,\n    request: graphQLRequest,\n    response: {\n      http: sharedResponseHTTPGraphQLHead ?? newHTTPGraphQLHead(),\n    },\n    // We clone the context because there are some assumptions that every operation\n    // execution has a brand new context object; specifically, in order to implement\n    // willResolveField we put a Symbol on the context that is specific to a particular\n    // request pipeline execution. We could avoid this if we had a better way of\n    // instrumenting execution.\n    //\n    // We don't want to do a deep clone here, because one of the main advantages of\n    // using batched HTTP requests is to share context across operations for a\n    // single request.\n    //\n    // The typecast here is safe, because the only way `contextValue` can be\n    // null-ish is if we used the `contextValue?: BaseContext` override, in\n    // which case TContext is BaseContext and {} is ok. (This does depend on\n    // the fact we've hackily forced the class to be contravariant in\n    // TContext.)\n    contextValue: cloneObject(options?.contextValue ?? ({} as TContext)),\n    metrics: {},\n    overallCachePolicy: newCachePolicy(),\n    requestIsBatched: sharedResponseHTTPGraphQLHead !== null,\n  };\n\n  try {\n    return await processGraphQLRequest(\n      schemaDerivedData,\n      server,\n      internals,\n      requestContext,\n    );\n  } catch (maybeError: unknown) {\n    // processGraphQLRequest throwing usually means that either there's a bug in\n    // Apollo Server or some plugin hook threw unexpectedly.\n    const error = ensureError(maybeError);\n    // If *these* hooks throw then we'll still get a 500 but won't mask its\n    // error.\n    await Promise.all(\n      internals.plugins.map(async (plugin) =>\n        plugin.unexpectedErrorProcessingRequest?.({\n          requestContext,\n          error,\n        }),\n      ),\n    );\n    // Mask unexpected error externally.\n    server.logger.error(`Unexpected error processing request: ${error}`);\n    throw new Error('Internal server error');\n  }\n}\n\n// Unlike InternalPlugins (where we can decide whether to install the default\n// plugin based on looking at which plugins are installed),\n// ImplicitlyInstallablePlugins (ie the default landing page plugin) can't\n// determine if they're needed until later in startup. Specifically, we can't\n// know if we've defined our own landing page until after serverWillStart\n// plugins have run.\nexport type ImplicitlyInstallablePlugin<TContext extends BaseContext> =\n  ApolloServerPlugin<TContext> & {\n    __internal_installed_implicitly__: boolean;\n  };\n\nexport function isImplicitlyInstallablePlugin<TContext extends BaseContext>(\n  p: ApolloServerPlugin<TContext>,\n): p is ImplicitlyInstallablePlugin<TContext> {\n  return '__internal_installed_implicitly__' in p;\n}\n\nexport const MEDIA_TYPES = {\n  APPLICATION_JSON: 'application/json; charset=utf-8',\n  APPLICATION_JSON_GRAPHQL_CALLBACK:\n    'application/json; callbackSpec=1.0; charset=utf-8',\n  APPLICATION_GRAPHQL_RESPONSE_JSON:\n    'application/graphql-response+json; charset=utf-8',\n  // We do *not* currently support this content-type; we will once incremental\n  // delivery is part of the official GraphQL spec.\n  MULTIPART_MIXED_NO_DEFER_SPEC: 'multipart/mixed',\n  MULTIPART_MIXED_EXPERIMENTAL: 'multipart/mixed; deferSpec=20220824',\n  TEXT_HTML: 'text/html',\n};\n\nexport function chooseContentTypeForSingleResultResponse(\n  head: HTTPGraphQLHead,\n): string | null {\n  const acceptHeader = head.headers.get('accept');\n  if (!acceptHeader) {\n    // Note that we may change the default to\n    // 'application/graphql-response+json' by 2025 as encouraged by the\n    // graphql-over-http spec.\n    return MEDIA_TYPES.APPLICATION_JSON;\n  } else {\n    const preferred = new Negotiator({\n      headers: { accept: head.headers.get('accept') },\n    }).mediaType([\n      MEDIA_TYPES.APPLICATION_JSON,\n      MEDIA_TYPES.APPLICATION_GRAPHQL_RESPONSE_JSON,\n      MEDIA_TYPES.APPLICATION_JSON_GRAPHQL_CALLBACK,\n    ]);\n    if (preferred) {\n      return preferred;\n    } else {\n      return null;\n    }\n  }\n}\n\nfunction cloneObject<T extends Object>(object: T): T {\n  return Object.assign(Object.create(Object.getPrototypeOf(object)), object);\n}\n"],"names":[],"mappings":";;;;;;;AACA,OAAO,EAAE,UAAU,EAAE,MAAM,0BAA0B,CAAC;AACtD,OAAO,EACL,gBAAgB,EAChB,sBAAsB,GAEvB,MAAM,6BAA6B,CAAC;AAIrC,OAAO,UAA+B,MAAM,uBAAuB,CAAC;AAgBpE,OAAO,QAAQ,MAAM,UAAU,CAAC;AAChC,OAAO,UAAU,MAAM,YAAY,CAAC;AACpC,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EAAE,qBAAqB,EAAE,MAAM,4BAA4B,CAAC;AACnE,OAAO,EACL,WAAW,EACX,kBAAkB,EAClB,wBAAwB,GACzB,MAAM,qBAAqB,CAAC;AAC7B,OAAO,EACL,qBAAqB,EACrB,+BAA+B,GAChC,MAAM,mBAAmB,CAAC;AAwB3B,OAAO,EAAE,8BAA8B,EAAE,MAAM,mBAAmB,CAAC;AAEnE,OAAO,EAAE,gBAAgB,EAAyB,MAAM,qBAAqB,CAAC;AAC9E,OAAO,EACL,WAAW,EACX,uCAAuC,GACxC,MAAM,kBAAkB,CAAC;AAC1B,OAAO,EAAE,gBAAgB,EAAE,qBAAqB,EAAE,MAAM,sBAAsB,CAAC;AAC/E,OAAO,EAAE,kBAAkB,EAAE,mBAAmB,EAAE,MAAM,mBAAmB,CAAC;AAC5E,OAAO,EAAE,SAAS,EAAE,MAAM,sBAAsB,CAAC;AACjD,OAAO,EAAE,oBAAoB,EAAE,MAAM,iCAAiC,CAAC;AACvE,OAAO,EAAE,qBAAqB,EAAE,MAAM,kCAAkC,CAAC;AACzE,OAAO,EAAE,SAAS,EAAE,MAAM,sBAAsB,CAAC;AACjD,OAAO,EAAE,aAAa,EAAE,MAAM,0BAA0B,CAAC;;AAlEzD,OAAO,EAAE,oBAAoB,EAAE,MAAM,uBAAuB,CAAC;;;AAE7D,OAAO,EACL,YAAY,EACZ,iBAAiB,EACjB,KAAK,EACL,WAAW,GAUZ,MAAM,SAAS,CAAC;;;;;;;;;;;;;;;;;;;;;;AAoDjB,MAAM,eAAe,GAAmB,CAAC,OAA0B,EAAE,CAAG,CAAD,AAAE;QACvE,KAAK,EAAC,IAAI;YACR,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,KAAK,UAAU,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,KAAK,QAAQ,EAAE,CAAC;gBACnE,OAAO,CAAC,WAAW,CACjB,wJAAI,eAAY,CACd,oLAAoL,EACpL;oBACE,KAAK,EAAE;wBAAC,IAAI;qBAAC;oBACb,UAAU,EAAE;wBACV,mBAAmB,yKACjB,kCAA+B,CAAC,sBAAsB;qBACzD;iBACF,CACF,CACF,CAAC;YACJ,CAAC;QACH,CAAC;KACF,CAAC,CAAC;AA8FH,SAAS,aAAa;IACpB,MAAM,cAAc,iJAAG,UAAQ,CAAC,SAAS,CAAC,eAAe,CAAC,CAAC;IAC3D,cAAc,CAAC,QAAQ,+IAAC,UAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAC9C,OAAO,cAAc,CAAC;AACxB,CAAC;AAuBK,MAAO,YAAY;IAMvB,YAAY,MAAqC,CAAA;QAC/C,MAAM,OAAO,GAAG,MAAM,CAAC,OAAO,IAAI,OAAO,CAAC,GAAG,CAAC,QAAQ,+BAAI,EAAE,CAAC;QAE7D,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,IAAI,aAAa,EAAE,CAAC;QAE/C,MAAM,YAAY,oLAAG,wBAAqB,AAArB,EAAsB,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;QAEvE,MAAM,KAAK,GAAG,OAAO,KAAK,YAAY,CAAC;QAEvC,IACE,MAAM,CAAC,KAAK,IACZ,MAAM,CAAC,KAAK,KAAK,SAAS,0KAC1B,yBAAsB,CAAC,kCAAkC,CAAC,MAAM,CAAC,KAAK,CAAC,EACvE,CAAC;YACD,MAAM,IAAI,KAAK,CACb,wCAAwC,GACtC,0EAA0E,GAC1E,yEAAyE,GACzE,sEAAsE,CACzE,CAAC;QACJ,CAAC;QAED,MAAM,KAAK,GAAgB,MAAM,CAAC,OAAO,GASrC;YACE,KAAK,EAAE,aAAa;YACpB,aAAa,EAAE,kLAAI,gBAAa,CAAC;gBAC/B,OAAO,EAAE,MAAM,CAAC,OAAO;gBACvB,YAAY;gBACZ,yBAAyB,EAAE,CAAC,MAAM,EAAE,CAClC,CADoC,WACxB,CAAC,yBAAyB,CACpC,MAAM,EACN,MAAM,CAAC,aAAa,CACrB;gBACH,MAAM,EAAE,IAAI,CAAC,MAAM;aACpB,CAAC;SACH,GAMD;YACE,KAAK,EAAE,aAAa;YACpB,aAAa,EAAE,kLAAI,gBAAa,CAAC;gBAC/B,SAAS,EAAE,YAAY,CAAC,eAAe,CAAC,MAAM,CAAC;gBAC/C,yBAAyB,EAAE,CAAC,MAAM,EAAE,CAClC,CADoC,WACxB,CAAC,yBAAyB,CACpC,MAAM,EACN,MAAM,CAAC,aAAa,CACrB;gBACH,MAAM,EAAE,IAAI,CAAC,MAAM;aACpB,CAAC;SACH,CAAC;QAEN,MAAM,oBAAoB,GAAG,MAAM,CAAC,aAAa,IAAI,KAAK,CAAC;QAC3D,MAAM,iCAAiC,GACrC,MAAM,CAAC,iCAAiC,IAAI,KAAK,CAAC;QAIpD,IAAI,CAAC,KAAK,GACR,MAAM,CAAC,KAAK,KAAK,SAAS,IAAI,MAAM,CAAC,KAAK,KAAK,SAAS,GACpD,0KAAI,mBAAgB,EAAE,GACtB,MAAM,CAAC,KAAK,CAAC;QAInB,IAAI,CAAC,SAAS,GAAG;YACf,WAAW,EAAE,MAAM,CAAC,WAAW;YAC/B,SAAS,EAAE,MAAM,CAAC,SAAS;YAC3B,eAAe,EAAE;mBACX,MAAM,CAAC,eAAe,IAAI,EAAE,CAAC;mBAC7B,oBAAoB,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;oBAAC,eAAe;iBAAC,CAAC;aACnD;YACD,iCAAiC;YACjC,4BAA4B,EAC1B,MAAM,CAAC,4BAA4B,IAAI,KAAK;YAC9C,aAAa,EAAE,MAAM,CAAC,aAAa;YACnC,iCAAiC,EAC/B,MAAM,CAAC,iCAAiC,IACxC,CAAC,OAAO,KAAK,YAAY,IAAI,OAAO,KAAK,MAAM,CAAC;YAClD,gBAAgB,EACd,MAAM,CAAC,gBAAgB,KAAK,KAAK,GAC7B,SAAS,GACT;gBACE,GAAG,MAAM,CAAC,gBAAgB;gBAC1B,KAAK,EAAE,0KAAI,yBAAsB,CAC/B,MAAM,CAAC,gBAAgB,EAAE,KAAK,IAAI,IAAI,CAAC,KAAK,EAC5C,0LAAgB,CACjB;aACF;YACP,OAAO;YACP,wBAAwB,EAAE,MAAM,CAAC,wBAAwB,IAAI,KAAK;YAClE,YAAY;YAIZ,OAAO,EAAE,MAAM,CAAC,OAAO,IAAI,EAAE;YAC7B,YAAY,EAAE,MAAM,CAAC,YAAY,IAAI,CAAA,CAAE;YACvC,KAAK;YACL,wBAAwB,EAAE,MAAM,CAAC,wBAAwB;YAEzD,eAAe,EAAE,IAAI;YAErB,4BAA4B,EAC1B,MAAM,CAAC,cAAc,KAAK,IAAI,IAAI,MAAM,CAAC,cAAc,KAAK,SAAS,sKACjE,0CAAuC,GACvC,MAAM,CAAC,cAAc,KAAK,KAAK,GAC7B,IAAI,GACH,MAAM,CAAC,cAAc,CAAC,cAAc,IACrC,6MAAuC,CAAC;YAChD,kCAAkC,EAChC,MAAM,CAAC,kCAAkC,IAAI,KAAK;YACpD,qCAAqC,EACnC,MAAM,CAAC,qCAAqC;YAC9C,eAAe,EAAE,MAAM,CAAC,eAAe,wKAAI,sBAAmB;SAC/D,CAAC;IACJ,CAAC;IA2BM,KAAK,CAAC,KAAK,GAAA;QAChB,OAAO,MAAM,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IAClC,CAAC;IAEM,oEAAoE,GAAA;QACzE,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,GAAK,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC;IAC1D,CAAC;IAEO,KAAK,CAAC,MAAM,CAAC,mBAA4B,EAAA;QAC/C,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,KAAK,aAAa,EAAE,CAAC;YAIjD,MAAM,IAAI,KAAK,CACb,CAAA,kCAAA,CAAoC,GAClC,CAAA,yEAAA,CAA2E,GAC3E,CAAA,0BAAA,CAA4B,CAC/B,CAAC;QACJ,CAAC;QACD,MAAM,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,aAAa,CAAC;QACzD,MAAM,OAAO,GAAG,yLAAA,AAAU,EAAE,CAAC;QAC7B,IAAI,CAAC,SAAS,CAAC,KAAK,GAAG;YACrB,KAAK,EAAE,UAAU;YACjB,OAAO;YACP,aAAa;YACb,mBAAmB;SACpB,CAAC;QACF,IAAI,CAAC;YAGH,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAE/B,MAAM,SAAS,GAA4B,EAAE,CAAC;YAC9C,MAAM,QAAQ,GAAG,MAAM,aAAa,CAAC,KAAK,EAAE,CAAC;YAC7C,IAAI,QAAQ,EAAE,CAAC;gBACb,IAAI,CAAC,SAAS,CAAC,eAAe,GAAG,QAAQ,CAAC;YAC5C,CAAC;YACD,SAAS,CAAC,IAAI,CAAC,KAAK,IAAI,EAAE;gBACxB,MAAM,aAAa,CAAC,IAAI,EAAE,CAAC;YAC7B,CAAC,CAAC,CAAC;YAEH,MAAM,iBAAiB,GAAG,aAAa,CAAC,oBAAoB,EAAE,CAAC;YAC/D,MAAM,OAAO,GAAyB;gBACpC,MAAM,EAAE,IAAI,CAAC,MAAM;gBACnB,KAAK,EAAE,IAAI,CAAC,KAAK;gBACjB,MAAM,EAAE,iBAAiB,CAAC,MAAM;gBAChC,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,YAAY;gBACnC,mBAAmB;aACpB,CAAC;YAEF,MAAM,qBAAqB,GAAG,CAC5B,MAAM,OAAO,CAAC,GAAG,CACf,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,CAAG,CAAD,AAAE;oBAC5C,cAAc,EACZ,MAAM,CAAC,eAAe,IAAI,AAAC,MAAM,MAAM,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC;oBACnE,mBAAmB,EACjB,6BAA6B,CAAC,MAAM,CAAC,IACrC,MAAM,CAAC,iCAAiC;iBAC3C,CAAC,CAAC,CACJ,CACF,CAAC,MAAM,CACN,CACE,yBAAyB,EAIzB,CAAG,CAAD,MAAQ,yBAAyB,CAAC,cAAc,KAAK,QAAQ,CAClE,CAAC;YAEF,qBAAqB,CAAC,OAAO,CAC3B,CAAC,EAAE,cAAc,EAAE,EAAE,qBAAqB,EAAE,EAAE,EAAE,EAAE;gBAChD,IAAI,qBAAqB,EAAE,CAAC;oBAC1B,aAAa,CAAC,oBAAoB,CAAC,qBAAqB,CAAC,CAAC;gBAC5D,CAAC;YACH,CAAC,CACF,CAAC;YAEF,MAAM,eAAe,GAAG,qBAAqB,CAC1C,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,cAAc,CAAC,cAAc,CAAC,CAC3C,MAAM,CAAC,sLAAS,CAAC,CAAC;YACrB,IAAI,eAAe,CAAC,MAAM,EAAE,CAAC;gBAC3B,SAAS,CAAC,IAAI,CAAC,KAAK,IAAI,EAAE;oBACxB,MAAM,OAAO,CAAC,GAAG,CACf,eAAe,CAAC,GAAG,CAAC,CAAC,cAAc,EAAE,CAAG,CAAD,aAAe,EAAE,CAAC,CAC1D,CAAC;gBACJ,CAAC,CAAC,CAAC;YACL,CAAC;YAED,MAAM,oBAAoB,GAAG,qBAAqB,CAC/C,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAC,AAAF,CAAG,cAAc,CAAC,WAAW,CAAC,CACxC,MAAM,CAAC,sLAAS,CAAC,CAAC;YACrB,MAAM,YAAY,GAAG,oBAAoB,CAAC,MAAM,GAC5C,KAAK,IAAI,EAAE;gBACT,MAAM,OAAO,CAAC,GAAG,CACf,oBAAoB,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,CAAG,CAAD,UAAY,EAAE,CAAC,CACzD,CAAC;YACJ,CAAC,GACD,IAAI,CAAC;YAQT,IAAI,0CAA0C,GAC5C,qBAAqB,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAG,CAAC,AAAF,CAAG,cAAc,CAAC,iBAAiB,CAAC,CAAC;YAC1E,IAAI,0CAA0C,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC1D,0CAA0C,GACxC,0CAA0C,CAAC,MAAM,CAC/C,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,CAAC,mBAAmB,CAC9B,CAAC;YACN,CAAC;YACD,IAAI,WAAW,GAAuB,IAAI,CAAC;YAC3C,IAAI,0CAA0C,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC1D,MAAM,KAAK,CAAC,kDAAkD,CAAC,CAAC;YAClE,CAAC,MAAM,IAAI,0CAA0C,CAAC,MAAM,EAAE,CAAC;gBAC7D,WAAW,GACT,MAAM,0CAA0C,CAAC,CAAC,CAAC,CAAC,cAAc,CAC/D,iBAAkB,EAAE,CAAC;YAC5B,CAAC;YAED,MAAM,aAAa,GAAG,IAAI,CAAC,sCAAsC,CAC/D;gBAAC,QAAQ;gBAAE,SAAS;aAAC,EACrB,mBAAmB,CACpB,CAAC;YAEF,IAAI,CAAC,SAAS,CAAC,KAAK,GAAG;gBACrB,KAAK,EAAE,SAAS;gBAChB,aAAa;gBACb,YAAY;gBACZ,WAAW;gBACX,SAAS;gBACT,aAAa;aACd,CAAC;QACJ,CAAC,CAAC,OAAO,UAAmB,EAAE,CAAC;YAC7B,MAAM,KAAK,4KAAG,eAAA,AAAW,EAAC,UAAU,CAAC,CAAC;YAEtC,IAAI,CAAC;gBACH,MAAM,OAAO,CAAC,GAAG,CACf,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,CACxC,CAD0C,KACpC,CAAC,cAAc,EAAE,CAAC;wBAAE,KAAK;oBAAA,CAAE,CAAC,CACnC,CACF,CAAC;YACJ,CAAC,CAAC,OAAO,WAAW,EAAE,CAAC;gBACrB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAA,2BAAA,EAA8B,WAAW,EAAE,CAAC,CAAC;YACjE,CAAC;YAED,IAAI,CAAC,SAAS,CAAC,KAAK,GAAG;gBACrB,KAAK,EAAE,iBAAiB;gBACxB,KAAK;aACN,CAAC;YACF,MAAM,KAAK,CAAC;QACd,CAAC,QAAS,CAAC;YACT,OAAO,CAAC,OAAO,EAAE,CAAC;QACpB,CAAC;IACH,CAAC;IAEO,sCAAsC,CAC5C,OAAyB,EACzB,mBAA4B,EAAA;QAE5B,MAAM,aAAa,GAA4B,EAAE,CAAC;QAUlD,IACE,IAAI,CAAC,SAAS,CAAC,wBAAwB,KAAK,KAAK,IAChD,IAAI,CAAC,SAAS,CAAC,wBAAwB,KAAK,SAAS,IACpD,CAAC,mKACC,cAAU,IACV,IAAI,CAAC,SAAS,CAAC,OAAO,KAAK,MAAM,IACjC,CAAC,mBAAmB,CACrB,CAAC,CACJ,CAAC;YACD,OAAO,aAAa,CAAC;QACvB,CAAC;QAED,IAAI,cAAc,GAAG,KAAK,CAAC;QAC3B,MAAM,aAAa,GAA2B,KAAK,EAAE,MAAM,EAAE,EAAE;YAC7D,IAAI,cAAc,EAAE,CAAC;gBAGnB,OAAO;YACT,CAAC;YACD,cAAc,GAAG,IAAI,CAAC;YACtB,IAAI,CAAC;gBACH,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;YACpB,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC;gBACX,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAA,oBAAA,EAAuB,MAAM,CAAA,SAAA,CAAW,CAAC,CAAC;gBAC5D,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;gBAErB,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAClB,CAAC;YAMD,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;QACpC,CAAC,CAAC;QAEF,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;YACzB,OAAO,CAAC,EAAE,CAAC,MAAM,EAAE,aAAa,CAAC,CAAC;YAClC,aAAa,CAAC,IAAI,CAAC,KAAK,IAAI,EAAE;gBAC5B,OAAO,CAAC,cAAc,CAAC,MAAM,EAAE,aAAa,CAAC,CAAC;YAChD,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QACH,OAAO,aAAa,CAAC;IACvB,CAAC;IAaO,KAAK,CAAC,cAAc,GAAA;QAC1B,MAAO,IAAI,CAAE,CAAC;YACZ,OAAQ,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;gBACnC,KAAK,aAAa;oBAMhB,MAAM,IAAI,KAAK,CACb,oEAAoE,CACrE,CAAC;gBACJ,KAAK,UAAU;oBACb,MAAM,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,OAAO,CAAC;oBAEnC,MAAM;gBACR,KAAK,iBAAiB;oBAGpB,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;oBAIjD,MAAM,IAAI,KAAK,CACb,qGAAqG,CACtG,CAAC;gBACJ,KAAK,SAAS,CAAC;gBACf,KAAK,UAAU;oBACb,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC;gBAC9B,KAAK,UAAU,CAAC;gBAChB,KAAK,SAAS;oBACZ,IAAI,CAAC,MAAM,CAAC,IAAI,CACd,+DAA+D,GAC7D,sEAAsE,GACtE,gDAAgD,CACnD,CAAC;oBACF,MAAM,IAAI,KAAK,CACb,CAAA,kCAAA,EACE,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,KAAK,UAAU,GACrC,8BAA8B,GAC9B,8BACN,CAAA,EAAA,CAAI,CACL,CAAC;gBACJ;oBACE,MAAM,yLAAI,uBAAoB,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;YACzD,CAAC;QACH,CAAC;IACH,CAAC;IAiBM,aAAa,CAAC,kBAA0B,EAAA;QAC7C,IACE,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,KAAK,SAAS,IACxC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,KAAK,UAAU,IACzC,CAAC,CACC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,KAAK,UAAU,IACzC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,mBAAmB,CACzC,EACD,CAAC;YACD,MAAM,IAAI,KAAK,CACb,kDAAkD,GAChD,kBAAkB,GAClB,GAAG,CACN,CAAC;QACJ,CAAC;IACH,CAAC;IASO,eAAe,CAAC,GAAU,EAAA;QAChC,IAAI,CAAC,MAAM,CAAC,KAAK,CACf,uEAAuE,GACrE,wCAAwC,GACxC,CAAC,GAAG,EAAE,OAAO,IAAI,GAAG,CAAC,CACxB,CAAC;IACJ,CAAC;IAEO,MAAM,CAAC,eAAe,CAC5B,MAAqD,EAAA;QAErD,IAAI,MAAM,CAAC,MAAM,EAAE,CAAC;YAClB,OAAO,MAAM,CAAC,MAAM,CAAC;QACvB,CAAC;QAED,MAAM,EAAE,QAAQ,EAAE,SAAS,EAAE,GAAG,MAAM,CAAC;QACvC,MAAM,iBAAiB,GAAG,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;YAAC,QAAQ;SAAC,CAAC;QAQ1E,yLAAO,uBAAA,AAAoB,EAAC;YAC1B,QAAQ,EAAE,iBAAiB;YAC3B,SAAS;SACV,CAAC,CAAC;IACL,CAAC;IAEO,MAAM,CAAC,yBAAyB,CACtC,MAAqB,EAKrB,qBAAuD,EAAA;QAQvD,uKAAA,AAAiB,EAAC,MAAM,CAAC,CAAC;QAE1B,OAAO;YACL,MAAM;YASN,aAAa,EACX,qBAAqB,KAAK,SAAS,GAC/B,0KAAI,mBAAgB,EAAgB,GACpC,qBAAqB;YAC3B,sBAAsB,EAAE,qBAAqB,GACzC,OAAG,8MAAA,AAAqB,6JAAC,cAAA,AAAW,EAAC,MAAM,CAAC,CAAC,CAAA,CAAA,CAAG,GAChD,EAAE;SACP,CAAC;IACJ,CAAC;IAEM,KAAK,CAAC,IAAI,GAAA;QACf,OAAQ,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;YACnC,KAAK,aAAa,CAAC;YACnB,KAAK,UAAU,CAAC;YAChB,KAAK,iBAAiB;gBACpB,MAAM,KAAK,CACT,4FAA4F,CAC7F,CAAC;YAGJ,KAAK,SAAS;gBACZ,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,SAAS,EAAE,CAAC;oBACnC,MAAM,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,SAAS,CAAC;gBACvC,CAAC;gBACD,OAAO;YAIT,KAAK,UAAU,CAAC;YAChB,KAAK,UAAU,CAAC;gBAAC,CAAC;oBAChB,MAAM,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,OAAO,CAAC;oBAInC,MAAM,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,KAAoB,CAAC;oBAClD,IAAI,KAAK,CAAC,KAAK,KAAK,SAAS,EAAE,CAAC;wBAC9B,MAAM,KAAK,CAAC,CAAA,+BAAA,EAAkC,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;oBAC/D,CAAC;oBACD,IAAI,KAAK,CAAC,SAAS,EAAE,CAAC;wBACpB,MAAM,KAAK,CAAC,SAAS,CAAC;oBACxB,CAAC;oBACD,OAAO;gBACT,CAAC;YAED,KAAK,SAAS;gBAEZ,MAAM;YAER;gBACE,MAAM,yLAAI,uBAAoB,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;QACzD,CAAC;QAED,MAAM,OAAO,GAAG,yLAAA,AAAU,EAAE,CAAC;QAE7B,MAAM,EACJ,aAAa,EACb,YAAY,EACZ,WAAW,EACX,SAAS,EACT,aAAa,EACd,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC;QAGzB,IAAI,CAAC,SAAS,CAAC,KAAK,GAAG;YACrB,KAAK,EAAE,UAAU;YACjB,OAAO;YACP,aAAa;YACb,WAAW;SACZ,CAAC;QAEF,IAAI,CAAC;YACH,MAAM,YAAY,EAAE,EAAE,CAAC;YAIvB,IAAI,CAAC,SAAS,CAAC,KAAK,GAAG;gBAAE,KAAK,EAAE,UAAU;gBAAE,OAAO;YAAA,CAAE,CAAC;YAMtD,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC;mBAAG,SAAS;aAAC,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,CAAG,CAAD,MAAQ,EAAE,CAAC,CAAC,CAAC;YAC9D,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC;mBAAG,aAAa;aAAC,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,CAAG,CAAD,MAAQ,EAAE,CAAC,CAAC,CAAC;QACpE,CAAC,CAAC,OAAO,SAAS,EAAE,CAAC;YACnB,IAAI,CAAC,SAAS,CAAC,KAAK,GAAG;gBACrB,KAAK,EAAE,SAAS;gBAChB,SAAS,EAAE,SAAkB;aAC9B,CAAC;YACF,OAAO,CAAC,OAAO,EAAE,CAAC;YAClB,MAAM,SAAS,CAAC;QAClB,CAAC;QACD,IAAI,CAAC,SAAS,CAAC,KAAK,GAAG;YAAE,KAAK,EAAE,SAAS;YAAE,SAAS,EAAE,IAAI;QAAA,CAAE,CAAC;IAC/D,CAAC;IAEO,KAAK,CAAC,iBAAiB,GAAA;QAC7B,MAAM,EACJ,OAAO,EACP,YAAY,EACZ,OAAO,EACP,iCAAiC,EAClC,GAAG,IAAI,CAAC,SAAS,CAAC;QACnB,MAAM,KAAK,GAAG,OAAO,KAAK,YAAY,CAAC;QAEvC,MAAM,+BAA+B,GAAG,CAAC,EAAoB,EAAE,CAC7D,CAD+D,MACxD,CAAC,IAAI,CACV,CAAC,CAAC,EAAE,EAAE,yKAAC,mBAAA,AAAgB,EAAC,CAAC,CAAC,IAAI,CAAC,CAAC,sBAAsB,KAAK,EAAE,CAC9D,CAAC;QAUJ,MAAM,mBAAmB,GAAG,IAAI,GAAG,EAGhC,CAAC;QACJ,KAAK,MAAM,CAAC,IAAI,OAAO,CAAE,CAAC;YACxB,6KAAI,oBAAA,AAAgB,EAAC,CAAC,CAAC,EAAE,CAAC;gBACxB,MAAM,EAAE,GAAG,CAAC,CAAC,sBAAsB,CAAC;gBACpC,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC;oBACjC,mBAAmB,CAAC,GAAG,CAAC,EAAE,EAAE;wBAC1B,WAAW,EAAE,KAAK;wBAClB,cAAc,EAAE,KAAK;qBACtB,CAAC,CAAC;gBACL,CAAC;gBACD,MAAM,IAAI,GAAG,mBAAmB,CAAC,GAAG,CAAC,EAAE,CAAE,CAAC;gBAC1C,IAAI,CAAC,CAAC,sBAAsB,EAAE,CAAC;oBAC7B,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;gBAC1B,CAAC,MAAM,CAAC;oBACN,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;gBAC7B,CAAC;gBAED,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;oBAC5C,MAAM,IAAI,KAAK,CACb,CAAA,iDAAA,EAAoD,EAAE,CAAA,KAAA,CAAO,GAC3D,CAAA,kBAAA,EAAqB,EAAE,CAAA,uCAAA,CAAyC,GAChE,CAAA,+DAAA,CAAiE,GACjE,CAAA,qCAAA,CAAuC,CAC1C,CAAC;gBACJ,CAAC;YACH,CAAC;QACH,CAAC;QAGD,CAAC;YACC,IAAI,CAAC,+BAA+B,CAAC,cAAc,CAAC,EAAE,CAAC;gBACrD,MAAM,EAAE,8BAA8B,EAAE,GAAG,MAAM,MAAM,CACrD,gCAAgC,CACjC,CAAC;gBACF,OAAO,CAAC,IAAI,CAAC,8BAA8B,EAAE,CAAC,CAAC;YACjD,CAAC;QACH,CAAC;QAID,CAAC;YACC,MAAM,iBAAiB,GACrB,+BAA+B,CAAC,gBAAgB,CAAC,CAAC;YACpD,IAAI,CAAC,iBAAiB,IAAI,YAAY,CAAC,GAAG,EAAE,CAAC;gBAC3C,IAAI,YAAY,CAAC,QAAQ,EAAE,CAAC;oBAI1B,MAAM,EAAE,gCAAgC,EAAE,GAAG,MAAM,MAAM,CACvD,kCAAkC,CACnC,CAAC;oBACF,OAAO,CAAC,OAAO,CACb,gCAAgC,CAAC;wBAC/B,2BAA2B,EAAE,IAAI;qBAClC,CAAC,CACH,CAAC;gBACJ,CAAC,MAAM,CAAC;oBACN,IAAI,CAAC,MAAM,CAAC,IAAI,CACd,6EAA6E,GAC3E,+EAA+E,GAC/E,8EAA8E,GAC9E,8DAA8D,CACjE,CAAC;gBACJ,CAAC;YACH,CAAC;QACH,CAAC;QAGD,CAAC;YACC,MAAM,iBAAiB,GACrB,+BAA+B,CAAC,iBAAiB,CAAC,CAAC;YACrD,MAAM,gBAAgB,GAAG,OAAO,CAAC,GAAG,CAAC,uBAAuB,KAAK,MAAM,CAAC;YACxE,IAAI,CAAC,iBAAiB,IAAI,gBAAgB,EAAE,CAAC;gBAC3C,IAAI,YAAY,CAAC,GAAG,EAAE,CAAC;oBACrB,MAAM,EAAE,iCAAiC,EAAE,GAAG,MAAM,MAAM,CACxD,mCAAmC,CACpC,CAAC;oBACF,OAAO,CAAC,IAAI,CAAC,iCAAiC,EAAE,CAAC,CAAC;gBACpD,CAAC,MAAM,CAAC;oBACN,MAAM,IAAI,KAAK,CACb,yEAAyE,GACvE,kEAAkE,GAClE,iDAAiD,GACjD,mDAAmD,CACtD,CAAC;gBACJ,CAAC;YACH,CAAC;QACH,CAAC;QAGD,CAAC;YACC,MAAM,iBAAiB,GAAG,+BAA+B,CAAC,aAAa,CAAC,CAAC;YACzE,IAAI,CAAC,iBAAiB,EAAE,CAAC;gBAOvB,MAAM,EAAE,6BAA6B,EAAE,GAAG,MAAM,MAAM,CACpD,+BAA+B,CAChC,CAAC;gBACF,OAAO,CAAC,IAAI,CACV,6BAA6B,CAAC;oBAAE,wBAAwB,EAAE,IAAI;gBAAA,CAAE,CAAC,CAClE,CAAC;YACJ,CAAC;QACH,CAAC;QAeD,MAAM,iBAAiB,GAAG,+BAA+B,CACvD,qBAAqB,CACtB,CAAC;QACF,IAAI,CAAC,iBAAiB,EAAE,CAAC;YACvB,MAAM,EACJ,yCAAyC,EACzC,8CAA8C,EAC/C,GAAG,MAAM,MAAM,CAAC,uCAAuC,CAAC,CAAC;YAC1D,MAAM,MAAM,GAAiC,KAAK,GAC9C,yCAAyC,EAAE,GAC3C,8CAA8C,EAAE,CAAC;YACrD,IAAI,CAAC,6BAA6B,CAAC,MAAM,CAAC,EAAE,CAAC;gBAC3C,MAAM,KAAK,CACT,+DAA+D,CAChE,CAAC;YACJ,CAAC;YACD,MAAM,CAAC,iCAAiC,GAAG,IAAI,CAAC;YAChD,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACvB,CAAC;QAED,CAAC;YACC,MAAM,iBAAiB,GACrB,+BAA+B,CAAC,oBAAoB,CAAC,CAAC;YACxD,IAAI,iCAAiC,IAAI,CAAC,iBAAiB,EAAE,CAAC;gBAC5D,MAAM,EAAE,oCAAoC,EAAE,GAAG,MAAM,MAAM,CAC3D,sCAAsC,CACvC,CAAC;gBACF,OAAO,CAAC,IAAI,CAAC,oCAAoC,EAAE,CAAC,CAAC;YACvD,CAAC;QACH,CAAC;IACH,CAAC;IAEM,SAAS,CAAC,MAAoC,EAAA;QACnD,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,KAAK,aAAa,EAAE,CAAC;YACjD,MAAM,IAAI,KAAK,CAAC,gDAAgD,CAAC,CAAC;QACpE,CAAC;QACD,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACtC,CAAC;IAEM,KAAK,CAAC,yBAAyB,CAAC,EACrC,kBAAkB,EAClB,OAAO,EAIR,EAAA;QACC,IAAI,CAAC;YACH,IAAI,kBAAkB,CAAC;YACvB,IAAI,CAAC;gBACH,kBAAkB,GAAG,MAAM,IAAI,CAAC,cAAc,EAAE,CAAC;YACnD,CAAC,CAAC,OAAO,KAAc,EAAE,CAAC;gBAIxB,OAAO,MAAM,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,kBAAkB,CAAC,CAAC;YAC7D,CAAC;YAED,IACE,kBAAkB,CAAC,WAAW,IAC9B,IAAI,CAAC,WAAW,CAAC,kBAAkB,CAAC,EACpC,CAAC;gBACD,IAAI,YAAY,CAAC;gBACjB,IAAI,OAAO,kBAAkB,CAAC,WAAW,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;oBAC5D,YAAY,GAAG,kBAAkB,CAAC,WAAW,CAAC,IAAI,CAAC;gBACrD,CAAC,MAAM,CAAC;oBACN,IAAI,CAAC;wBACH,YAAY,GAAG,MAAM,kBAAkB,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC;oBAC7D,CAAC,CAAC,OAAO,UAAmB,EAAE,CAAC;wBAC7B,MAAM,KAAK,6KAAG,cAAA,AAAW,EAAC,UAAU,CAAC,CAAC;wBACtC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAA,sCAAA,EAAyC,KAAK,EAAE,CAAC,CAAC;wBACpE,OAAO,MAAM,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,kBAAkB,CAAC,CAAC;oBAC7D,CAAC;gBACH,CAAC;gBAED,OAAO;oBACL,OAAO,EAAE,8KAAI,YAAS,CAAC;wBAAC;4BAAC,cAAc;4BAAE,WAAW;yBAAC;qBAAC,CAAC;oBACvD,IAAI,EAAE;wBACJ,IAAI,EAAE,UAAU;wBAChB,MAAM,EAAE,YAAY;qBACrB;iBACF,CAAC;YACJ,CAAC;YAID,IAAI,IAAI,CAAC,SAAS,CAAC,4BAA4B,EAAE,CAAC;oBAChD,iLAAA,AAAW,EACT,kBAAkB,CAAC,OAAO,EAC1B,IAAI,CAAC,SAAS,CAAC,4BAA4B,CAC5C,CAAC;YACJ,CAAC;YAED,IAAI,YAAsB,CAAC;YAC3B,IAAI,CAAC;gBACH,YAAY,GAAG,MAAM,OAAO,EAAE,CAAC;YACjC,CAAC,CAAC,OAAO,UAAmB,EAAE,CAAC;gBAC7B,MAAM,KAAK,6KAAG,cAAA,AAAW,EAAC,UAAU,CAAC,CAAC;gBACtC,IAAI,CAAC;oBACH,MAAM,OAAO,CAAC,GAAG,CACf,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,CACxC,CAD0C,KACpC,CAAC,sBAAsB,EAAE,CAAC;4BAC9B,KAAK;yBACN,CAAC,CACH,CACF,CAAC;gBACJ,CAAC,CAAC,OAAO,WAAW,EAAE,CAAC;oBACrB,IAAI,CAAC,MAAM,CAAC,KAAK,CACf,CAAA,mCAAA,EAAsC,WAAW,EAAE,CACpD,CAAC;gBACJ,CAAC;gBAKD,OAAO,MAAM,IAAI,CAAC,aAAa,2KAC7B,qBAAA,AAAkB,EAAC,KAAK,EAAE,2BAA2B,CAAC,EACtD,kBAAkB,CACnB,CAAC;YACJ,CAAC;YAED,OAAO,8KAAM,iCAAA,AAA8B,EACzC,IAAI,EACJ,kBAAkB,EAClB,YAAY,EACZ,kBAAkB,CAAC,aAAa,CAAC,oBAAoB,EAAE,EACvD,IAAI,CAAC,SAAS,CACf,CAAC;QACJ,CAAC,CAAC,OAAO,WAAoB,EAAE,CAAC;YAC9B,MAAM,UAAU,GAAG,WAAW,CAAC;YAC/B,IACE,UAAU,gKAAY,eAAY,IAClC,UAAU,CAAC,UAAU,CAAC,IAAI,4KAAK,wBAAqB,CAAC,WAAW,EAChE,CAAC;gBACD,IAAI,CAAC;oBACH,MAAM,OAAO,CAAC,GAAG,CACf,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,CACxC,CAD0C,KACpC,CAAC,yBAAyB,EAAE,CAAC;4BAAE,KAAK,EAAE,UAAU;wBAAA,CAAE,CAAC,CAC1D,CACF,CAAC;gBACJ,CAAC,CAAC,OAAO,WAAW,EAAE,CAAC;oBACrB,IAAI,CAAC,MAAM,CAAC,KAAK,CACf,CAAA,sCAAA,EAAyC,WAAW,EAAE,CACvD,CAAC;gBACJ,CAAC;YACH,CAAC;YACD,OAAO,MAAM,IAAI,CAAC,aAAa,CAAC,UAAU,EAAE,kBAAkB,CAAC,CAAC;QAClE,CAAC;IACH,CAAC;IAEO,KAAK,CAAC,aAAa,CACzB,KAAc,EACd,WAA4B,EAAA;QAE5B,MAAM,EAAE,eAAe,EAAE,cAAc,EAAE,6KAAG,2BAAA,AAAwB,EAClE;YAAC,KAAK;SAAC,EACP;YACE,iCAAiC,EAC/B,IAAI,CAAC,SAAS,CAAC,iCAAiC;YAClD,WAAW,EAAE,IAAI,CAAC,SAAS,CAAC,WAAW;SACxC,CACF,CAAC;QAEF,OAAO;YACL,MAAM,EAAE,cAAc,CAAC,MAAM,IAAI,GAAG;YACpC,OAAO,EAAE,8KAAI,YAAS,CAAC;mBAClB,cAAc,CAAC,OAAO;gBACzB;oBACE,cAAc;oBAQd,wCAAwC,CAAC,WAAW,CAAC,IACnD,WAAW,CAAC,gBAAgB;iBAC/B;aACF,CAAC;YACF,IAAI,EAAE;gBACJ,IAAI,EAAE,UAAU;gBAChB,MAAM,EAAE,MAAM,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC;oBAC3C,MAAM,EAAE,eAAe;iBACxB,CAAC;aACH;SACF,CAAC;IACJ,CAAC;IAEO,WAAW,CAAC,OAA2B,EAAA;QAC7C,MAAM,YAAY,GAAG,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QACnD,OAAO,AACL,OAAO,CAAC,MAAM,KAAK,KAAK,IACxB,CAAC,CAAC,YAAY,IACd,0IAAI,UAAU,CAAC;YACb,OAAO,EAAE;gBAAE,MAAM,EAAE,YAAY;YAAA,CAAE;SAClC,CAAC,CAAC,SAAS,CAAC;YAIX,WAAW,CAAC,gBAAgB;YAC5B,WAAW,CAAC,iCAAiC;YAC7C,WAAW,CAAC,4BAA4B;YACxC,WAAW,CAAC,6BAA6B;YACzC,WAAW,CAAC,SAAS;SACtB,CAAC,KAAK,WAAW,CAAC,SAAS,CAC7B,CAAC;IACJ,CAAC;IAyCD,KAAK,CAAC,gBAAgB,CAIpB,OAKC,EACD,UAA6C,CAAA,CAAE,EAAA;QAK/C,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,KAAK,aAAa,EAAE,CAAC;YACjD,MAAM,IAAI,CAAC,KAAK,EAAE,CAAC;QACrB,CAAC;QAED,MAAM,iBAAiB,GAAG,CACxB,MAAM,IAAI,CAAC,cAAc,EAAE,CAC5B,CAAC,aAAa,CAAC,oBAAoB,EAAE,CAAC;QAIvC,MAAM,cAAc,GAAmB;YACrC,GAAG,OAAO;YACV,KAAK,EACH,OAAO,CAAC,KAAK,IAAI,OAAO,OAAO,CAAC,KAAK,KAAK,QAAQ,yJAC9C,QAAA,AAAK,EAAC,OAAO,CAAC,KAAK,CAAC,GACpB,OAAO,CAAC,KAAK;SACpB,CAAC;QAEF,MAAM,QAAQ,GAAoB,MAAM,wBAAwB,CAC9D;YACE,MAAM,EAAE,IAAI;YACZ,cAAc;YACd,SAAS,EAAE,IAAI,CAAC,SAAS;YACzB,iBAAiB;YACjB,6BAA6B,EAAE,IAAI;SACpC,EACD,OAAO,CACR,CAAC;QAIF,OAAO,QAAkC,CAAC;IAC5C,CAAC;CACF;AAIM,KAAK,UAAU,wBAAwB,CAC5C,EACE,MAAM,EACN,cAAc,EACd,SAAS,EACT,iBAAiB,EACjB,6BAA6B,EAO9B,EACD,OAA0C;IAE1C,MAAM,cAAc,GAAoC;QACtD,MAAM,EAAE,MAAM,CAAC,MAAM;QACrB,KAAK,EAAE,MAAM,CAAC,KAAK;QACnB,MAAM,EAAE,iBAAiB,CAAC,MAAM;QAChC,OAAO,EAAE,cAAc;QACvB,QAAQ,EAAE;YACR,IAAI,EAAE,6BAA6B,2KAAI,sBAAA,AAAkB,EAAE;SAC5D;QAgBD,YAAY,EAAE,WAAW,CAAC,OAAO,EAAE,YAAY,IAAK,CAAA,CAAe,CAAC;QACpE,OAAO,EAAE,CAAA,CAAE;QACX,kBAAkB,MAAE,oLAAA,AAAc,EAAE;QACpC,gBAAgB,EAAE,6BAA6B,KAAK,IAAI;KACzD,CAAC;IAEF,IAAI,CAAC;QACH,OAAO,iLAAM,wBAAqB,AAArB,EACX,iBAAiB,EACjB,MAAM,EACN,SAAS,EACT,cAAc,CACf,CAAC;IACJ,CAAC,CAAC,OAAO,UAAmB,EAAE,CAAC;QAG7B,MAAM,KAAK,6KAAG,cAAA,AAAW,EAAC,UAAU,CAAC,CAAC;QAGtC,MAAM,OAAO,CAAC,GAAG,CACf,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,CACnC,CADqC,KAC/B,CAAC,gCAAgC,EAAE,CAAC;gBACxC,cAAc;gBACd,KAAK;aACN,CAAC,CACH,CACF,CAAC;QAEF,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAA,qCAAA,EAAwC,KAAK,EAAE,CAAC,CAAC;QACrE,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;IAC3C,CAAC;AACH,CAAC;AAaK,SAAU,6BAA6B,CAC3C,CAA+B;IAE/B,OAAO,mCAAmC,IAAI,CAAC,CAAC;AAClD,CAAC;AAEM,MAAM,WAAW,GAAG;IACzB,gBAAgB,EAAE,iCAAiC;IACnD,iCAAiC,EAC/B,mDAAmD;IACrD,iCAAiC,EAC/B,kDAAkD;IAGpD,6BAA6B,EAAE,iBAAiB;IAChD,4BAA4B,EAAE,qCAAqC;IACnE,SAAS,EAAE,WAAW;CACvB,CAAC;AAEI,SAAU,wCAAwC,CACtD,IAAqB;IAErB,MAAM,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;IAChD,IAAI,CAAC,YAAY,EAAE,CAAC;QAIlB,OAAO,WAAW,CAAC,gBAAgB,CAAC;IACtC,CAAC,MAAM,CAAC;QACN,MAAM,SAAS,GAAG,0IAAI,UAAU,CAAC;YAC/B,OAAO,EAAE;gBAAE,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC;YAAA,CAAE;SAChD,CAAC,CAAC,SAAS,CAAC;YACX,WAAW,CAAC,gBAAgB;YAC5B,WAAW,CAAC,iCAAiC;YAC7C,WAAW,CAAC,iCAAiC;SAC9C,CAAC,CAAC;QACH,IAAI,SAAS,EAAE,CAAC;YACd,OAAO,SAAS,CAAC;QACnB,CAAC,MAAM,CAAC;YACN,OAAO,IAAI,CAAC;QACd,CAAC;IACH,CAAC;AACH,CAAC;AAED,SAAS,WAAW,CAAmB,MAAS;IAC9C,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;AAC7E,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2117, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2123, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/externalTypes/index.ts"],"sourcesContent":["/**\n * This file represents the external type definitions needed by end users,\n * integration implementors, and plugin implementors. Everything from this file\n * is re-exported by the root (via * export), so add exports to this file with\n * intention (it's public API).\n */\nexport type { BaseContext, ContextFunction, ContextThunk } from './context.js';\nexport type { GraphQLRequest, GraphQLResponse } from './graphql.js';\nexport type {\n  HTTPGraphQLRequest,\n  HTTPGraphQLResponse,\n  HTTPGraphQLHead,\n} from './http.js';\nexport type {\n  ApolloServerPlugin,\n  GraphQLFieldResolverParams,\n  GraphQLRequestExecutionListener,\n  GraphQLRequestListener,\n  GraphQLRequestListenerDidResolveField,\n  GraphQLRequestListenerExecutionDidEnd,\n  GraphQLRequestListenerParsingDidEnd,\n  GraphQLRequestListenerValidationDidEnd,\n  GraphQLSchemaContext,\n  GraphQLServerListener,\n  GraphQLServerContext,\n  LandingPage,\n} from './plugins.js';\nexport type {\n  GraphQLRequestContext,\n  GraphQLRequestMetrics,\n  GraphQLRequestContextDidEncounterErrors,\n  GraphQLRequestContextDidResolveOperation,\n  GraphQLRequestContextDidResolveSource,\n  GraphQLRequestContextExecutionDidStart,\n  GraphQLRequestContextParsingDidStart,\n  GraphQLRequestContextResponseForOperation,\n  GraphQLRequestContextValidationDidStart,\n  GraphQLRequestContextWillSendResponse,\n} from './requestPipeline.js';\nexport type {\n  DocumentStore,\n  ApolloConfigInput,\n  ApolloConfig,\n  PersistedQueryOptions,\n  CSRFPreventionOptions,\n  ApolloServerOptionsWithSchema,\n  ApolloServerOptionsWithTypeDefs,\n  ApolloServerOptionsWithStaticSchema,\n  ApolloServerOptionsWithGateway,\n  ApolloServerOptions,\n} from './constructor.js';\n\nexport type {\n  GraphQLExperimentalFormattedInitialIncrementalExecutionResult,\n  GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult,\n  GraphQLExperimentalFormattedIncrementalResult,\n  GraphQLExperimentalFormattedIncrementalDeferResult,\n  GraphQLExperimentalFormattedIncrementalStreamResult,\n} from './incrementalDeliveryPolyfill.js';\n"],"names":[],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 2126, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2132, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/index.ts"],"sourcesContent":["export { ApolloServer } from './ApolloServer.js';\nexport { HeaderMap } from './utils/HeaderMap.js';\n// Note that this is purely a type export.\nexport * from './externalTypes/index.js';\n"],"names":[],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 2137, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2153, "column": 0}, "map": {"version":3,"file":"resolvable.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/utils/resolvable.ts"],"sourcesContent":["// Copyright 2019 Joseph Gentle\n\n// Permission to use, copy, modify, and / or distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n// FITNESS.IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n//   INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n// LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n// OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n// PERFORMANCE OF THIS SOFTWARE.\n\nexport type Resolvable<T> = Promise<T> & {\n  resolve: (t: T) => void;\n  reject: (e: any) => void;\n};\n\nexport default <T = void>(): Resolvable<T> => {\n  let resolve: (val: T) => void;\n  let reject: (err: any) => void;\n  const promise = new Promise<T>((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  }) as Resolvable<T>;\n  promise.resolve = resolve!;\n  promise.reject = reject!;\n  return promise;\n};\n"],"names":[],"mappings":";;;;AAmBA,QAAA,OAAA,GAAe,GAA4B,EAAE;IAC3C,IAAI,OAAyB,CAAC;IAC9B,IAAI,MAA0B,CAAC;IAC/B,MAAM,OAAO,GAAG,IAAI,OAAO,CAAI,CAAC,QAAQ,EAAE,OAAO,EAAE,EAAE;QACnD,OAAO,GAAG,QAAQ,CAAC;QACnB,MAAM,GAAG,OAAO,CAAC;IACnB,CAAC,CAAkB,CAAC;IACpB,OAAO,CAAC,OAAO,GAAG,OAAQ,CAAC;IAC3B,OAAO,CAAC,MAAM,GAAG,MAAO,CAAC;IACzB,OAAO,OAAO,CAAC;AACjB,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2168, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2173, "column": 0}, "map": {"version":3,"file":"cachePolicy.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/cachePolicy.ts"],"sourcesContent":["import type { CacheHint, CachePolicy } from '@apollo/cache-control-types';\n\nexport function newCachePolicy(): CachePolicy {\n  return {\n    maxAge: undefined,\n    scope: undefined,\n    restrict(hint: CacheHint) {\n      if (\n        hint.maxAge !== undefined &&\n        (this.maxAge === undefined || hint.maxAge < this.maxAge)\n      ) {\n        this.maxAge = hint.maxAge;\n      }\n      if (hint.scope !== undefined && this.scope !== 'PRIVATE') {\n        this.scope = hint.scope;\n      }\n    },\n    replace(hint: CacheHint) {\n      if (hint.maxAge !== undefined) {\n        this.maxAge = hint.maxAge;\n      }\n      if (hint.scope !== undefined) {\n        this.scope = hint.scope;\n      }\n    },\n    policyIfCacheable() {\n      if (this.maxAge === undefined || this.maxAge === 0) {\n        return null;\n      }\n      return { maxAge: this.maxAge, scope: this.scope ?? 'PUBLIC' };\n    },\n  };\n}\n"],"names":[],"mappings":";;;;;AAEA,SAAgB,cAAc;IAC5B,OAAO;QACL,MAAM,EAAE,SAAS;QACjB,KAAK,EAAE,SAAS;QAChB,QAAQ,EAAC,IAAe;YACtB,IACE,IAAI,CAAC,MAAM,KAAK,SAAS,IACzB,CAAC,IAAI,CAAC,MAAM,KAAK,SAAS,IAAI,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,EACxD,CAAC;gBACD,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;YAC5B,CAAC;YACD,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,EAAE,CAAC;gBACzD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;YAC1B,CAAC;QACH,CAAC;QACD,OAAO,EAAC,IAAe;YACrB,IAAI,IAAI,CAAC,MAAM,KAAK,SAAS,EAAE,CAAC;gBAC9B,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;YAC5B,CAAC;YACD,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,EAAE,CAAC;gBAC7B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;YAC1B,CAAC;QACH,CAAC;QACD,iBAAiB;YACf,IAAI,IAAI,CAAC,MAAM,KAAK,SAAS,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;gBACnD,OAAO,IAAI,CAAC;YACd,CAAC;YACD,OAAO;gBAAE,MAAM,EAAE,IAAI,CAAC,MAAM;gBAAE,KAAK,EAAE,IAAI,CAAC,KAAK,IAAI,QAAQ;YAAA,CAAE,CAAC;QAChE,CAAC;KACF,CAAC;AACJ,CAAC;AA9BD,QAAA,cAAA,GAAA,eA8BC","ignoreList":[0]}},
    {"offset": {"line": 2210, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2215, "column": 0}, "map": {"version":3,"file":"determineApolloConfig.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/determineApolloConfig.ts"],"sourcesContent":["import { createHash } from '@apollo/utils.createhash';\nimport type { ApolloConfig, ApolloConfigInput } from './externalTypes/index.js';\nimport type { Logger } from '@apollo/utils.logger';\n\n// This function combines the `apollo` constructor argument and some environment\n// variables to come up with a full ApolloConfig.\nexport function determineApolloConfig(\n  input: ApolloConfigInput | undefined,\n  logger: Logger,\n): ApolloConfig {\n  const apolloConfig: ApolloConfig = {};\n\n  const {\n    APOLLO_KEY,\n    APOLLO_GRAPH_REF,\n    APOLLO_GRAPH_ID,\n    APOLLO_GRAPH_VARIANT,\n  } = process.env;\n\n  // Determine key.\n  if (input?.key) {\n    apolloConfig.key = input.key.trim();\n  } else if (APOLLO_KEY) {\n    apolloConfig.key = APOLLO_KEY.trim();\n  }\n  if ((input?.key ?? APOLLO_KEY) !== apolloConfig.key) {\n    logger.warn(\n      'The provided API key has unexpected leading or trailing whitespace. ' +\n        'Apollo Server will trim the key value before use.',\n    );\n  }\n\n  // Assert API key is a valid header value, since it's going to be used as one\n  // throughout.\n  if (apolloConfig.key) {\n    assertValidHeaderValue(apolloConfig.key);\n  }\n\n  // Determine key hash.\n  if (apolloConfig.key) {\n    apolloConfig.keyHash = createHash('sha512')\n      .update(apolloConfig.key)\n      .digest('hex');\n  }\n\n  // Determine graph ref, if provided together.\n  if (input?.graphRef) {\n    apolloConfig.graphRef = input.graphRef;\n  } else if (APOLLO_GRAPH_REF) {\n    apolloConfig.graphRef = APOLLO_GRAPH_REF;\n  }\n\n  // See if graph ID and variant were provided separately.\n  const graphId = input?.graphId ?? APOLLO_GRAPH_ID;\n  const graphVariant = input?.graphVariant ?? APOLLO_GRAPH_VARIANT;\n\n  if (apolloConfig.graphRef) {\n    if (graphId) {\n      throw new Error(\n        'Cannot specify both graph ref and graph ID. Please use ' +\n          '`apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph ID.',\n      );\n    }\n    if (graphVariant) {\n      throw new Error(\n        'Cannot specify both graph ref and graph variant. Please use ' +\n          '`apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph variant.',\n      );\n    }\n  } else if (graphId) {\n    // Graph ref is not specified, but the ID is. We can construct the ref\n    // from the ID and variant. Note that after this, we stop tracking the ID\n    // and variant, because Apollo Server 3 does not assume that all graph refs\n    // can be decomposed into ID and variant (except in the op reg plugin).\n    apolloConfig.graphRef = graphVariant\n      ? `${graphId}@${graphVariant}`\n      : graphId;\n  }\n\n  return apolloConfig;\n}\n\nfunction assertValidHeaderValue(value: string) {\n  // Ref: node-fetch@2.x `Headers` validation\n  // https://github.com/node-fetch/node-fetch/blob/9b9d45881e5ca68757077726b3c0ecf8fdca1f29/src/headers.js#L18\n  const invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/g;\n  if (invalidHeaderCharRegex.test(value)) {\n    const invalidChars = value.match(invalidHeaderCharRegex)!;\n    throw new Error(\n      `The API key provided to Apollo Server contains characters which are invalid as HTTP header values. The following characters found in the key are invalid: ${invalidChars.join(\n        ', ',\n      )}. Valid header values may only contain ASCII visible characters. If you think there is an issue with your key, please contact Apollo support.`,\n    );\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA,yDAAsD;AAMtD,SAAgB,qBAAqB,CACnC,KAAoC,EACpC,MAAc;IAEd,MAAM,YAAY,GAAiB,CAAA,CAAE,CAAC;IAEtC,MAAM,EACJ,UAAU,EACV,gBAAgB,EAChB,eAAe,EACf,oBAAoB,EACrB,GAAG,OAAO,CAAC,GAAG,CAAC;IAGhB,IAAI,KAAK,EAAE,GAAG,EAAE,CAAC;QACf,YAAY,CAAC,GAAG,GAAG,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC;IACtC,CAAC,MAAM,IAAI,UAAU,EAAE,CAAC;QACtB,YAAY,CAAC,GAAG,GAAG,UAAU,CAAC,IAAI,EAAE,CAAC;IACvC,CAAC;IACD,IAAI,CAAC,KAAK,EAAE,GAAG,IAAI,UAAU,CAAC,KAAK,YAAY,CAAC,GAAG,EAAE,CAAC;QACpD,MAAM,CAAC,IAAI,CACT,sEAAsE,GACpE,mDAAmD,CACtD,CAAC;IACJ,CAAC;IAID,IAAI,YAAY,CAAC,GAAG,EAAE,CAAC;QACrB,sBAAsB,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC;IAC3C,CAAC;IAGD,IAAI,YAAY,CAAC,GAAG,EAAE,CAAC;QACrB,YAAY,CAAC,OAAO,GAAG,CAAA,GAAA,mBAAA,UAAU,EAAC,QAAQ,CAAC,CACxC,MAAM,CAAC,YAAY,CAAC,GAAG,CAAC,CACxB,MAAM,CAAC,KAAK,CAAC,CAAC;IACnB,CAAC;IAGD,IAAI,KAAK,EAAE,QAAQ,EAAE,CAAC;QACpB,YAAY,CAAC,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC;IACzC,CAAC,MAAM,IAAI,gBAAgB,EAAE,CAAC;QAC5B,YAAY,CAAC,QAAQ,GAAG,gBAAgB,CAAC;IAC3C,CAAC;IAGD,MAAM,OAAO,GAAG,KAAK,EAAE,OAAO,IAAI,eAAe,CAAC;IAClD,MAAM,YAAY,GAAG,KAAK,EAAE,YAAY,IAAI,oBAAoB,CAAC;IAEjE,IAAI,YAAY,CAAC,QAAQ,EAAE,CAAC;QAC1B,IAAI,OAAO,EAAE,CAAC;YACZ,MAAM,IAAI,KAAK,CACb,yDAAyD,GACvD,4EAA4E,CAC/E,CAAC;QACJ,CAAC;QACD,IAAI,YAAY,EAAE,CAAC;YACjB,MAAM,IAAI,KAAK,CACb,8DAA8D,GAC5D,iFAAiF,CACpF,CAAC;QACJ,CAAC;IACH,CAAC,MAAM,IAAI,OAAO,EAAE,CAAC;QAKnB,YAAY,CAAC,QAAQ,GAAG,YAAY,GAChC,GAAG,OAAO,CAAA,CAAA,EAAI,YAAY,EAAE,GAC5B,OAAO,CAAC;IACd,CAAC;IAED,OAAO,YAAY,CAAC;AACtB,CAAC;AA1ED,QAAA,qBAAA,GAAA,sBA0EC;AAED,SAAS,sBAAsB,CAAC,KAAa;IAG3C,MAAM,sBAAsB,GAAG,0BAA0B,CAAC;IAC1D,IAAI,sBAAsB,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;QACvC,MAAM,YAAY,GAAG,KAAK,CAAC,KAAK,CAAC,sBAAsB,CAAE,CAAC;QAC1D,MAAM,IAAI,KAAK,CACb,CAAA,0JAAA,EAA6J,YAAY,CAAC,IAAI,CAC5K,IAAI,CACL,CAAA,6IAAA,CAA+I,CACjJ,CAAC;IACJ,CAAC;AACH,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2265, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2270, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/errors/index.ts"],"sourcesContent":["import { GraphQLError } from 'graphql';\n\nexport enum ApolloServerErrorCode {\n  INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR',\n  GRAPHQL_PARSE_FAILED = 'GRAPHQL_PARSE_FAILED',\n  GRAPHQL_VALIDATION_FAILED = 'GRAPHQL_VALIDATION_FAILED',\n  PERSISTED_QUERY_NOT_FOUND = 'PERSISTED_QUERY_NOT_FOUND',\n  PERSISTED_QUERY_NOT_SUPPORTED = 'PERSISTED_QUERY_NOT_SUPPORTED',\n  BAD_USER_INPUT = 'BAD_USER_INPUT',\n  OPERATION_RESOLUTION_FAILURE = 'OPERATION_RESOLUTION_FAILURE',\n  BAD_REQUEST = 'BAD_REQUEST',\n}\n\nexport enum ApolloServerValidationErrorCode {\n  INTROSPECTION_DISABLED = 'INTROSPECTION_DISABLED',\n}\n\n/**\n * unwrapResolverError is a useful helper function for `formatError` hooks.\n * Errors thrown in resolvers are wrapped by graphql-js in a GraphQLError that\n * adds context such as the `path` to the field in the operation. If you'd like\n * to look directly at the original error thrown in the resolver (with whatever\n * data is on that error object, but without fields like `path`), you can use\n * this function. Note that other GraphQLErrors that contain `originalError`\n * (like parse errors) are not unwrapped by this function.\n */\nexport function unwrapResolverError(error: unknown): unknown {\n  if (error instanceof GraphQLError && error.path && error.originalError) {\n    return error.originalError;\n  }\n  return error;\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA,+BAAuC;AAEvC,IAAY,qBASX;AATD,CAAA,SAAY,qBAAqB;IAC/B,qBAAA,CAAA,wBAAA,GAAA,uBAA+C,CAAA;IAC/C,qBAAA,CAAA,uBAAA,GAAA,sBAA6C,CAAA;IAC7C,qBAAA,CAAA,4BAAA,GAAA,2BAAuD,CAAA;IACvD,qBAAA,CAAA,4BAAA,GAAA,2BAAuD,CAAA;IACvD,qBAAA,CAAA,gCAAA,GAAA,+BAA+D,CAAA;IAC/D,qBAAA,CAAA,iBAAA,GAAA,gBAAiC,CAAA;IACjC,qBAAA,CAAA,+BAAA,GAAA,8BAA6D,CAAA;IAC7D,qBAAA,CAAA,cAAA,GAAA,aAA2B,CAAA;AAC7B,CAAC,EATW,qBAAqB,IAAA,CAAA,QAAA,qBAAA,GAArB,qBAAqB,GAAA,CAAA,CAAA,GAShC;AAED,IAAY,+BAEX;AAFD,CAAA,SAAY,+BAA+B;IACzC,+BAAA,CAAA,yBAAA,GAAA,wBAAiD,CAAA;AACnD,CAAC,EAFW,+BAA+B,IAAA,CAAA,QAAA,+BAAA,GAA/B,+BAA+B,GAAA,CAAA,CAAA,GAE1C;AAWD,SAAgB,mBAAmB,CAAC,KAAc;IAChD,IAAI,KAAK,YAAY,UAAA,YAAY,IAAI,KAAK,CAAC,IAAI,IAAI,KAAK,CAAC,aAAa,EAAE,CAAC;QACvE,OAAO,KAAK,CAAC,aAAa,CAAC;IAC7B,CAAC;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AALD,QAAA,mBAAA,GAAA,oBAKC","ignoreList":[0]}},
    {"offset": {"line": 2298, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2303, "column": 0}, "map": {"version":3,"file":"HeaderMap.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/utils/HeaderMap.ts"],"sourcesContent":["export class HeaderMap extends Map<string, string> {\n  // In order for TypeScript to prevent a standard `Map` from being compatible\n  // with a `HeaderMap`, we need some additional property on the class.\n  // @ts-ignore (this is just unused)\n  private __identity = Symbol('HeaderMap');\n\n  override set(key: string, value: string): this {\n    return super.set(key.toLowerCase(), value);\n  }\n\n  override get(key: string) {\n    return super.get(key.toLowerCase());\n  }\n\n  override delete(key: string) {\n    return super.delete(key.toLowerCase());\n  }\n\n  override has(key: string) {\n    return super.has(key.toLowerCase());\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAa,SAAU,SAAQ,GAAmB;IAAlD,aAAA;;QAIU,IAAA,CAAA,UAAU,GAAG,MAAM,CAAC,WAAW,CAAC,CAAC;IAiB3C,CAAC;IAfU,GAAG,CAAC,GAAW,EAAE,KAAa,EAAA;QACrC,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,WAAW,EAAE,EAAE,KAAK,CAAC,CAAC;IAC7C,CAAC;IAEQ,GAAG,CAAC,GAAW,EAAA;QACtB,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,CAAC;IACtC,CAAC;IAEQ,MAAM,CAAC,GAAW,EAAA;QACzB,OAAO,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,CAAC;IACzC,CAAC;IAEQ,GAAG,CAAC,GAAW,EAAA;QACtB,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,CAAC;IACtC,CAAC;CACF;AArBD,QAAA,SAAA,GAAA,UAqBC","ignoreList":[0]}},
    {"offset": {"line": 2327, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2332, "column": 0}, "map": {"version":3,"file":"internalErrorClasses.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/internalErrorClasses.ts"],"sourcesContent":["import { GraphQLError, type GraphQLErrorOptions } from 'graphql';\nimport { ApolloServerErrorCode } from './errors/index.js';\nimport { newHTTPGraphQLHead } from './runHttpQuery.js';\nimport { HeaderMap } from './utils/HeaderMap.js';\n\n// These error classes are not part of Apollo Server's external API; the\n// ApolloServerErrorCode enum is (exported from `@apollo/server/errors`).\n\nclass GraphQLErrorWithCode extends GraphQLError {\n  constructor(\n    message: string,\n    code: ApolloServerErrorCode,\n    options?: GraphQLErrorOptions,\n  ) {\n    super(message, {\n      ...options,\n      extensions: { ...options?.extensions, code },\n    });\n    this.name = this.constructor.name;\n  }\n}\n\nexport class SyntaxError extends GraphQLErrorWithCode {\n  constructor(graphqlError: GraphQLError) {\n    super(graphqlError.message, ApolloServerErrorCode.GRAPHQL_PARSE_FAILED, {\n      source: graphqlError.source,\n      positions: graphqlError.positions,\n      extensions: { http: newHTTPGraphQLHead(400), ...graphqlError.extensions },\n      originalError: graphqlError,\n    });\n  }\n}\n\nexport class ValidationError extends GraphQLErrorWithCode {\n  constructor(graphqlError: GraphQLError) {\n    super(\n      graphqlError.message,\n      ApolloServerErrorCode.GRAPHQL_VALIDATION_FAILED,\n      {\n        nodes: graphqlError.nodes,\n        extensions: {\n          http: newHTTPGraphQLHead(400),\n          ...graphqlError.extensions,\n        },\n        originalError: graphqlError.originalError ?? graphqlError,\n      },\n    );\n  }\n}\n\n// Persisted query errors (especially \"not found\") need to be uncached, because\n// hopefully we're about to fill in the APQ cache and the same request will\n// succeed next time. We also want a 200 response to avoid any error handling\n// that may mask the contents of an error response. (Otherwise, the default\n// status code for a response with `errors` but no `data` (even null) is 400.)\nconst getPersistedQueryErrorHttp = () => ({\n  status: 200,\n  headers: new HeaderMap([\n    ['cache-control', 'private, no-cache, must-revalidate'],\n  ]),\n});\n\nexport class PersistedQueryNotFoundError extends GraphQLErrorWithCode {\n  constructor() {\n    super(\n      'PersistedQueryNotFound',\n      ApolloServerErrorCode.PERSISTED_QUERY_NOT_FOUND,\n      { extensions: { http: getPersistedQueryErrorHttp() } },\n    );\n  }\n}\n\nexport class PersistedQueryNotSupportedError extends GraphQLErrorWithCode {\n  constructor() {\n    super(\n      'PersistedQueryNotSupported',\n      ApolloServerErrorCode.PERSISTED_QUERY_NOT_SUPPORTED,\n      // Not super clear why we need this to be uncached (makes sense for\n      // PersistedQueryNotFoundError, because there we're about to fill the\n      // cache and make the next copy of the same request succeed) but we've\n      // been doing it for years so :shrug:\n      { extensions: { http: getPersistedQueryErrorHttp() } },\n    );\n  }\n}\n\nexport class UserInputError extends GraphQLErrorWithCode {\n  constructor(graphqlError: GraphQLError) {\n    super(graphqlError.message, ApolloServerErrorCode.BAD_USER_INPUT, {\n      nodes: graphqlError.nodes,\n      originalError: graphqlError.originalError ?? graphqlError,\n      extensions: graphqlError.extensions,\n    });\n  }\n}\n\nexport class OperationResolutionError extends GraphQLErrorWithCode {\n  constructor(graphqlError: GraphQLError) {\n    super(\n      graphqlError.message,\n      ApolloServerErrorCode.OPERATION_RESOLUTION_FAILURE,\n      {\n        nodes: graphqlError.nodes,\n        originalError: graphqlError.originalError ?? graphqlError,\n        extensions: {\n          http: newHTTPGraphQLHead(400),\n          ...graphqlError.extensions,\n        },\n      },\n    );\n  }\n}\n\nexport class BadRequestError extends GraphQLErrorWithCode {\n  constructor(message: string, options?: GraphQLErrorOptions) {\n    super(message, ApolloServerErrorCode.BAD_REQUEST, {\n      ...options,\n      // Default to 400 status code, but caller can override. (If caller just\n      // wants to override headers... well, they can't, sorry.)\n      extensions: { http: newHTTPGraphQLHead(400), ...options?.extensions },\n    });\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2444, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2449, "column": 0}, "map": {"version":3,"file":"runHttpQuery.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/runHttpQuery.ts"],"sourcesContent":["import type {\n  BaseContext,\n  GraphQLExperimentalFormattedIncrementalResult,\n  GraphQLExperimentalFormattedInitialIncrementalExecutionResult,\n  GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult,\n  GraphQLRequest,\n  HTTPGraphQLHead,\n  HTTPGraphQLRequest,\n  HTTPGraphQLResponse,\n} from './externalTypes/index.js';\nimport {\n  type ApolloServer,\n  type ApolloServerInternals,\n  chooseContentTypeForSingleResultResponse,\n  internalExecuteOperation,\n  MEDIA_TYPES,\n  type SchemaDerivedData,\n} from './ApolloServer.js';\nimport { type FormattedExecutionResult, Kind } from 'graphql';\nimport { BadRequestError } from './internalErrorClasses.js';\nimport Negotiator from 'negotiator';\nimport { HeaderMap } from './utils/HeaderMap.js';\n\nfunction fieldIfString(\n  o: Record<string, unknown>,\n  fieldName: string,\n): string | undefined {\n  const value = o[fieldName];\n  if (typeof value === 'string') {\n    return value;\n  }\n  return undefined;\n}\n\nfunction searchParamIfSpecifiedOnce(\n  searchParams: URLSearchParams,\n  paramName: string,\n) {\n  const values = searchParams.getAll(paramName);\n  switch (values.length) {\n    case 0:\n      return undefined;\n    case 1:\n      return values[0];\n    default:\n      throw new BadRequestError(\n        `The '${paramName}' search parameter may only be specified once.`,\n      );\n  }\n}\n\nfunction jsonParsedSearchParamIfSpecifiedOnce(\n  searchParams: URLSearchParams,\n  fieldName: string,\n): Record<string, unknown> | undefined {\n  const value = searchParamIfSpecifiedOnce(searchParams, fieldName);\n  if (value === undefined) {\n    return undefined;\n  }\n  let hopefullyRecord;\n  try {\n    hopefullyRecord = JSON.parse(value);\n  } catch {\n    throw new BadRequestError(\n      `The ${fieldName} search parameter contains invalid JSON.`,\n    );\n  }\n  if (!isStringRecord(hopefullyRecord)) {\n    throw new BadRequestError(\n      `The ${fieldName} search parameter should contain a JSON-encoded object.`,\n    );\n  }\n  return hopefullyRecord;\n}\n\nfunction fieldIfRecord(\n  o: Record<string, unknown>,\n  fieldName: string,\n): Record<string, unknown> | undefined {\n  const value = o[fieldName];\n  if (isStringRecord(value)) {\n    return value;\n  }\n  return undefined;\n}\n\nfunction isStringRecord(o: unknown): o is Record<string, unknown> {\n  return (\n    !!o && typeof o === 'object' && !Buffer.isBuffer(o) && !Array.isArray(o)\n  );\n}\n\nfunction isNonEmptyStringRecord(o: unknown): o is Record<string, unknown> {\n  return isStringRecord(o) && Object.keys(o).length > 0;\n}\n\nfunction ensureQueryIsStringOrMissing(query: unknown) {\n  if (!query || typeof query === 'string') {\n    return;\n  }\n  // Check for a common error first.\n  if ((query as any).kind === Kind.DOCUMENT) {\n    throw new BadRequestError(\n      \"GraphQL queries must be strings. It looks like you're sending the \" +\n        'internal graphql-js representation of a parsed query in your ' +\n        'request instead of a request in the GraphQL query language. You ' +\n        'can convert an AST to a string using the `print` function from ' +\n        '`graphql`, or use a client like `apollo-client` which converts ' +\n        'the internal representation to a string for you.',\n    );\n  } else {\n    throw new BadRequestError('GraphQL queries must be strings.');\n  }\n}\n\nexport async function runHttpQuery<TContext extends BaseContext>({\n  server,\n  httpRequest,\n  contextValue,\n  schemaDerivedData,\n  internals,\n  sharedResponseHTTPGraphQLHead,\n}: {\n  server: ApolloServer<TContext>;\n  httpRequest: HTTPGraphQLRequest;\n  contextValue: TContext;\n  schemaDerivedData: SchemaDerivedData;\n  internals: ApolloServerInternals<TContext>;\n  sharedResponseHTTPGraphQLHead: HTTPGraphQLHead | null;\n}): Promise<HTTPGraphQLResponse> {\n  let graphQLRequest: GraphQLRequest;\n\n  switch (httpRequest.method) {\n    case 'POST': {\n      if (!isNonEmptyStringRecord(httpRequest.body)) {\n        throw new BadRequestError(\n          'POST body missing, invalid Content-Type, or JSON object has no keys.',\n        );\n      }\n\n      ensureQueryIsStringOrMissing(httpRequest.body.query);\n\n      if (typeof httpRequest.body.variables === 'string') {\n        throw new BadRequestError(\n          '`variables` in a POST body should be provided as an object, not a recursively JSON-encoded string.',\n        );\n      }\n\n      if (typeof httpRequest.body.extensions === 'string') {\n        throw new BadRequestError(\n          '`extensions` in a POST body should be provided as an object, not a recursively JSON-encoded string.',\n        );\n      }\n\n      if (\n        'extensions' in httpRequest.body &&\n        httpRequest.body.extensions !== null &&\n        !isStringRecord(httpRequest.body.extensions)\n      ) {\n        throw new BadRequestError(\n          '`extensions` in a POST body must be an object if provided.',\n        );\n      }\n\n      if (\n        'variables' in httpRequest.body &&\n        httpRequest.body.variables !== null &&\n        !isStringRecord(httpRequest.body.variables)\n      ) {\n        throw new BadRequestError(\n          '`variables` in a POST body must be an object if provided.',\n        );\n      }\n\n      if (\n        'operationName' in httpRequest.body &&\n        httpRequest.body.operationName !== null &&\n        typeof httpRequest.body.operationName !== 'string'\n      ) {\n        throw new BadRequestError(\n          '`operationName` in a POST body must be a string if provided.',\n        );\n      }\n\n      graphQLRequest = {\n        query: fieldIfString(httpRequest.body, 'query'),\n        operationName: fieldIfString(httpRequest.body, 'operationName'),\n        variables: fieldIfRecord(httpRequest.body, 'variables'),\n        extensions: fieldIfRecord(httpRequest.body, 'extensions'),\n        http: httpRequest,\n      };\n\n      break;\n    }\n\n    case 'GET': {\n      const searchParams = new URLSearchParams(httpRequest.search);\n\n      graphQLRequest = {\n        query: searchParamIfSpecifiedOnce(searchParams, 'query'),\n        operationName: searchParamIfSpecifiedOnce(\n          searchParams,\n          'operationName',\n        ),\n        variables: jsonParsedSearchParamIfSpecifiedOnce(\n          searchParams,\n          'variables',\n        ),\n        extensions: jsonParsedSearchParamIfSpecifiedOnce(\n          searchParams,\n          'extensions',\n        ),\n        http: httpRequest,\n      };\n\n      break;\n    }\n    default:\n      throw new BadRequestError(\n        'Apollo Server supports only GET/POST requests.',\n        {\n          extensions: {\n            http: {\n              status: 405,\n              headers: new HeaderMap([['allow', 'GET, POST']]),\n            },\n          },\n        },\n      );\n  }\n\n  const graphQLResponse = await internalExecuteOperation(\n    {\n      server,\n      graphQLRequest,\n      internals,\n      schemaDerivedData,\n      sharedResponseHTTPGraphQLHead,\n    },\n    { contextValue },\n  );\n\n  if (graphQLResponse.body.kind === 'single') {\n    if (!graphQLResponse.http.headers.get('content-type')) {\n      // If we haven't already set the content-type (via a plugin or something),\n      // decide which content-type to use based on the accept header.\n      const contentType = chooseContentTypeForSingleResultResponse(httpRequest);\n      if (contentType === null) {\n        throw new BadRequestError(\n          `An 'accept' header was provided for this request which does not accept ` +\n            `${MEDIA_TYPES.APPLICATION_JSON} or ${MEDIA_TYPES.APPLICATION_GRAPHQL_RESPONSE_JSON}`,\n          // Use 406 Not Accepted\n          { extensions: { http: { status: 406 } } },\n        );\n      }\n      graphQLResponse.http.headers.set('content-type', contentType);\n    }\n\n    return {\n      ...graphQLResponse.http,\n      body: {\n        kind: 'complete',\n        string: await internals.stringifyResult(\n          orderExecutionResultFields(graphQLResponse.body.singleResult),\n        ),\n      },\n    };\n  }\n\n  // Note that incremental delivery is not yet part of the official GraphQL\n  // spec. We are implementing a proposed version of the spec, and require\n  // clients to explicitly state `deferSpec=20220824`. Once incremental delivery\n  // has been added to the GraphQL spec, we will support `accept` headers\n  // without `deferSpec` as well (perhaps with slightly different behavior if\n  // anything has changed).\n  const acceptHeader = httpRequest.headers.get('accept');\n  if (\n    !(\n      acceptHeader &&\n      new Negotiator({\n        headers: { accept: httpRequest.headers.get('accept') },\n      }).mediaType([\n        // mediaType() will return the first one that matches, so if the client\n        // doesn't include the deferSpec parameter it will match this one here,\n        // which isn't good enough.\n        MEDIA_TYPES.MULTIPART_MIXED_NO_DEFER_SPEC,\n        MEDIA_TYPES.MULTIPART_MIXED_EXPERIMENTAL,\n      ]) === MEDIA_TYPES.MULTIPART_MIXED_EXPERIMENTAL\n    )\n  ) {\n    // The client ran an operation that would yield multiple parts, but didn't\n    // specify `accept: multipart/mixed`. We return an error.\n    throw new BadRequestError(\n      'Apollo server received an operation that uses incremental delivery ' +\n        '(@defer or @stream), but the client does not accept multipart/mixed ' +\n        'HTTP responses. To enable incremental delivery support, add the HTTP ' +\n        \"header 'Accept: multipart/mixed; deferSpec=20220824'.\",\n      // Use 406 Not Accepted\n      { extensions: { http: { status: 406 } } },\n    );\n  }\n\n  graphQLResponse.http.headers.set(\n    'content-type',\n    'multipart/mixed; boundary=\"-\"; deferSpec=20220824',\n  );\n  return {\n    ...graphQLResponse.http,\n    body: {\n      kind: 'chunked',\n      asyncIterator: writeMultipartBody(\n        graphQLResponse.body.initialResult,\n        graphQLResponse.body.subsequentResults,\n      ),\n    },\n  };\n}\n\nasync function* writeMultipartBody(\n  initialResult: GraphQLExperimentalFormattedInitialIncrementalExecutionResult,\n  subsequentResults: AsyncIterable<GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult>,\n): AsyncGenerator<string> {\n  // Note: we assume in this function that every result other than the last has\n  // hasNext=true and the last has hasNext=false. That is, we choose which kind\n  // of delimiter to place at the end of each block based on the contents of the\n  // message, not the structure of the async iterator. This makes sense because\n  // we want to write the delimiter as soon as each block is done (so the client\n  // can parse it immediately) but we may not know whether a general async\n  // iterator is finished until we do async work.\n\n  yield `\\r\\n---\\r\\ncontent-type: application/json; charset=utf-8\\r\\n\\r\\n${JSON.stringify(\n    orderInitialIncrementalExecutionResultFields(initialResult),\n  )}\\r\\n---${initialResult.hasNext ? '' : '--'}\\r\\n`;\n\n  for await (const result of subsequentResults) {\n    yield `content-type: application/json; charset=utf-8\\r\\n\\r\\n${JSON.stringify(\n      orderSubsequentIncrementalExecutionResultFields(result),\n    )}\\r\\n---${result.hasNext ? '' : '--'}\\r\\n`;\n  }\n}\n\n// See https://github.com/facebook/graphql/pull/384 for why\n// errors comes first.\nfunction orderExecutionResultFields(\n  result: FormattedExecutionResult,\n): FormattedExecutionResult {\n  return {\n    errors: result.errors,\n    data: result.data,\n    extensions: result.extensions,\n  };\n}\nfunction orderInitialIncrementalExecutionResultFields(\n  result: GraphQLExperimentalFormattedInitialIncrementalExecutionResult,\n): GraphQLExperimentalFormattedInitialIncrementalExecutionResult {\n  return {\n    hasNext: result.hasNext,\n    errors: result.errors,\n    data: result.data,\n    incremental: orderIncrementalResultFields(result.incremental),\n    extensions: result.extensions,\n  };\n}\nfunction orderSubsequentIncrementalExecutionResultFields(\n  result: GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult,\n): GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult {\n  return {\n    hasNext: result.hasNext,\n    incremental: orderIncrementalResultFields(result.incremental),\n    extensions: result.extensions,\n  };\n}\n\nfunction orderIncrementalResultFields(\n  incremental?: readonly GraphQLExperimentalFormattedIncrementalResult[],\n): undefined | GraphQLExperimentalFormattedIncrementalResult[] {\n  return incremental?.map((i: any) => ({\n    hasNext: i.hasNext,\n    errors: i.errors,\n    path: i.path,\n    label: i.label,\n    data: i.data,\n    items: i.items,\n    extensions: i.extensions,\n  }));\n}\n\n// The result of a curl does not appear well in the terminal, so we add an extra new line\nexport function prettyJSONStringify(value: FormattedExecutionResult) {\n  return JSON.stringify(value) + '\\n';\n}\n\nexport function newHTTPGraphQLHead(status?: number): HTTPGraphQLHead {\n  return {\n    status,\n    headers: new HeaderMap(),\n  };\n}\n\n// Updates `target` with status code and headers from `source`. For now let's\n// consider it undefined what happens if both have a status code set or both set\n// the same header.\nexport function mergeHTTPGraphQLHead(\n  target: HTTPGraphQLHead,\n  source: HTTPGraphQLHead,\n) {\n  if (source.status) {\n    target.status = source.status;\n  }\n  if (source.headers) {\n    for (const [name, value] of source.headers) {\n      // If source.headers contains non-lowercase header names, this will\n      // catch that case as long as target.headers is a HeaderMap.\n      target.headers.set(name, value);\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2701, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2706, "column": 0}, "map": {"version":3,"file":"errorNormalize.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/errorNormalize.ts"],"sourcesContent":["// The functions in this file are not part of Apollo Server's external API.\n\nimport {\n  GraphQLError,\n  type GraphQLErrorExtensions,\n  type GraphQLFormattedError,\n} from 'graphql';\nimport { ApolloServerErrorCode } from './errors/index.js';\nimport type { HTTPGraphQLHead } from './externalTypes/http.js';\nimport { mergeHTTPGraphQLHead, newHTTPGraphQLHead } from './runHttpQuery.js';\nimport { HeaderMap } from './utils/HeaderMap.js';\n\n// This function accepts any value that were thrown and convert it to GraphQLFormattedError.\n// It also add default extensions.code and copy stack trace onto an extension if requested.\n// Additionally, it returns an `HTTPGraphQLHead` created from combining the values of any\n// `HTTPGraphqlHead` objects found on `extensions.http` (the behavior when multiple errors\n// set a status code or set the same header should be treated as undefined); these extensions\n// are removed from the formatted error.\n//\n// This function should not throw.\nexport function normalizeAndFormatErrors(\n  errors: ReadonlyArray<unknown>,\n  options: {\n    formatError?: (\n      formattedError: GraphQLFormattedError,\n      error: unknown,\n    ) => GraphQLFormattedError;\n    includeStacktraceInErrorResponses?: boolean;\n  } = {},\n): {\n  formattedErrors: Array<GraphQLFormattedError>;\n  httpFromErrors: HTTPGraphQLHead;\n} {\n  const formatError = options.formatError ?? ((error) => error);\n  const httpFromErrors = newHTTPGraphQLHead();\n\n  return {\n    httpFromErrors,\n    formattedErrors: errors.map((error) => {\n      try {\n        return formatError(enrichError(error), error);\n      } catch (formattingError) {\n        if (options.includeStacktraceInErrorResponses) {\n          // includeStacktraceInErrorResponses is used in development\n          // so it will be helpful to show errors thrown by formatError hooks in that mode\n          return enrichError(formattingError);\n        } else {\n          // obscure error\n          return {\n            message: 'Internal server error',\n            extensions: { code: ApolloServerErrorCode.INTERNAL_SERVER_ERROR },\n          };\n        }\n      }\n    }),\n  };\n\n  function enrichError(maybeError: unknown): GraphQLFormattedError {\n    const graphqlError = ensureGraphQLError(maybeError);\n\n    const extensions: GraphQLErrorExtensions = {\n      ...graphqlError.extensions,\n      code:\n        graphqlError.extensions.code ??\n        ApolloServerErrorCode.INTERNAL_SERVER_ERROR,\n    };\n\n    if (isPartialHTTPGraphQLHead(extensions.http)) {\n      mergeHTTPGraphQLHead(httpFromErrors, {\n        headers: new HeaderMap(),\n        ...extensions.http,\n      });\n      delete extensions.http;\n    }\n\n    if (options.includeStacktraceInErrorResponses) {\n      // Note that if ensureGraphQLError created graphqlError from an\n      // originalError, graphqlError.stack will be the same as\n      // originalError.stack due to some special code in the GraphQLError\n      // constructor.\n      extensions.stacktrace = graphqlError.stack?.split('\\n');\n    }\n\n    return { ...graphqlError.toJSON(), extensions };\n  }\n}\n\nexport function ensureError(maybeError: unknown): Error {\n  return maybeError instanceof Error\n    ? maybeError\n    : new GraphQLError('Unexpected error value: ' + String(maybeError));\n}\n\nexport function ensureGraphQLError(\n  maybeError: unknown,\n  messagePrefixIfNotGraphQLError: string = '',\n): GraphQLError {\n  const error: Error = ensureError(maybeError);\n\n  return error instanceof GraphQLError\n    ? error\n    : new GraphQLError(messagePrefixIfNotGraphQLError + error.message, {\n        originalError: error,\n      });\n}\n\nfunction isPartialHTTPGraphQLHead(x: unknown): x is Partial<HTTPGraphQLHead> {\n  return (\n    !!x &&\n    typeof x === 'object' &&\n    (!('status' in x) || typeof (x as any).status === 'number') &&\n    (!('headers' in x) || (x as any).headers instanceof Map)\n  );\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2775, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2780, "column": 0}, "map": {"version":3,"file":"httpBatching.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/httpBatching.ts"],"sourcesContent":["import type {\n  BaseContext,\n  HTTPGraphQLRequest,\n  HTTPGraphQLResponse,\n} from './externalTypes/index.js';\nimport type {\n  ApolloServer,\n  ApolloServerInternals,\n  SchemaDerivedData,\n} from './ApolloServer';\nimport { newHTTPGraphQLHead, runHttpQuery } from './runHttpQuery.js';\nimport { BadRequestError } from './internalErrorClasses.js';\n\nasync function runBatchedHttpQuery<TContext extends BaseContext>({\n  server,\n  batchRequest,\n  body,\n  contextValue,\n  schemaDerivedData,\n  internals,\n}: {\n  server: ApolloServer<TContext>;\n  batchRequest: HTTPGraphQLRequest;\n  body: unknown[];\n  contextValue: TContext;\n  schemaDerivedData: SchemaDerivedData;\n  internals: ApolloServerInternals<TContext>;\n}): Promise<HTTPGraphQLResponse> {\n  if (body.length === 0) {\n    throw new BadRequestError('No operations found in request.');\n  }\n\n  // This single HTTPGraphQLHead is shared across all the operations in the\n  // batch. This means that any changes to response headers or status code from\n  // one operation can be immediately seen by other operations. Plugins that set\n  // response headers or status code can then choose to combine the data they\n  // are setting with data that may already be there from another operation as\n  // they choose.\n  const sharedResponseHTTPGraphQLHead = newHTTPGraphQLHead();\n  const responseBodies = await Promise.all(\n    body.map(async (bodyPiece: unknown) => {\n      const singleRequest: HTTPGraphQLRequest = {\n        ...batchRequest,\n        body: bodyPiece,\n      };\n\n      const response = await runHttpQuery({\n        server,\n        httpRequest: singleRequest,\n        contextValue,\n        schemaDerivedData,\n        internals,\n        sharedResponseHTTPGraphQLHead,\n      });\n\n      if (response.body.kind === 'chunked') {\n        throw Error(\n          'Incremental delivery is not implemented for batch requests',\n        );\n      }\n      return response.body.string;\n    }),\n  );\n  return {\n    ...sharedResponseHTTPGraphQLHead,\n    body: { kind: 'complete', string: `[${responseBodies.join(',')}]` },\n  };\n}\n\nexport async function runPotentiallyBatchedHttpQuery<\n  TContext extends BaseContext,\n>(\n  server: ApolloServer<TContext>,\n  httpGraphQLRequest: HTTPGraphQLRequest,\n  contextValue: TContext,\n  schemaDerivedData: SchemaDerivedData,\n  internals: ApolloServerInternals<TContext>,\n): Promise<HTTPGraphQLResponse> {\n  if (\n    !(\n      httpGraphQLRequest.method === 'POST' &&\n      Array.isArray(httpGraphQLRequest.body)\n    )\n  ) {\n    return await runHttpQuery({\n      server,\n      httpRequest: httpGraphQLRequest,\n      contextValue,\n      schemaDerivedData,\n      internals,\n      sharedResponseHTTPGraphQLHead: null,\n    });\n  }\n  if (internals.allowBatchedHttpRequests) {\n    return await runBatchedHttpQuery({\n      server,\n      batchRequest: httpGraphQLRequest,\n      body: httpGraphQLRequest.body as unknown[],\n      contextValue,\n      schemaDerivedData,\n      internals,\n    });\n  }\n  throw new BadRequestError('Operation batching disabled.');\n}\n"],"names":[],"mappings":";;;;;AAUA,MAAA,iDAAqE;AACrE,MAAA,iEAA4D;AAE5D,KAAK,UAAU,mBAAmB,CAA+B,EAC/D,MAAM,EACN,YAAY,EACZ,IAAI,EACJ,YAAY,EACZ,iBAAiB,EACjB,SAAS,EAQV;IACC,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACtB,MAAM,IAAI,0BAAA,eAAe,CAAC,iCAAiC,CAAC,CAAC;IAC/D,CAAC;IAQD,MAAM,6BAA6B,GAAG,CAAA,GAAA,kBAAA,kBAAkB,GAAE,CAAC;IAC3D,MAAM,cAAc,GAAG,MAAM,OAAO,CAAC,GAAG,CACtC,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,SAAkB,EAAE,EAAE;QACpC,MAAM,aAAa,GAAuB;YACxC,GAAG,YAAY;YACf,IAAI,EAAE,SAAS;SAChB,CAAC;QAEF,MAAM,QAAQ,GAAG,MAAM,CAAA,GAAA,kBAAA,YAAY,EAAC;YAClC,MAAM;YACN,WAAW,EAAE,aAAa;YAC1B,YAAY;YACZ,iBAAiB;YACjB,SAAS;YACT,6BAA6B;SAC9B,CAAC,CAAC;QAEH,IAAI,QAAQ,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,EAAE,CAAC;YACrC,MAAM,KAAK,CACT,4DAA4D,CAC7D,CAAC;QACJ,CAAC;QACD,OAAO,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC;IAC9B,CAAC,CAAC,CACH,CAAC;IACF,OAAO;QACL,GAAG,6BAA6B;QAChC,IAAI,EAAE;YAAE,IAAI,EAAE,UAAU;YAAE,MAAM,EAAE,CAAA,CAAA,EAAI,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA,CAAA,CAAG;QAAA,CAAE;KACpE,CAAC;AACJ,CAAC;AAEM,KAAK,UAAU,8BAA8B,CAGlD,MAA8B,EAC9B,kBAAsC,EACtC,YAAsB,EACtB,iBAAoC,EACpC,SAA0C;IAE1C,IACE,CAAC,CACC,kBAAkB,CAAC,MAAM,KAAK,MAAM,IACpC,KAAK,CAAC,OAAO,CAAC,kBAAkB,CAAC,IAAI,CAAC,CACvC,EACD,CAAC;QACD,OAAO,MAAM,CAAA,GAAA,kBAAA,YAAY,EAAC;YACxB,MAAM;YACN,WAAW,EAAE,kBAAkB;YAC/B,YAAY;YACZ,iBAAiB;YACjB,SAAS;YACT,6BAA6B,EAAE,IAAI;SACpC,CAAC,CAAC;IACL,CAAC;IACD,IAAI,SAAS,CAAC,wBAAwB,EAAE,CAAC;QACvC,OAAO,MAAM,mBAAmB,CAAC;YAC/B,MAAM;YACN,YAAY,EAAE,kBAAkB;YAChC,IAAI,EAAE,kBAAkB,CAAC,IAAiB;YAC1C,YAAY;YACZ,iBAAiB;YACjB,SAAS;SACV,CAAC,CAAC;IACL,CAAC;IACD,MAAM,IAAI,0BAAA,eAAe,CAAC,8BAA8B,CAAC,CAAC;AAC5D,CAAC;AAnCD,QAAA,8BAAA,GAAA,+BAmCC","ignoreList":[0]}},
    {"offset": {"line": 2842, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2847, "column": 0}, "map": {"version":3,"file":"internalPlugin.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/internalPlugin.ts"],"sourcesContent":["import type { BaseContext, ApolloServerPlugin } from './externalTypes/index.js';\n\n// This file's exports should not be exported from the overall\n// @apollo/server module.\n\n// The internal plugins implement this interface which\n// ApolloServer.ensurePluginInstantiation uses to figure out if the plugins have\n// already been installed (or explicitly disabled via the matching Disable\n// plugins).\nexport interface InternalApolloServerPlugin<TContext extends BaseContext>\n  extends ApolloServerPlugin<TContext> {\n  // Used to identify a few specific plugins that are instantiated\n  // by default if not explicitly used or disabled.\n  __internal_plugin_id__: InternalPluginId;\n  __is_disabled_plugin__: boolean;\n}\n\n// Helper function for writing internal plugins which lets you write an object\n// that is type-checked as InternalApolloServerPlugin but is still only of type\n// ApolloServerPlugin (as appropriate for externally-exported plugin-returning\n// functions).\nexport function internalPlugin<TContext extends BaseContext>(\n  p: InternalApolloServerPlugin<TContext>,\n): ApolloServerPlugin<TContext> {\n  return p;\n}\n\nexport type InternalPluginId =\n  | 'CacheControl'\n  | 'LandingPageDisabled'\n  | 'SchemaReporting'\n  | 'InlineTrace'\n  | 'UsageReporting'\n  | 'DisableSuggestions';\n\nexport function pluginIsInternal<TContext extends BaseContext>(\n  plugin: ApolloServerPlugin<TContext>,\n): plugin is InternalApolloServerPlugin<TContext> {\n  // We could call the function and compare it to the list above, but this seems\n  // good enough.\n  return '__internal_plugin_id__' in plugin;\n}\n"],"names":[],"mappings":";;;;;AAqBA,SAAgB,cAAc,CAC5B,CAAuC;IAEvC,OAAO,CAAC,CAAC;AACX,CAAC;AAJD,QAAA,cAAA,GAAA,eAIC;AAUD,SAAgB,gBAAgB,CAC9B,MAAoC;IAIpC,OAAO,wBAAwB,IAAI,MAAM,CAAC;AAC5C,CAAC;AAND,QAAA,gBAAA,GAAA,iBAMC","ignoreList":[0]}},
    {"offset": {"line": 2860, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2865, "column": 0}, "map": {"version":3,"file":"preventCsrf.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/preventCsrf.ts"],"sourcesContent":["import MIMEType from 'whatwg-mimetype';\nimport { BadRequestError } from './internalErrorClasses.js';\nimport type { HeaderMap } from './utils/HeaderMap.js';\n\n// Our recommended set of CSRF prevention headers. Operations that do not\n// provide a content-type such as `application/json` (in practice, this\n// means GET operations) must include at least one of these headers.\n// Apollo Client Web's default behavior is to always sends a\n// `content-type` even for `GET`, and Apollo iOS and Apollo Kotlin always\n// send `x-apollo-operation-name`. So if you set\n// `csrfPreventionRequestHeaders: true` then any `GET` operation from these\n// three client projects and any `POST` operation at all should work\n// successfully; if you need `GET`s from another kind of client to work,\n// just add `apollo-require-preflight: true` to their requests.\nexport const recommendedCsrfPreventionRequestHeaders = [\n  'x-apollo-operation-name',\n  'apollo-require-preflight',\n];\n\n// See https://fetch.spec.whatwg.org/#cors-safelisted-request-header\nconst NON_PREFLIGHTED_CONTENT_TYPES = [\n  'application/x-www-form-urlencoded',\n  'multipart/form-data',\n  'text/plain',\n];\n\n// We don't want random websites to be able to execute actual GraphQL operations\n// from a user's browser unless our CORS policy supports it. It's not good\n// enough just to ensure that the browser can't read the response from the\n// operation; we also want to prevent CSRF, where the attacker can cause side\n// effects with an operation or can measure the timing of a read operation. Our\n// goal is to ensure that we don't run the context function or execute the\n// GraphQL operation until the browser has evaluated the CORS policy, which\n// means we want all operations to be pre-flighted. We can do that by only\n// processing operations that have at least one header set that appears to be\n// manually set by the JS code rather than by the browser automatically.\n//\n// POST requests generally have a content-type `application/json`, which is\n// sufficient to trigger preflighting. So we take extra care with requests that\n// specify no content-type or that specify one of the three non-preflighted\n// content types. For those operations, we require (if this feature is enabled)\n// one of a set of specific headers to be set. By ensuring that every operation\n// either has a custom content-type or sets one of these headers, we know we\n// won't execute operations at the request of origins who our CORS policy will\n// block.\nexport function preventCsrf(\n  headers: HeaderMap,\n  csrfPreventionRequestHeaders: string[],\n) {\n  const contentType = headers.get('content-type');\n\n  // We have to worry about CSRF if it looks like this may have been a\n  // non-preflighted request. If we see a content-type header that is not one of\n  // the three CORS-safelisted MIME types (see\n  // https://fetch.spec.whatwg.org/#cors-safelisted-request-header) then we know\n  // it was preflighted and we don't have to worry.\n  if (contentType !== undefined) {\n    const contentTypeParsed = MIMEType.parse(contentType);\n    if (contentTypeParsed === null) {\n      // If we got null, then parsing the content-type failed... which is\n      // actually *ok* because that would lead to a preflight. (For example, the\n      // header is empty, or doesn't have a slash, or has bad characters.) The\n      // scary CSRF case is only if there's *not* an error. So it is actually\n      // fine for us to just `return` here. (That said, it would also be\n      // reasonable to reject such requests with provided yet unparsable\n      // Content-Type here.)\n      return;\n    }\n    if (!NON_PREFLIGHTED_CONTENT_TYPES.includes(contentTypeParsed.essence)) {\n      // We managed to parse a MIME type that was not one of the\n      // CORS-safelisted ones. (Probably application/json!) That means that if\n      // the client is a browser, the browser must have applied CORS\n      // preflighting and we don't have to worry about CSRF.\n      return;\n    }\n  }\n\n  // Either there was no content-type, or the content-type parsed properly as\n  // one of the three CORS-safelisted values. Let's look for another header that\n  // (if this was a browser) must have been set by the user's code and would\n  // have caused a preflight.\n  if (\n    csrfPreventionRequestHeaders.some((header) => {\n      const value = headers.get(header);\n      return value !== undefined && value.length > 0;\n    })\n  ) {\n    return;\n  }\n\n  throw new BadRequestError(\n    `This operation has been blocked as a potential Cross-Site Request Forgery ` +\n      `(CSRF). Please either specify a 'content-type' header (with a type that ` +\n      `is not one of ${NON_PREFLIGHTED_CONTENT_TYPES.join(', ')}) or provide ` +\n      `a non-empty value for one of the following headers: ${csrfPreventionRequestHeaders.join(\n        ', ',\n      )}\\n`,\n  );\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA,MAAA,oBAAA,4CAAuC;AACvC,MAAA,iEAA4D;AAa/C,QAAA,uCAAuC,GAAG;IACrD,yBAAyB;IACzB,0BAA0B;CAC3B,CAAC;AAGF,MAAM,6BAA6B,GAAG;IACpC,mCAAmC;IACnC,qBAAqB;IACrB,YAAY;CACb,CAAC;AAqBF,SAAgB,WAAW,CACzB,OAAkB,EAClB,4BAAsC;IAEtC,MAAM,WAAW,GAAG,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;IAOhD,IAAI,WAAW,KAAK,SAAS,EAAE,CAAC;QAC9B,MAAM,iBAAiB,GAAG,kBAAA,OAAQ,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;QACtD,IAAI,iBAAiB,KAAK,IAAI,EAAE,CAAC;YAQ/B,OAAO;QACT,CAAC;QACD,IAAI,CAAC,6BAA6B,CAAC,QAAQ,CAAC,iBAAiB,CAAC,OAAO,CAAC,EAAE,CAAC;YAKvE,OAAO;QACT,CAAC;IACH,CAAC;IAMD,IACE,4BAA4B,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,EAAE;QAC3C,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAClC,OAAO,KAAK,KAAK,SAAS,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;IACjD,CAAC,CAAC,EACF,CAAC;QACD,OAAO;IACT,CAAC;IAED,MAAM,IAAI,0BAAA,eAAe,CACvB,CAAA,0EAAA,CAA4E,GAC1E,CAAA,wEAAA,CAA0E,GAC1E,CAAA,cAAA,EAAiB,6BAA6B,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA,aAAA,CAAe,GACxE,CAAA,oDAAA,EAAuD,4BAA4B,CAAC,IAAI,CACtF,IAAI,CACL,CAAA,EAAA,CAAI,CACR,CAAC;AACJ,CAAC;AArDD,QAAA,WAAA,GAAA,YAqDC","ignoreList":[0]}},
    {"offset": {"line": 2906, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2911, "column": 0}, "map": {"version":3,"file":"schemaInstrumentation.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/utils/schemaInstrumentation.ts"],"sourcesContent":["import {\n  type GraphQLSchema,\n  type GraphQLField,\n  getNamedType,\n  GraphQLObjectType,\n  type GraphQLFieldResolver,\n  defaultFieldResolver,\n} from 'graphql';\nimport type {\n  BaseContext,\n  GraphQLRequestExecutionListener,\n} from '../externalTypes/index.js';\n\nexport const symbolExecutionDispatcherWillResolveField = Symbol(\n  'apolloServerExecutionDispatcherWillResolveField',\n);\nexport const symbolUserFieldResolver = Symbol('apolloServerUserFieldResolver');\nconst symbolPluginsEnabled = Symbol('apolloServerPluginsEnabled');\n\nexport function enablePluginsForSchemaResolvers<TContext extends BaseContext>(\n  schema: GraphQLSchema & { [symbolPluginsEnabled]?: boolean },\n) {\n  if (pluginsEnabledForSchemaResolvers(schema)) {\n    return schema;\n  }\n  Object.defineProperty(schema, symbolPluginsEnabled, {\n    value: true,\n  });\n\n  const typeMap = schema.getTypeMap();\n  Object.values(typeMap).forEach((type) => {\n    if (\n      !getNamedType(type).name.startsWith('__') &&\n      type instanceof GraphQLObjectType\n    ) {\n      const fields = type.getFields();\n      Object.values(fields).forEach((field) => {\n        wrapField<TContext>(field);\n      });\n    }\n  });\n\n  return schema;\n}\n\nexport function pluginsEnabledForSchemaResolvers(\n  schema: GraphQLSchema & { [symbolPluginsEnabled]?: boolean },\n): boolean {\n  return !!schema[symbolPluginsEnabled];\n}\n\nfunction wrapField<TContext extends BaseContext>(\n  field: GraphQLField<any, any>,\n): void {\n  const originalFieldResolve = field.resolve;\n\n  field.resolve = (source, args, contextValue, info) => {\n    const willResolveField = contextValue?.[\n      symbolExecutionDispatcherWillResolveField\n    ] as\n      | GraphQLRequestExecutionListener<TContext>['willResolveField']\n      | undefined;\n\n    const userFieldResolver = contextValue?.[symbolUserFieldResolver] as\n      | GraphQLFieldResolver<any, any>\n      | undefined;\n\n    // The technique for implementing a  \"did resolve field\" is accomplished by\n    // returning a function from the `willResolveField` handler.  While there\n    // may be several callbacks, depending on the number of plugins which have\n    // implemented a `willResolveField` hook, this hook will call them all\n    // as dictated by the dispatcher.  We will call this when object\n    // resolution is complete.\n    const didResolveField =\n      typeof willResolveField === 'function' &&\n      willResolveField({ source, args, contextValue, info });\n\n    const fieldResolver =\n      originalFieldResolve || userFieldResolver || defaultFieldResolver;\n\n    try {\n      const result = fieldResolver(source, args, contextValue, info);\n\n      // Call the stack's handlers either immediately (if result is not a\n      // Promise) or once the Promise is done. Then return that same\n      // maybe-Promise value.\n      if (typeof didResolveField === 'function') {\n        whenResultIsFinished(result, didResolveField);\n      }\n      return result;\n    } catch (error) {\n      // Normally it's a bad sign to see an error both handled and\n      // re-thrown. But it is useful to allow extensions to track errors while\n      // still handling them in the normal GraphQL way.\n      if (typeof didResolveField === 'function') {\n        didResolveField(error as Error);\n      }\n      throw error;\n    }\n  };\n}\n\nfunction isPromise(x: any): boolean {\n  return x && typeof x.then === 'function';\n}\n\n// Given result (which may be a Promise or an array some of whose elements are\n// promises) Promises, set up 'callback' to be invoked when result is fully\n// resolved. (Unfortunately, this does not perfectly handle every possible\n// return value shape, such as arrays of arrays of Promises.)\nexport function whenResultIsFinished(\n  result: any,\n  callback: (err: Error | null, result?: any) => void,\n) {\n  if (isPromise(result)) {\n    result.then(\n      (r: any) => whenResultIsFinished(r, callback),\n      (err: Error) => callback(err),\n    );\n  } else if (Array.isArray(result)) {\n    if (result.some(isPromise)) {\n      Promise.all(result).then(\n        (r: any) => callback(null, r),\n        (err: Error) => callback(err),\n      );\n    } else {\n      callback(null, result);\n    }\n  } else {\n    callback(null, result);\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA,+BAOiB;AAMJ,QAAA,yCAAyC,GAAG,MAAM,CAC7D,iDAAiD,CAClD,CAAC;AACW,QAAA,uBAAuB,GAAG,MAAM,CAAC,+BAA+B,CAAC,CAAC;AAC/E,MAAM,oBAAoB,GAAG,MAAM,CAAC,4BAA4B,CAAC,CAAC;AAElE,SAAgB,+BAA+B,CAC7C,MAA4D;IAE5D,IAAI,gCAAgC,CAAC,MAAM,CAAC,EAAE,CAAC;QAC7C,OAAO,MAAM,CAAC;IAChB,CAAC;IACD,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,oBAAoB,EAAE;QAClD,KAAK,EAAE,IAAI;KACZ,CAAC,CAAC;IAEH,MAAM,OAAO,GAAG,MAAM,CAAC,UAAU,EAAE,CAAC;IACpC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QACtC,IACE,CAAC,CAAA,GAAA,UAAA,YAAY,EAAC,IAAI,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IACzC,IAAI,YAAY,UAAA,iBAAiB,EACjC,CAAC;YACD,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;YAChC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;gBACtC,SAAS,CAAW,KAAK,CAAC,CAAC;YAC7B,CAAC,CAAC,CAAC;QACL,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,OAAO,MAAM,CAAC;AAChB,CAAC;AAxBD,QAAA,+BAAA,GAAA,gCAwBC;AAED,SAAgB,gCAAgC,CAC9C,MAA4D;IAE5D,OAAO,CAAC,CAAC,MAAM,CAAC,oBAAoB,CAAC,CAAC;AACxC,CAAC;AAJD,QAAA,gCAAA,GAAA,iCAIC;AAED,SAAS,SAAS,CAChB,KAA6B;IAE7B,MAAM,oBAAoB,GAAG,KAAK,CAAC,OAAO,CAAC;IAE3C,KAAK,CAAC,OAAO,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE,YAAY,EAAE,IAAI,EAAE,EAAE;QACnD,MAAM,gBAAgB,GAAG,YAAY,EAAE,CACrC,QAAA,yCAAyC,CAG9B,CAAC;QAEd,MAAM,iBAAiB,GAAG,YAAY,EAAE,CAAC,QAAA,uBAAuB,CAEnD,CAAC;QAQd,MAAM,eAAe,GACnB,OAAO,gBAAgB,KAAK,UAAU,IACtC,gBAAgB,CAAC;YAAE,MAAM;YAAE,IAAI;YAAE,YAAY;YAAE,IAAI;QAAA,CAAE,CAAC,CAAC;QAEzD,MAAM,aAAa,GACjB,oBAAoB,IAAI,iBAAiB,IAAI,UAAA,oBAAoB,CAAC;QAEpE,IAAI,CAAC;YACH,MAAM,MAAM,GAAG,aAAa,CAAC,MAAM,EAAE,IAAI,EAAE,YAAY,EAAE,IAAI,CAAC,CAAC;YAK/D,IAAI,OAAO,eAAe,KAAK,UAAU,EAAE,CAAC;gBAC1C,oBAAoB,CAAC,MAAM,EAAE,eAAe,CAAC,CAAC;YAChD,CAAC;YACD,OAAO,MAAM,CAAC;QAChB,CAAC,CAAC,OAAO,KAAK,EAAE,CAAC;YAIf,IAAI,OAAO,eAAe,KAAK,UAAU,EAAE,CAAC;gBAC1C,eAAe,CAAC,KAAc,CAAC,CAAC;YAClC,CAAC;YACD,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC,CAAC;AACJ,CAAC;AAED,SAAS,SAAS,CAAC,CAAM;IACvB,OAAO,CAAC,IAAI,OAAO,CAAC,CAAC,IAAI,KAAK,UAAU,CAAC;AAC3C,CAAC;AAMD,SAAgB,oBAAoB,CAClC,MAAW,EACX,QAAmD;IAEnD,IAAI,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC;QACtB,MAAM,CAAC,IAAI,CACT,CAAC,CAAM,EAAE,CAAG,CAAD,mBAAqB,CAAC,CAAC,EAAE,QAAQ,CAAC,EAC7C,CAAC,GAAU,EAAE,CAAG,CAAD,OAAS,CAAC,GAAG,CAAC,CAC9B,CAAC;IACJ,CAAC,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC;QACjC,IAAI,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC;YAC3B,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,IAAI,CACtB,CAAC,CAAM,EAAE,CAAG,CAAD,OAAS,CAAC,IAAI,EAAE,CAAC,CAAC,EAC7B,CAAC,GAAU,EAAE,CAAG,CAAD,OAAS,CAAC,GAAG,CAAC,CAC9B,CAAC;QACJ,CAAC,MAAM,CAAC;YACN,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;QACzB,CAAC;IACH,CAAC,MAAM,CAAC;QACN,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;IACzB,CAAC;AACH,CAAC;AArBD,QAAA,oBAAA,GAAA,qBAqBC","ignoreList":[0]}},
    {"offset": {"line": 2986, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2991, "column": 0}, "map": {"version":3,"file":"isDefined.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/utils/isDefined.ts"],"sourcesContent":["export function isDefined<T>(t: T | undefined | null | void): t is T {\n  return t != null;\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAgB,SAAS,CAAI,CAA8B;IACzD,OAAO,CAAC,IAAI,IAAI,CAAC;AACnB,CAAC;AAFD,QAAA,SAAA,GAAA,UAEC","ignoreList":[0]}},
    {"offset": {"line": 3000, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3005, "column": 0}, "map": {"version":3,"file":"invokeHooks.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/utils/invokeHooks.ts"],"sourcesContent":["import { isDefined } from './isDefined.js';\n\ntype AsyncDidEndHook<TArgs extends any[]> = (...args: TArgs) => Promise<void>;\ntype SyncDidEndHook<TArgs extends any[]> = (...args: TArgs) => void;\n\nexport async function invokeDidStartHook<T, TEndHookArgs extends unknown[]>(\n  targets: T[],\n  hook: (t: T) => Promise<AsyncDidEndHook<TEndHookArgs> | undefined | void>,\n): Promise<AsyncDidEndHook<TEndHookArgs>> {\n  const didEndHooks = (\n    await Promise.all(targets.map((target) => hook(target)))\n  ).filter(isDefined);\n\n  didEndHooks.reverse();\n\n  return async (...args: TEndHookArgs) => {\n    for (const didEndHook of didEndHooks) {\n      didEndHook(...args);\n    }\n  };\n}\n\n// Almost all hooks are async, but as a special case, willResolveField is sync\n// due to performance concerns.\nexport function invokeSyncDidStartHook<T, TEndHookArgs extends unknown[]>(\n  targets: T[],\n  hook: (t: T) => SyncDidEndHook<TEndHookArgs> | undefined | void,\n): SyncDidEndHook<TEndHookArgs> {\n  const didEndHooks: SyncDidEndHook<TEndHookArgs>[] = targets\n    .map((target) => hook(target))\n    .filter(isDefined);\n\n  didEndHooks.reverse();\n\n  return (...args: TEndHookArgs) => {\n    for (const didEndHook of didEndHooks) {\n      didEndHook(...args);\n    }\n  };\n}\n\nexport async function invokeHooksUntilDefinedAndNonNull<T, TOut>(\n  targets: T[],\n  hook: (t: T) => Promise<TOut | null | undefined>,\n): Promise<TOut | null> {\n  for (const target of targets) {\n    const value = await hook(target);\n    if (value != null) {\n      return value;\n    }\n  }\n  return null;\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA,2CAA2C;AAKpC,KAAK,UAAU,kBAAkB,CACtC,OAAY,EACZ,IAAyE;IAEzE,MAAM,WAAW,GAAG,CAClB,MAAM,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAG,CAAD,GAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CACzD,CAAC,MAAM,CAAC,eAAA,SAAS,CAAC,CAAC;IAEpB,WAAW,CAAC,OAAO,EAAE,CAAC;IAEtB,OAAO,KAAK,EAAE,GAAG,IAAkB,EAAE,EAAE;QACrC,KAAK,MAAM,UAAU,IAAI,WAAW,CAAE,CAAC;YACrC,UAAU,CAAC,GAAG,IAAI,CAAC,CAAC;QACtB,CAAC;IACH,CAAC,CAAC;AACJ,CAAC;AAfD,QAAA,kBAAA,GAAA,mBAeC;AAID,SAAgB,sBAAsB,CACpC,OAAY,EACZ,IAA+D;IAE/D,MAAM,WAAW,GAAmC,OAAO,CACxD,GAAG,CAAC,CAAC,MAAM,EAAE,CAAG,CAAD,GAAK,CAAC,MAAM,CAAC,CAAC,CAC7B,MAAM,CAAC,eAAA,SAAS,CAAC,CAAC;IAErB,WAAW,CAAC,OAAO,EAAE,CAAC;IAEtB,OAAO,CAAC,GAAG,IAAkB,EAAE,EAAE;QAC/B,KAAK,MAAM,UAAU,IAAI,WAAW,CAAE,CAAC;YACrC,UAAU,CAAC,GAAG,IAAI,CAAC,CAAC;QACtB,CAAC;IACH,CAAC,CAAC;AACJ,CAAC;AAfD,QAAA,sBAAA,GAAA,uBAeC;AAEM,KAAK,UAAU,iCAAiC,CACrD,OAAY,EACZ,IAAgD;IAEhD,KAAK,MAAM,MAAM,IAAI,OAAO,CAAE,CAAC;QAC7B,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,CAAC;QACjC,IAAI,KAAK,IAAI,IAAI,EAAE,CAAC;YAClB,OAAO,KAAK,CAAC;QACf,CAAC;IACH,CAAC;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAXD,QAAA,iCAAA,GAAA,kCAWC","ignoreList":[0]}},
    {"offset": {"line": 3041, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3046, "column": 0}, "map": {"version":3,"file":"makeGatewayGraphQLRequestContext.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/utils/makeGatewayGraphQLRequestContext.ts"],"sourcesContent":["import type {\n  GatewayGraphQLRequest,\n  GatewayGraphQLRequestContext,\n  GatewayGraphQLResponse,\n  GatewaySchemaHash,\n} from '@apollo/server-gateway-interface';\nimport type { FetcherHeaders } from '@apollo/utils.fetcher';\nimport type { ApolloServer, ApolloServerInternals } from '../ApolloServer';\nimport type {\n  BaseContext,\n  GraphQLRequestContextExecutionDidStart,\n} from '../externalTypes';\nimport type { HeaderMap } from './HeaderMap';\n\n// Apollo Gateway's API included `GraphQLRequestContext` from AS2/AS3.\n// Specifically, a request context is passed to the main executor method, which\n// it then exposes to user-configurable `GraphQLDataSource`s.\n// `GraphQLRequestContext` has changed in incompatible ways in AS4; for example,\n// we represent HTTP messages using our own data structures rather than Fetches,\n// and some fields have been removed because they relate to features that don't\n// exist any more.\n//\n// In general, the future of Apollo's development is in Apollo Router, not\n// Gateway. So rather than have a big transition where a new version of Gateway\n// supports AS4's GraphQLRequestContext instead of AS3's, we simply teach AS4\n// how to produce AS3-style GraphQLRequestContext objects specifically for use\n// by Gateway. We have changed Gateway to get its TS type definitions from a new\n// package rather than from AS3 itself, so that Gateway no longer needs to\n// depend on Apollo Server.\n//\n// This function turn an AS4 GraphQLRequestContext into a\n// GatewayGraphQLRequestContext (which is basically an AS3\n// GraphQLRequestContext).\n//\n// You might think that *after* invoking the executor, we would then need to\n// propagate any changes made by the gateway back onto the \"real\"\n// GraphQLRequestContext. It turns out that for each bit of data on the request\n// context, this is either unnecessary or impossible. (We don't need to support\n// use cases where people break type safe, eg by changing the values of readonly\n// fields.) Here's why:\n//\n// Many fields on GatewayGraphQLRequestContext are declared readonly and their\n// values are taken directly from the real GraphQLRequestContext. This means\n// that gateways should not change the field's value, and any mutations of the\n// object stored in the field (say, calling\n// `requestContext.overallCachePolicy.restrict`, as RemoteGraphQLDataSource\n// does) already take effect.\n//\n//  The only two fields not declared as readonly are `logger` and `debug`.\n//\n// Technically, a gateway implementation could set `requestContext.logger` to a\n// different Logger without breaking the TypeScript declarations. In AS4 we\n// don't actually have a requestContext.logger; we have `readonly\n// requestContext.server` and `readonly server.logger`. So there's not an easy\n// way for us to carry out this change: AS4 just doesn't let gateway or plugins\n// override the server's logger (and generally doesn't allow the logger to\n// change after the server is created), which seems like a simpler model. If it\n// turns out there is a real use case for the gateway to be able to change the\n// overall logger for the request as seen by plugins, we can fix that later.\n//\n// Similarly, it's not clear what the intended use case of mutating `debug` in\n// gateway would be. `debug` has now mostly changed into\n// `includeStacktraceInErrorResponses`. So perhaps this could be used to let you\n// decide whether or not to include the stacktrace on a per-operation basis...\n// but you can also use `formatError` or `didEncounterErrors` for this perhaps?\n// In any case, AS4 doesn't track `includeStacktraceInErrorResponses` on a\n// per-operation basis; if we find a use case for this we can add it later.\n//\n// So we'll just ignore changes to `logger` and `debug`.\n//\n// Next, there's `request`. We don't know of a use case for mutating the\n// *request* at execution time. If there was a real use case, we could add a\n// function that copies pieces back from the gateway `request` to the AS4\n// request, but we're not bothering to yet.\n//\n// Finally, there's `response`. Sure, the executor *could* mutate `response`.\n// But the main thing the executor is doing is *returning* a response, which\n// then semi-overwrites `requestContext.response` anyway. So it doesn't seem\n// like we need to support `executor` *also* overwriting response. Yet again, we\n// can fix this if it turns out it's necessary. (That said, the executor could\n// in theory write HTTP response headers or status, so we make sure to hook them\n// up directly to the appropriate data in the real GraphQLRequestContext.)\n//\n// So all in all, it looks like it's OK for this to be a \"one-way\" conversion.\nexport function makeGatewayGraphQLRequestContext<TContext extends BaseContext>(\n  as4RequestContext: GraphQLRequestContextExecutionDidStart<TContext>,\n  server: ApolloServer<TContext>,\n  internals: ApolloServerInternals<TContext>,\n): GatewayGraphQLRequestContext {\n  const request: GatewayGraphQLRequest = {};\n  if ('query' in as4RequestContext.request) {\n    request.query = as4RequestContext.request.query;\n  }\n  if ('operationName' in as4RequestContext.request) {\n    request.operationName = as4RequestContext.request.operationName;\n  }\n  if ('variables' in as4RequestContext.request) {\n    request.variables = as4RequestContext.request.variables;\n  }\n  if ('extensions' in as4RequestContext.request) {\n    request.extensions = as4RequestContext.request.extensions;\n  }\n  if (as4RequestContext.request.http) {\n    const as4http = as4RequestContext.request.http;\n    const needQuestion =\n      as4http.search !== '' && !as4http.search.startsWith('?');\n    request.http = {\n      method: as4http.method,\n      // As of AS4, we no longer attempt to track complete URLs (just the search\n      // parameters used in GET requests). So we have to fake them for Gateway.\n      url: `https://unknown-url.invalid/${needQuestion ? '?' : ''}${\n        as4http.search\n      }`,\n      headers: new FetcherHeadersForHeaderMap(as4http.headers),\n    };\n  }\n\n  const response: GatewayGraphQLResponse = {\n    http: {\n      headers: new FetcherHeadersForHeaderMap(\n        as4RequestContext.response.http.headers,\n      ),\n      get status() {\n        return as4RequestContext.response.http.status;\n      },\n      set status(newStatus) {\n        as4RequestContext.response.http.status = newStatus;\n      },\n    },\n    // We leave off `body` because it hasn't been set yet.\n  };\n\n  return {\n    request,\n    response,\n    logger: server.logger,\n    schema: as4RequestContext.schema,\n    // For the sake of typechecking, we still provide this field, but we don't\n    // calculate it. If somebody really needs it in their gateway\n    // implementation, they're welcome to copy\n    // https://github.com/apollographql/apollo-server/blob/3f218e78/packages/apollo-server-core/src/utils/schemaHash.ts\n    // into their code.\n    schemaHash:\n      'schemaHash no longer exists in Apollo Server 4' as GatewaySchemaHash,\n    context: as4RequestContext.contextValue,\n    cache: server.cache,\n    queryHash: as4RequestContext.queryHash,\n    document: as4RequestContext.document,\n    source: as4RequestContext.source,\n    operationName: as4RequestContext.operationName,\n    operation: as4RequestContext.operation,\n    errors: as4RequestContext.errors,\n    metrics: as4RequestContext.metrics,\n    debug: internals.includeStacktraceInErrorResponses,\n    overallCachePolicy: as4RequestContext.overallCachePolicy,\n    requestIsBatched: as4RequestContext.requestIsBatched,\n  };\n}\n\n// An implementation of the W3C-style headers class used by Gateway (and AS3),\n// backed by AS4's HeaderMap. Changes are written directly to the HeaderMap, so\n// any concurrent writes to the underlying HeaderMap (eg from a plugin) can be\n// seen immediately by the gateway and vice versa.\nclass FetcherHeadersForHeaderMap implements FetcherHeaders {\n  constructor(private map: HeaderMap) {}\n  append(name: string, value: string) {\n    if (this.map.has(name)) {\n      this.map.set(name, this.map.get(name) + ', ' + value);\n    } else {\n      this.map.set(name, value);\n    }\n  }\n  delete(name: string) {\n    this.map.delete(name);\n  }\n  get(name: string): string | null {\n    return this.map.get(name) ?? null;\n  }\n  has(name: string): boolean {\n    return this.map.has(name);\n  }\n  set(name: string, value: string) {\n    this.map.set(name, value);\n  }\n  entries(): Iterator<[string, string]> {\n    return this.map.entries();\n  }\n  keys(): Iterator<string> {\n    return this.map.keys();\n  }\n  values(): Iterator<string> {\n    return this.map.values();\n  }\n  [Symbol.iterator](): Iterator<[string, string]> {\n    return this.map.entries();\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3142, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3147, "column": 0}, "map": {"version":3,"file":"incrementalDeliveryPolyfill.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/incrementalDeliveryPolyfill.ts"],"sourcesContent":["import {\n  execute,\n  type ExecutionArgs,\n  type ExecutionResult,\n  type GraphQLError,\n} from 'graphql';\n\n// This file \"polyfills\" graphql@17's experimentalExecuteIncrementally (by\n// returning a function that does not understand incremental directives if\n// you're using graphql@16). The types defined in this file are largely copied\n// from graphql-js.\n\ninterface ObjMap<T> {\n  [key: string]: T;\n}\nexport interface GraphQLExperimentalInitialIncrementalExecutionResult<\n  TData = ObjMap<unknown>,\n  TExtensions = ObjMap<unknown>,\n> extends ExecutionResult<TData, TExtensions> {\n  hasNext: boolean;\n  incremental?: ReadonlyArray<\n    GraphQLExperimentalIncrementalResult<TData, TExtensions>\n  >;\n  extensions?: TExtensions;\n}\n\nexport interface GraphQLExperimentalSubsequentIncrementalExecutionResult<\n  TData = ObjMap<unknown>,\n  TExtensions = ObjMap<unknown>,\n> {\n  hasNext: boolean;\n  incremental?: ReadonlyArray<\n    GraphQLExperimentalIncrementalResult<TData, TExtensions>\n  >;\n  extensions?: TExtensions;\n}\n\ntype GraphQLExperimentalIncrementalResult<\n  TData = ObjMap<unknown>,\n  TExtensions = ObjMap<unknown>,\n> =\n  | GraphQLExperimentalIncrementalDeferResult<TData, TExtensions>\n  | GraphQLExperimentalIncrementalStreamResult<TData, TExtensions>;\n\ninterface GraphQLExperimentalIncrementalDeferResult<\n  TData = ObjMap<unknown>,\n  TExtensions = ObjMap<unknown>,\n> extends ExecutionResult<TData, TExtensions> {\n  path?: ReadonlyArray<string | number>;\n  label?: string;\n}\n\ninterface GraphQLExperimentalIncrementalStreamResult<\n  TData = Array<unknown>,\n  TExtensions = ObjMap<unknown>,\n> {\n  errors?: ReadonlyArray<GraphQLError>;\n  items?: TData | null;\n  path?: ReadonlyArray<string | number>;\n  label?: string;\n  extensions?: TExtensions;\n}\n\nexport interface GraphQLExperimentalIncrementalExecutionResults<\n  TData = ObjMap<unknown>,\n  TExtensions = ObjMap<unknown>,\n> {\n  initialResult: GraphQLExperimentalInitialIncrementalExecutionResult<\n    TData,\n    TExtensions\n  >;\n  subsequentResults: AsyncGenerator<\n    GraphQLExperimentalSubsequentIncrementalExecutionResult<TData, TExtensions>,\n    void,\n    void\n  >;\n}\n\ntype PromiseOrValue<T> = Promise<T> | T;\n\n// This starts as undefined and is set to a function or null by running\n// tryToLoadGraphQL17(). If graphql-js 17 is installed, it is set to the\n// experimentalExecuteIncrementally function from that package; otherwise it is\n// set to null.\nlet graphqlExperimentalExecuteIncrementally:\n  | ((\n      args: ExecutionArgs,\n    ) => PromiseOrValue<\n      ExecutionResult | GraphQLExperimentalIncrementalExecutionResults\n    >)\n  | null\n  | undefined = undefined;\n\nasync function tryToLoadGraphQL17() {\n  if (graphqlExperimentalExecuteIncrementally !== undefined) {\n    return;\n  }\n  const graphql = await import('graphql');\n  if ('experimentalExecuteIncrementally' in graphql) {\n    graphqlExperimentalExecuteIncrementally = (graphql as any)\n      .experimentalExecuteIncrementally;\n  } else {\n    graphqlExperimentalExecuteIncrementally = null;\n  }\n}\n\nexport async function executeIncrementally(\n  args: ExecutionArgs,\n): Promise<ExecutionResult | GraphQLExperimentalIncrementalExecutionResults> {\n  await tryToLoadGraphQL17();\n  if (graphqlExperimentalExecuteIncrementally) {\n    return graphqlExperimentalExecuteIncrementally(args);\n  }\n  return execute(args);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,+BAKiB;AA+EjB,IAAI,uCAAuC,GAO3B,SAAS,CAAC;AAE1B,KAAK,UAAU,kBAAkB;IAC/B,IAAI,uCAAuC,KAAK,SAAS,EAAE,CAAC;QAC1D,OAAO;IACT,CAAC;IACD,MAAM,OAAO,GAAG,MAAA,QAAA,OAAA,GAAA,IAAA,CAAA,IAAA,qBAAa,SAAS,GAAC,CAAC;IACxC,IAAI,kCAAkC,IAAI,OAAO,EAAE,CAAC;QAClD,uCAAuC,GAAI,OAAe,CACvD,gCAAgC,CAAC;IACtC,CAAC,MAAM,CAAC;QACN,uCAAuC,GAAG,IAAI,CAAC;IACjD,CAAC;AACH,CAAC;AAEM,KAAK,UAAU,oBAAoB,CACxC,IAAmB;IAEnB,MAAM,kBAAkB,EAAE,CAAC;IAC3B,IAAI,uCAAuC,EAAE,CAAC;QAC5C,OAAO,uCAAuC,CAAC,IAAI,CAAC,CAAC;IACvD,CAAC;IACD,OAAO,CAAA,GAAA,UAAA,OAAO,EAAC,IAAI,CAAC,CAAC;AACvB,CAAC;AARD,QAAA,oBAAA,GAAA,qBAQC","ignoreList":[0]}},
    {"offset": {"line": 3206, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3211, "column": 0}, "map": {"version":3,"file":"requestPipeline.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/requestPipeline.ts"],"sourcesContent":["import { createHash } from '@apollo/utils.createhash';\nimport {\n  specifiedRules,\n  getOperationAST,\n  GraphQLError,\n  validate,\n  parse,\n  Kind,\n  type ExecutionResult,\n} from 'graphql';\nimport {\n  symbolExecutionDispatcherWillResolveField,\n  enablePluginsForSchemaResolvers,\n  symbolUserFieldResolver,\n} from './utils/schemaInstrumentation.js';\nimport {\n  PersistedQueryNotSupportedError,\n  PersistedQueryNotFoundError,\n  UserInputError,\n  BadRequestError,\n  ValidationError,\n  SyntaxError,\n  OperationResolutionError,\n} from './internalErrorClasses.js';\nimport {\n  ensureError,\n  normalizeAndFormatErrors,\n  ensureGraphQLError,\n} from './errorNormalize.js';\nimport type {\n  GraphQLRequestContext,\n  GraphQLRequestContextDidResolveSource,\n  GraphQLRequestContextExecutionDidStart,\n  GraphQLRequestContextResponseForOperation,\n  GraphQLRequestContextDidResolveOperation,\n  GraphQLRequestContextParsingDidStart,\n  GraphQLRequestContextValidationDidStart,\n  GraphQLRequestContextWillSendResponse,\n  GraphQLRequestContextDidEncounterErrors,\n  GraphQLRequestExecutionListener,\n  BaseContext,\n  GraphQLResponse,\n  GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult,\n} from './externalTypes/index.js';\n\nimport {\n  invokeDidStartHook,\n  invokeHooksUntilDefinedAndNonNull,\n  invokeSyncDidStartHook,\n} from './utils/invokeHooks.js';\n\nimport { makeGatewayGraphQLRequestContext } from './utils/makeGatewayGraphQLRequestContext.js';\n\nimport { mergeHTTPGraphQLHead, newHTTPGraphQLHead } from './runHttpQuery.js';\nimport type {\n  ApolloServer,\n  ApolloServerInternals,\n  SchemaDerivedData,\n} from './ApolloServer.js';\nimport { isDefined } from './utils/isDefined.js';\nimport type {\n  GraphQLRequestContextDidEncounterSubsequentErrors,\n  GraphQLRequestContextWillSendSubsequentPayload,\n} from './externalTypes/requestPipeline.js';\nimport {\n  executeIncrementally,\n  type GraphQLExperimentalInitialIncrementalExecutionResult,\n  type GraphQLExperimentalSubsequentIncrementalExecutionResult,\n} from './incrementalDeliveryPolyfill.js';\nimport { HeaderMap } from './utils/HeaderMap.js';\n\nexport const APQ_CACHE_PREFIX = 'apq:';\n\nfunction computeQueryHash(query: string) {\n  return createHash('sha256').update(query).digest('hex');\n}\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] };\n\nfunction isBadUserInputGraphQLError(error: GraphQLError): boolean {\n  return (\n    error.nodes?.length === 1 &&\n    error.nodes[0].kind === Kind.VARIABLE_DEFINITION &&\n    (error.message.startsWith(\n      `Variable \"$${error.nodes[0].variable.name.value}\" got invalid value `,\n    ) ||\n      error.message.startsWith(\n        `Variable \"$${error.nodes[0].variable.name.value}\" of required type `,\n      ) ||\n      error.message.startsWith(\n        `Variable \"$${error.nodes[0].variable.name.value}\" of non-null type `,\n      ))\n  );\n}\n\n// This is \"semi-formatted\" because the initial result has not yet been\n// formatted but the subsequent results \"have been\" --- in the sense that they\n// are an async iterable that will format them as they come in.\ntype SemiFormattedExecuteIncrementallyResults =\n  | {\n      singleResult: ExecutionResult;\n    }\n  | {\n      initialResult: GraphQLExperimentalInitialIncrementalExecutionResult;\n      subsequentResults: AsyncIterable<GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult>;\n    };\n\nexport async function processGraphQLRequest<TContext extends BaseContext>(\n  schemaDerivedData: SchemaDerivedData,\n  server: ApolloServer<TContext>,\n  internals: ApolloServerInternals<TContext>,\n  requestContext: Mutable<GraphQLRequestContext<TContext>>,\n): Promise<GraphQLResponse> {\n  const requestListeners = (\n    await Promise.all(\n      internals.plugins.map((p) => p.requestDidStart?.(requestContext)),\n    )\n  ).filter(isDefined);\n\n  const request = requestContext.request;\n\n  let { query, extensions } = request;\n\n  let queryHash: string;\n\n  requestContext.metrics.persistedQueryHit = false;\n  requestContext.metrics.persistedQueryRegister = false;\n\n  if (extensions?.persistedQuery) {\n    // It looks like we've received a persisted query. Check if we\n    // support them.\n    if (!internals.persistedQueries) {\n      return await sendErrorResponse([new PersistedQueryNotSupportedError()]);\n    } else if (extensions.persistedQuery.version !== 1) {\n      return await sendErrorResponse([\n        new GraphQLError('Unsupported persisted query version', {\n          extensions: { http: newHTTPGraphQLHead(400) },\n        }),\n      ]);\n    }\n\n    queryHash = extensions.persistedQuery.sha256Hash;\n\n    if (query === undefined) {\n      query = await internals.persistedQueries.cache.get(queryHash);\n      if (query) {\n        requestContext.metrics.persistedQueryHit = true;\n      } else {\n        return await sendErrorResponse([new PersistedQueryNotFoundError()]);\n      }\n    } else {\n      const computedQueryHash = computeQueryHash(query);\n\n      // The provided hash must exactly match the SHA-256 hash of\n      // the query string. This prevents hash hijacking, where a\n      // new and potentially malicious query is associated with\n      // an existing hash.\n      if (queryHash !== computedQueryHash) {\n        return await sendErrorResponse([\n          new GraphQLError('provided sha does not match query', {\n            extensions: { http: newHTTPGraphQLHead(400) },\n          }),\n        ]);\n      }\n\n      // We won't write to the persisted query cache until later.\n      // Deferring the writing gives plugins the ability to \"win\" from use of\n      // the cache, but also have their say in whether or not the cache is\n      // written to (by interrupting the request with an error).\n      requestContext.metrics.persistedQueryRegister = true;\n    }\n  } else if (query) {\n    queryHash = computeQueryHash(query);\n  } else {\n    return await sendErrorResponse([\n      new BadRequestError(\n        'GraphQL operations must contain a non-empty `query` or a `persistedQuery` extension.',\n      ),\n    ]);\n  }\n\n  requestContext.queryHash = queryHash;\n  requestContext.source = query;\n\n  // Let the plugins know that we now have a STRING of what we hope will\n  // parse and validate into a document we can execute on.  Unless we have\n  // retrieved this from our APQ cache, there's no guarantee that it is\n  // syntactically correct, so this string should not be trusted as a valid\n  // document until after it's parsed and validated.\n  await Promise.all(\n    requestListeners.map((l) =>\n      l.didResolveSource?.(\n        requestContext as GraphQLRequestContextDidResolveSource<TContext>,\n      ),\n    ),\n  );\n\n  // If we're configured with a document store (by default, we are), we'll\n  // utilize the operation's hash to lookup the AST from the previously\n  // parsed-and-validated operation.  Failure to retrieve anything from the\n  // cache just means we're committed to doing the parsing and validation.\n  if (schemaDerivedData.documentStore) {\n    try {\n      requestContext.document = await schemaDerivedData.documentStore.get(\n        schemaDerivedData.documentStoreKeyPrefix + queryHash,\n      );\n    } catch (err: unknown) {\n      server.logger.warn(\n        'An error occurred while attempting to read from the documentStore. ' +\n          ensureError(err).message,\n      );\n    }\n  }\n\n  // If we still don't have a document, we'll need to parse and validate it.\n  // With success, we'll attempt to save it into the store for future use.\n  if (!requestContext.document) {\n    const parsingDidEnd = await invokeDidStartHook(\n      requestListeners,\n      async (l) =>\n        l.parsingDidStart?.(\n          requestContext as GraphQLRequestContextParsingDidStart<TContext>,\n        ),\n    );\n\n    try {\n      requestContext.document = parse(query, internals.parseOptions);\n    } catch (syntaxMaybeError: unknown) {\n      const error = ensureError(syntaxMaybeError);\n      await parsingDidEnd(error);\n      return await sendErrorResponse([\n        new SyntaxError(ensureGraphQLError(error)),\n      ]);\n    }\n    await parsingDidEnd();\n\n    if (internals.dangerouslyDisableValidation !== true) {\n      const validationDidEnd = await invokeDidStartHook(\n        requestListeners,\n        async (l) =>\n          l.validationDidStart?.(\n            requestContext as GraphQLRequestContextValidationDidStart<TContext>,\n          ),\n      );\n\n      const validationErrors = validate(\n        schemaDerivedData.schema,\n        requestContext.document,\n        [...specifiedRules, ...internals.validationRules],\n      );\n\n      if (validationErrors.length === 0) {\n        await validationDidEnd();\n      } else {\n        await validationDidEnd(validationErrors);\n        return await sendErrorResponse(\n          validationErrors.map((error) => new ValidationError(error)),\n        );\n      }\n    }\n\n    if (schemaDerivedData.documentStore) {\n      // The underlying cache store behind the `documentStore` returns a\n      // `Promise` which is resolved (or rejected), eventually, based on the\n      // success or failure (respectively) of the cache save attempt.  While\n      // it's certainly possible to `await` this `Promise`, we don't care about\n      // whether or not it's successful at this point.  We'll instead proceed\n      // to serve the rest of the request and just hope that this works out.\n      // If it doesn't work, the next request will have another opportunity to\n      // try again.  Errors will surface as warnings, as appropriate.\n      //\n      // While it shouldn't normally be necessary to wrap this `Promise` in a\n      // `Promise.resolve` invocation, it seems that the underlying cache store\n      // is returning a non-native `Promise` (e.g. Bluebird, etc.).\n      Promise.resolve(\n        schemaDerivedData.documentStore.set(\n          schemaDerivedData.documentStoreKeyPrefix + queryHash,\n          requestContext.document,\n        ),\n      ).catch((err) =>\n        server.logger.warn(\n          'Could not store validated document. ' + err?.message || err,\n        ),\n      );\n    }\n  }\n\n  // TODO: If we want to guarantee an operation has been set when invoking\n  // `willExecuteOperation` and executionDidStart`, we need to throw an\n  // error here and not leave this to `buildExecutionContext` in\n  // `graphql-js`.\n  const operation = getOperationAST(\n    requestContext.document,\n    request.operationName,\n  );\n\n  requestContext.operation = operation || undefined;\n  // We'll set `operationName` to `null` for anonymous operations.\n  requestContext.operationName = operation?.name?.value || null;\n\n  // Special case: GET operations should only be queries (not mutations). We\n  // want to throw a particular HTTP error in that case. (This matters because\n  // it's generally how HTTP requests should work, and additionally it makes us\n  // less vulnerable to mutations running over CSRF, if you turn off our CSRF\n  // prevention feature.)\n  if (\n    request.http?.method === 'GET' &&\n    operation?.operation &&\n    operation.operation !== 'query'\n  ) {\n    return await sendErrorResponse([\n      new BadRequestError(\n        `GET requests only support query operations, not ${operation.operation} operations`,\n        {\n          extensions: {\n            http: { status: 405, headers: new HeaderMap([['allow', 'POST']]) },\n          },\n        },\n      ),\n    ]);\n  }\n\n  try {\n    await Promise.all(\n      requestListeners.map((l) =>\n        l.didResolveOperation?.(\n          requestContext as GraphQLRequestContextDidResolveOperation<TContext>,\n        ),\n      ),\n    );\n  } catch (err: unknown) {\n    // Note that we explicitly document throwing `GraphQLError`s from\n    // `didResolveOperation` as a good way to do validation that depends on the\n    // validated operation and the request context. (It will have status 500 by\n    // default.)\n    return await sendErrorResponse([ensureGraphQLError(err)]);\n  }\n\n  // Now that we've gone through the pre-execution phases of the request\n  // pipeline, and given plugins appropriate ability to object (by throwing\n  // an error) and not actually write, we'll write to the cache if it was\n  // determined earlier in the request pipeline that we should do so.\n  if (\n    requestContext.metrics.persistedQueryRegister &&\n    internals.persistedQueries\n  ) {\n    // While it shouldn't normally be necessary to wrap this `Promise` in a\n    // `Promise.resolve` invocation, it seems that the underlying cache store\n    // is returning a non-native `Promise` (e.g. Bluebird, etc.).\n    const ttl = internals.persistedQueries?.ttl;\n    Promise.resolve(\n      internals.persistedQueries.cache.set(\n        queryHash,\n        query,\n        // Explicitly checking for `undefined` which means \"not set\" vs 0 or\n        // null which means \"no TTL\".\n        ttl !== undefined\n          ? { ttl: internals.persistedQueries?.ttl }\n          : undefined,\n      ),\n    ).catch(server.logger.warn);\n  }\n\n  const responseFromPlugin = await invokeHooksUntilDefinedAndNonNull(\n    requestListeners,\n    async (l) =>\n      await l.responseForOperation?.(\n        requestContext as GraphQLRequestContextResponseForOperation<TContext>,\n      ),\n  );\n  if (responseFromPlugin !== null) {\n    requestContext.response.body = responseFromPlugin.body;\n    mergeHTTPGraphQLHead(requestContext.response.http, responseFromPlugin.http);\n  } else {\n    const executionListeners = (\n      await Promise.all(\n        requestListeners.map((l) =>\n          l.executionDidStart?.(\n            requestContext as GraphQLRequestContextExecutionDidStart<TContext>,\n          ),\n        ),\n      )\n    ).filter(isDefined);\n    executionListeners.reverse();\n\n    if (executionListeners.some((l) => l.willResolveField)) {\n      // Create a callback that will trigger the execution dispatcher's\n      // `willResolveField` hook.  We will attach this to the context on a\n      // symbol so it can be invoked by our `wrapField` method during execution.\n      const invokeWillResolveField: GraphQLRequestExecutionListener<TContext>['willResolveField'] =\n        (...args) =>\n          invokeSyncDidStartHook(executionListeners, (l) =>\n            l.willResolveField?.(...args),\n          );\n\n      Object.defineProperty(\n        requestContext.contextValue,\n        symbolExecutionDispatcherWillResolveField,\n        { value: invokeWillResolveField },\n      );\n\n      // If the user has provided a custom field resolver, we will attach\n      // it to the context so we can still invoke it after we've wrapped the\n      // fields with `wrapField` within `enablePluginsForSchemaResolvers` of\n      // the `schemaInstrumentation` module.\n      if (internals.fieldResolver) {\n        Object.defineProperty(\n          requestContext.contextValue,\n          symbolUserFieldResolver,\n          {\n            value: internals.fieldResolver,\n          },\n        );\n      }\n\n      // If the schema is already enabled, this is a no-op.  Otherwise, the\n      // schema will be augmented so it is able to invoke willResolveField. Note\n      // that if we never see a plugin with willResolveField then we will never\n      // need to instrument the schema, which might be a small performance gain.\n      // (For example, this can happen if you pass `fieldLevelInstrumentation:\n      // () => false` to the usage reporting plugin and disable the cache\n      // control plugin. We can consider changing the cache control plugin to\n      // have a \"static cache control only\" mode that doesn't use\n      // willResolveField too if this proves to be helpful in practice.)\n      enablePluginsForSchemaResolvers(schemaDerivedData.schema);\n    }\n\n    try {\n      const fullResult = await execute(\n        requestContext as GraphQLRequestContextExecutionDidStart<TContext>,\n      );\n      const result =\n        'singleResult' in fullResult\n          ? fullResult.singleResult\n          : fullResult.initialResult;\n\n      // If we don't have an operation, there's no reason to go further. We know\n      // `result` will consist of one error (returned by `graphql-js`'s\n      // `buildExecutionContext`).\n      if (!requestContext.operation) {\n        if (!result.errors?.length) {\n          throw new Error(\n            'Unexpected error: Apollo Server did not resolve an operation but execute did not return errors',\n          );\n        }\n        throw new OperationResolutionError(result.errors[0]);\n      }\n\n      // The first thing that execution does is coerce the request's variables\n      // to the types declared in the operation, which can lead to errors if\n      // they are of the wrong type. It also makes sure that all non-null\n      // variables are required and get non-null values. If any of these things\n      // lead to errors, we change them into UserInputError so that their code\n      // doesn't end up being INTERNAL_SERVER_ERROR, since these are client\n      // errors. (But if the error already has a code, perhaps because the\n      // original error was thrown from a custom scalar parseValue, we leave it\n      // alone. We check that here instead of as part of\n      // isBadUserInputGraphQLError since perhaps that function will one day be\n      // changed to something we can get directly from graphql-js, but the\n      // `code` check is AS-specific.)\n      //\n      // This is hacky! Hopefully graphql-js will give us a way to separate\n      // variable resolution from execution later; see\n      // https://github.com/graphql/graphql-js/issues/3169\n      const resultErrors = result.errors?.map((e) => {\n        if (isBadUserInputGraphQLError(e) && e.extensions?.code == null) {\n          return new UserInputError(e);\n        }\n        return e;\n      });\n\n      if (resultErrors) {\n        await didEncounterErrors(resultErrors);\n      }\n\n      const { formattedErrors, httpFromErrors } = resultErrors\n        ? formatErrors(resultErrors)\n        : { formattedErrors: undefined, httpFromErrors: newHTTPGraphQLHead() };\n\n      // TODO(AS5) This becomes the default behavior and the\n      // `status400ForVariableCoercionErrors` configuration option is removed /\n      // ignored.\n      if (\n        internals.status400ForVariableCoercionErrors &&\n        resultErrors?.length &&\n        result.data === undefined &&\n        !httpFromErrors.status\n      ) {\n        httpFromErrors.status = 400;\n      }\n\n      mergeHTTPGraphQLHead(requestContext.response.http, httpFromErrors);\n\n      if ('singleResult' in fullResult) {\n        requestContext.response.body = {\n          kind: 'single',\n          singleResult: {\n            ...result,\n            errors: formattedErrors,\n          },\n        };\n      } else {\n        requestContext.response.body = {\n          kind: 'incremental',\n          initialResult: {\n            ...fullResult.initialResult,\n            errors: formattedErrors,\n          },\n          subsequentResults: fullResult.subsequentResults,\n        };\n      }\n    } catch (executionMaybeError: unknown) {\n      const executionError = ensureError(executionMaybeError);\n      await Promise.all(\n        executionListeners.map((l) => l.executionDidEnd?.(executionError)),\n      );\n\n      return await sendErrorResponse([ensureGraphQLError(executionError)]);\n    }\n\n    await Promise.all(executionListeners.map((l) => l.executionDidEnd?.()));\n  }\n\n  await invokeWillSendResponse();\n  if (!requestContext.response.body) {\n    throw Error('got to end of processGraphQLRequest without setting body?');\n  }\n  return requestContext.response as GraphQLResponse; // cast checked on previous line\n\n  async function execute(\n    requestContext: GraphQLRequestContextExecutionDidStart<TContext>,\n  ): Promise<SemiFormattedExecuteIncrementallyResults> {\n    const { request, document } = requestContext;\n\n    if (internals.__testing_incrementalExecutionResults) {\n      return internals.__testing_incrementalExecutionResults;\n    } else if (internals.gatewayExecutor) {\n      const result = await internals.gatewayExecutor(\n        makeGatewayGraphQLRequestContext(requestContext, server, internals),\n      );\n      return { singleResult: result };\n    } else {\n      const resultOrResults = await executeIncrementally({\n        schema: schemaDerivedData.schema,\n        document,\n        rootValue:\n          typeof internals.rootValue === 'function'\n            ? internals.rootValue(document)\n            : internals.rootValue,\n        contextValue: requestContext.contextValue,\n        variableValues: request.variables,\n        operationName: request.operationName,\n        fieldResolver: internals.fieldResolver,\n      });\n      if ('initialResult' in resultOrResults) {\n        return {\n          initialResult: resultOrResults.initialResult,\n          subsequentResults: formatErrorsInSubsequentResults(\n            resultOrResults.subsequentResults,\n          ),\n        };\n      } else {\n        return { singleResult: resultOrResults };\n      }\n    }\n  }\n\n  async function* formatErrorsInSubsequentResults(\n    results: AsyncIterable<GraphQLExperimentalSubsequentIncrementalExecutionResult>,\n  ): AsyncIterable<GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult> {\n    for await (const result of results) {\n      const payload: GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult =\n        result.incremental\n          ? {\n              ...result,\n              incremental: await seriesAsyncMap(\n                result.incremental,\n                async (incrementalResult) => {\n                  const { errors } = incrementalResult;\n                  if (errors) {\n                    await Promise.all(\n                      requestListeners.map((l) =>\n                        l.didEncounterSubsequentErrors?.(\n                          requestContext as GraphQLRequestContextDidEncounterSubsequentErrors<TContext>,\n                          errors,\n                        ),\n                      ),\n                    );\n\n                    return {\n                      ...incrementalResult,\n                      // Note that any `http` extensions in errors have no\n                      // effect, because we've already sent the status code\n                      // and response headers.\n                      errors: formatErrors(errors).formattedErrors,\n                    };\n                  }\n                  return incrementalResult;\n                },\n              ),\n            }\n          : result;\n\n      // Invoke hook, which is allowed to mutate payload if it really wants to.\n      await Promise.all(\n        requestListeners.map((l) =>\n          l.willSendSubsequentPayload?.(\n            requestContext as GraphQLRequestContextWillSendSubsequentPayload<TContext>,\n            payload,\n          ),\n        ),\n      );\n\n      yield payload;\n    }\n  }\n\n  async function invokeWillSendResponse() {\n    await Promise.all(\n      requestListeners.map((l) =>\n        l.willSendResponse?.(\n          requestContext as GraphQLRequestContextWillSendResponse<TContext>,\n        ),\n      ),\n    );\n  }\n\n  // Note that we ensure that all calls to didEncounterErrors are followed by\n  // calls to willSendResponse. (The usage reporting plugin depends on this.)\n  async function didEncounterErrors(errors: ReadonlyArray<GraphQLError>) {\n    requestContext.errors = errors;\n\n    return await Promise.all(\n      requestListeners.map((l) =>\n        l.didEncounterErrors?.(\n          requestContext as GraphQLRequestContextDidEncounterErrors<TContext>,\n        ),\n      ),\n    );\n  }\n\n  // This function \"sends\" a response that contains errors and no data (not even\n  // `data: null`) because the pipeline does not make it to a successful\n  // `execute` call. (It is *not* called for execution that happens to return\n  // some errors.) In this case \"send\" means \"update requestContext.response and\n  // invoke willSendResponse hooks\".\n  //\n  // If any errors have `extensions.http` set, it sets the response's status code\n  // and errors from them.\n  //\n  // Then, if the HTTP status code is not yet set, it sets it to 500.\n  async function sendErrorResponse(\n    errors: ReadonlyArray<GraphQLError>,\n  ): Promise<GraphQLResponse> {\n    await didEncounterErrors(errors);\n\n    const { formattedErrors, httpFromErrors } = formatErrors(errors);\n\n    requestContext.response.body = {\n      kind: 'single',\n      singleResult: {\n        errors: formattedErrors,\n      },\n    };\n\n    mergeHTTPGraphQLHead(requestContext.response.http, httpFromErrors);\n\n    if (!requestContext.response.http.status) {\n      requestContext.response.http.status = 500;\n    }\n\n    await invokeWillSendResponse();\n\n    // cast safe because we assigned to `body` above\n    return requestContext.response as GraphQLResponse;\n  }\n\n  function formatErrors(\n    errors: ReadonlyArray<GraphQLError>,\n  ): ReturnType<typeof normalizeAndFormatErrors> {\n    return normalizeAndFormatErrors(errors, {\n      formatError: internals.formatError,\n      includeStacktraceInErrorResponses:\n        internals.includeStacktraceInErrorResponses,\n    });\n  }\n}\n\nasync function seriesAsyncMap<T, U>(\n  ts: readonly T[],\n  fn: (value: T) => Promise<U>,\n): Promise<U[]> {\n  const us: U[] = [];\n  for (const t of ts) {\n    const u = await fn(t);\n    us.push(u);\n  }\n  return us;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3525, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3530, "column": 0}, "map": {"version":3,"file":"UnreachableCaseError.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/utils/UnreachableCaseError.ts"],"sourcesContent":["/**\n * Throw this in places that should be unreachable (because all other cases have\n * been handled, reducing the type of the argument to `never`). TypeScript will\n * complain if in fact there is a valid type for the argument.\n */\nexport class UnreachableCaseError extends Error {\n  constructor(val: never) {\n    super(`Unreachable case: ${val}`);\n  }\n}\n"],"names":[],"mappings":";;;;;AAKA,MAAa,oBAAqB,SAAQ,KAAK;IAC7C,YAAY,GAAU,CAAA;QACpB,KAAK,CAAC,CAAA,kBAAA,EAAqB,GAAG,EAAE,CAAC,CAAC;IACpC,CAAC;CACF;AAJD,QAAA,oBAAA,GAAA,qBAIC","ignoreList":[0]}},
    {"offset": {"line": 3541, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3546, "column": 0}, "map": {"version":3,"file":"computeCoreSchemaHash.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/utils/computeCoreSchemaHash.ts"],"sourcesContent":["import { createHash } from '@apollo/utils.createhash';\n\n// This hash function is used in both the schema reporting and usage reporting\n// plugins. Making sure we use the same hash function hypothetically allows the\n// two reporting features to work well together, though in practice nothing on\n// the Studio side currently correlates this ID across both features.\nexport function computeCoreSchemaHash(schema: string): string {\n  return createHash('sha256').update(schema).digest('hex');\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA,yDAAsD;AAMtD,SAAgB,qBAAqB,CAAC,MAAc;IAClD,OAAO,CAAA,GAAA,mBAAA,UAAU,EAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AAC3D,CAAC;AAFD,QAAA,qBAAA,GAAA,sBAEC","ignoreList":[0]}},
    {"offset": {"line": 3556, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3561, "column": 0}, "map": {"version":3,"file":"schemaManager.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/utils/schemaManager.ts"],"sourcesContent":["import type { Logger } from '@apollo/utils.logger';\nimport type { GraphQLSchema } from 'graphql';\nimport type {\n  GatewayExecutor,\n  GatewayInterface,\n  GatewayUnsubscriber,\n} from '@apollo/server-gateway-interface';\nimport type { SchemaDerivedData } from '../ApolloServer.js';\nimport type {\n  ApolloConfig,\n  GraphQLSchemaContext,\n} from '../externalTypes/index.js';\n\ntype SchemaDerivedDataProvider = (\n  apiSchema: GraphQLSchema,\n) => SchemaDerivedData;\n\n/**\n * An async-safe class for tracking changes in schemas and schema-derived data.\n *\n * Specifically, as long as start() is called (and completes) before stop() is\n * called, any set of executions of public methods is linearizable.\n *\n * Note that linearizability in Javascript is trivial if all public methods are\n * non-async, but increasingly difficult to guarantee if public methods become\n * async. Accordingly, if you believe a public method should be async, think\n * carefully on whether it's worth the mental overhead. (E.g. if you wished that\n * a callback was async, consider instead resolving a Promise in a non-async\n * callback and having your async code wait on the Promise in setTimeout().)\n */\nexport class SchemaManager {\n  private readonly logger: Logger;\n  private readonly schemaDerivedDataProvider: SchemaDerivedDataProvider;\n  private readonly onSchemaLoadOrUpdateListeners = new Set<\n    (schemaContext: GraphQLSchemaContext) => void\n  >();\n  private isStopped = false;\n  private schemaDerivedData?: SchemaDerivedData;\n  private schemaContext?: GraphQLSchemaContext;\n\n  // For state that's specific to the mode of operation.\n  private readonly modeSpecificState:\n    | {\n        readonly mode: 'gateway';\n        readonly gateway: GatewayInterface;\n        readonly apolloConfig: ApolloConfig;\n        unsubscribeFromGateway?: GatewayUnsubscriber;\n      }\n    | {\n        readonly mode: 'schema';\n        readonly apiSchema: GraphQLSchema;\n        readonly schemaDerivedData: SchemaDerivedData;\n      };\n\n  constructor(\n    options: (\n      | { gateway: GatewayInterface; apolloConfig: ApolloConfig }\n      | { apiSchema: GraphQLSchema }\n    ) & {\n      logger: Logger;\n      schemaDerivedDataProvider: SchemaDerivedDataProvider;\n    },\n  ) {\n    this.logger = options.logger;\n    this.schemaDerivedDataProvider = options.schemaDerivedDataProvider;\n    if ('gateway' in options) {\n      this.modeSpecificState = {\n        mode: 'gateway',\n        gateway: options.gateway,\n        apolloConfig: options.apolloConfig,\n      };\n    } else {\n      this.modeSpecificState = {\n        mode: 'schema',\n        apiSchema: options.apiSchema,\n        // The caller of the constructor expects us to fail early if the schema\n        // given is invalid/has errors, so we call the provider here. We also\n        // pass the result to start(), as the provider can be expensive to call.\n        schemaDerivedData: options.schemaDerivedDataProvider(options.apiSchema),\n      };\n    }\n  }\n\n  /**\n   * Calling start() will:\n   * - Start gateway schema fetching (if a gateway was provided).\n   * - Initialize schema-derived data.\n   * - Synchronously notify onSchemaLoadOrUpdate() listeners of schema load, and\n   *   asynchronously notify them of schema updates.\n   * - If we started a gateway, returns the gateway's executor; otherwise null.\n   */\n  public async start(): Promise<GatewayExecutor | null> {\n    if (this.modeSpecificState.mode === 'gateway') {\n      const gateway = this.modeSpecificState.gateway;\n      if (gateway.onSchemaLoadOrUpdate) {\n        // Use onSchemaLoadOrUpdate, as it reports the core supergraph SDL and\n        // always reports the initial schema load.\n        this.modeSpecificState.unsubscribeFromGateway =\n          gateway.onSchemaLoadOrUpdate((schemaContext) => {\n            this.processSchemaLoadOrUpdateEvent(schemaContext);\n          });\n      } else {\n        throw new Error(\n          \"Unexpectedly couldn't find onSchemaLoadOrUpdate on gateway\",\n        );\n      }\n\n      const config = await this.modeSpecificState.gateway.load({\n        apollo: this.modeSpecificState.apolloConfig,\n      });\n\n      return config.executor;\n    } else {\n      this.processSchemaLoadOrUpdateEvent(\n        {\n          apiSchema: this.modeSpecificState.apiSchema,\n        },\n        this.modeSpecificState.schemaDerivedData,\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Registers a listener for schema load/update events. Note that the latest\n   * event is buffered, i.e.\n   * - If registered before start(), this method will throw. (We have no need\n   *   for registration before start(), but this is easy enough to change.)\n   * - If registered after start() but before stop(), the callback will be first\n   *   called in this method (for whatever the current schema is), and then\n   *   later for updates.\n   * - If registered after stop(), the callback will never be called.\n   *\n   * For gateways, a core supergraph SDL will be provided to the callback.\n   *\n   * @param callback The listener to execute on schema load/updates.\n   */\n  public onSchemaLoadOrUpdate(\n    callback: (schemaContext: GraphQLSchemaContext) => void,\n  ): GatewayUnsubscriber {\n    if (!this.schemaContext) {\n      throw new Error('You must call start() before onSchemaLoadOrUpdate()');\n    }\n    if (!this.isStopped) {\n      try {\n        callback(this.schemaContext);\n      } catch (e) {\n        // Note that onSchemaLoadOrUpdate() is currently only called from\n        // ApolloServer._start(), so we throw here to alert the user early\n        // that their callback is failing.\n        throw new Error(\n          `An error was thrown from an 'onSchemaLoadOrUpdate' listener: ${\n            (e as Error).message\n          }`,\n        );\n      }\n    }\n    this.onSchemaLoadOrUpdateListeners.add(callback);\n\n    return () => {\n      this.onSchemaLoadOrUpdateListeners.delete(callback);\n    };\n  }\n\n  /**\n   * Get the schema-derived state for the current schema. This throws if called\n   * before start() is called.\n   */\n  public getSchemaDerivedData(): SchemaDerivedData {\n    if (!this.schemaDerivedData) {\n      throw new Error('You must call start() before getSchemaDerivedData()');\n    }\n    return this.schemaDerivedData;\n  }\n\n  /**\n   * Calling stop() will:\n   * - Stop gateway schema fetching (if a gateway was provided).\n   *   - Note that this specific step may not succeed if gateway is old.\n   * - Stop updating schema-derived data.\n   * - Stop notifying onSchemaLoadOrUpdate() listeners.\n   */\n  public async stop(): Promise<void> {\n    this.isStopped = true;\n    if (this.modeSpecificState.mode === 'gateway') {\n      this.modeSpecificState.unsubscribeFromGateway?.();\n      await this.modeSpecificState.gateway.stop?.();\n    }\n  }\n\n  private processSchemaLoadOrUpdateEvent(\n    schemaContext: GraphQLSchemaContext,\n    schemaDerivedData?: SchemaDerivedData,\n  ): void {\n    if (!this.isStopped) {\n      this.schemaDerivedData =\n        schemaDerivedData ??\n        this.schemaDerivedDataProvider(schemaContext.apiSchema);\n      this.schemaContext = schemaContext;\n      this.onSchemaLoadOrUpdateListeners.forEach((listener) => {\n        try {\n          listener(schemaContext);\n        } catch (e) {\n          this.logger.error(\n            \"An error was thrown from an 'onSchemaLoadOrUpdate' listener\",\n          );\n          this.logger.error(e);\n        }\n      });\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;AA8BA,MAAa,aAAa;IAwBxB,YACE,OAMC,CAAA;QA5Bc,IAAA,CAAA,6BAA6B,GAAG,IAAI,GAAG,EAErD,CAAC;QACI,IAAA,CAAA,SAAS,GAAG,KAAK,CAAC;QA2BxB,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;QAC7B,IAAI,CAAC,yBAAyB,GAAG,OAAO,CAAC,yBAAyB,CAAC;QACnE,IAAI,SAAS,IAAI,OAAO,EAAE,CAAC;YACzB,IAAI,CAAC,iBAAiB,GAAG;gBACvB,IAAI,EAAE,SAAS;gBACf,OAAO,EAAE,OAAO,CAAC,OAAO;gBACxB,YAAY,EAAE,OAAO,CAAC,YAAY;aACnC,CAAC;QACJ,CAAC,MAAM,CAAC;YACN,IAAI,CAAC,iBAAiB,GAAG;gBACvB,IAAI,EAAE,QAAQ;gBACd,SAAS,EAAE,OAAO,CAAC,SAAS;gBAI5B,iBAAiB,EAAE,OAAO,CAAC,yBAAyB,CAAC,OAAO,CAAC,SAAS,CAAC;aACxE,CAAC;QACJ,CAAC;IACH,CAAC;IAUM,KAAK,CAAC,KAAK,GAAA;QAChB,IAAI,IAAI,CAAC,iBAAiB,CAAC,IAAI,KAAK,SAAS,EAAE,CAAC;YAC9C,MAAM,OAAO,GAAG,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC;YAC/C,IAAI,OAAO,CAAC,oBAAoB,EAAE,CAAC;gBAGjC,IAAI,CAAC,iBAAiB,CAAC,sBAAsB,GAC3C,OAAO,CAAC,oBAAoB,CAAC,CAAC,aAAa,EAAE,EAAE;oBAC7C,IAAI,CAAC,8BAA8B,CAAC,aAAa,CAAC,CAAC;gBACrD,CAAC,CAAC,CAAC;YACP,CAAC,MAAM,CAAC;gBACN,MAAM,IAAI,KAAK,CACb,4DAA4D,CAC7D,CAAC;YACJ,CAAC;YAED,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,IAAI,CAAC;gBACvD,MAAM,EAAE,IAAI,CAAC,iBAAiB,CAAC,YAAY;aAC5C,CAAC,CAAC;YAEH,OAAO,MAAM,CAAC,QAAQ,CAAC;QACzB,CAAC,MAAM,CAAC;YACN,IAAI,CAAC,8BAA8B,CACjC;gBACE,SAAS,EAAE,IAAI,CAAC,iBAAiB,CAAC,SAAS;aAC5C,EACD,IAAI,CAAC,iBAAiB,CAAC,iBAAiB,CACzC,CAAC;YACF,OAAO,IAAI,CAAC;QACd,CAAC;IACH,CAAC;IAgBM,oBAAoB,CACzB,QAAuD,EAAA;QAEvD,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC;YACxB,MAAM,IAAI,KAAK,CAAC,qDAAqD,CAAC,CAAC;QACzE,CAAC;QACD,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;YACpB,IAAI,CAAC;gBACH,QAAQ,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;YAC/B,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC;gBAIX,MAAM,IAAI,KAAK,CACb,CAAA,6DAAA,EACG,CAAW,CAAC,OACf,EAAE,CACH,CAAC;YACJ,CAAC;QACH,CAAC;QACD,IAAI,CAAC,6BAA6B,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QAEjD,OAAO,GAAG,EAAE;YACV,IAAI,CAAC,6BAA6B,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QACtD,CAAC,CAAC;IACJ,CAAC;IAMM,oBAAoB,GAAA;QACzB,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAC5B,MAAM,IAAI,KAAK,CAAC,qDAAqD,CAAC,CAAC;QACzE,CAAC;QACD,OAAO,IAAI,CAAC,iBAAiB,CAAC;IAChC,CAAC;IASM,KAAK,CAAC,IAAI,GAAA;QACf,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;QACtB,IAAI,IAAI,CAAC,iBAAiB,CAAC,IAAI,KAAK,SAAS,EAAE,CAAC;YAC9C,IAAI,CAAC,iBAAiB,CAAC,sBAAsB,EAAE,EAAE,CAAC;YAClD,MAAM,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;QAChD,CAAC;IACH,CAAC;IAEO,8BAA8B,CACpC,aAAmC,EACnC,iBAAqC,EAAA;QAErC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;YACpB,IAAI,CAAC,iBAAiB,GACpB,iBAAiB,IACjB,IAAI,CAAC,yBAAyB,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;YAC1D,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;YACnC,IAAI,CAAC,6BAA6B,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,EAAE;gBACtD,IAAI,CAAC;oBACH,QAAQ,CAAC,aAAa,CAAC,CAAC;gBAC1B,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC;oBACX,IAAI,CAAC,MAAM,CAAC,KAAK,CACf,6DAA6D,CAC9D,CAAC;oBACF,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;gBACvB,CAAC;YACH,CAAC,CAAC,CAAC;QACL,CAAC;IACH,CAAC;CACF;AArLD,QAAA,aAAA,GAAA,cAqLC","ignoreList":[0]}},
    {"offset": {"line": 3652, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3657, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/plugin/cacheControl/index.ts"],"sourcesContent":["import type { ApolloServerPlugin } from '../../externalTypes/index.js';\nimport {\n  type DirectiveNode,\n  getNamedType,\n  type GraphQLCompositeType,\n  type GraphQLField,\n  isCompositeType,\n  isInterfaceType,\n  isObjectType,\n  responsePathAsArray,\n} from 'graphql';\nimport { newCachePolicy } from '../../cachePolicy.js';\nimport { internalPlugin } from '../../internalPlugin.js';\nimport LRUCache from 'lru-cache';\nimport type {\n  CacheHint,\n  CacheScope,\n  GraphQLResolveInfoWithCacheControl,\n} from '@apollo/cache-control-types';\n\n/**\n * CacheAnnotation represents the contents of a `@cacheControl` directive.\n * (`inheritMaxAge` is part of this interface and not CacheHint, because\n * `inheritMaxAge` isn't a contributing piece of a cache policy: it just means\n * to not apply default values in some contexts.)\n */\ninterface CacheAnnotation extends CacheHint {\n  inheritMaxAge?: true;\n}\n\nexport interface ApolloServerPluginCacheControlOptions {\n  /**\n   * All root fields and fields returning objects or interfaces have this value\n   * for `maxAge` unless they set a cache hint with a non-undefined `maxAge`\n   * using `@cacheControl` or `setCacheHint`. The default is 0, which means \"not\n   * cacheable\". (That is: if you don't set `defaultMaxAge`, then every root\n   * field in your operation and every field with sub-fields must have a cache\n   * hint or the overall operation will not be cacheable.)\n   */\n  defaultMaxAge?: number;\n  /**\n   * Determines whether to set the `Cache-Control` HTTP header. If true (the\n   * default), the header is written on all responses (with a value of\n   * `no-store` for non-cacheable responses). If `'if-cacheable'`, the header is\n   * only written for cacheable responses. If false, the header is never\n   * written. A response is cacheable if its overall cache policy has a non-zero\n   * `maxAge`, and the body is a single result rather than an incremental\n   * delivery response, and the body contains no errors.\n   */\n  calculateHttpHeaders?: boolean | 'if-cacheable';\n  // For testing only.\n  __testing__cacheHints?: Map<string, CacheHint>;\n}\n\nexport function ApolloServerPluginCacheControl(\n  options: ApolloServerPluginCacheControlOptions = Object.create(null),\n): ApolloServerPlugin {\n  let typeAnnotationCache: LRUCache<GraphQLCompositeType, CacheAnnotation>;\n\n  let fieldAnnotationCache: LRUCache<\n    GraphQLField<unknown, unknown>,\n    CacheAnnotation\n  >;\n\n  return internalPlugin({\n    __internal_plugin_id__: 'CacheControl',\n    __is_disabled_plugin__: false,\n\n    async serverWillStart({ schema }) {\n      // Set the size of the caches to be equal to the number of composite types\n      // and fields in the schema respectively. This generally means that the\n      // cache will always have room for all the cache hints in the active\n      // schema but we won't have a memory leak as schemas are replaced in a\n      // gateway. (Once we're comfortable breaking compatibility with\n      // versions of Gateway older than 0.35.0, we should also run this code\n      // from a schemaDidLoadOrUpdate instead of serverWillStart. Using\n      // schemaDidLoadOrUpdate throws when combined with old gateways.)\n      typeAnnotationCache = new LRUCache<GraphQLCompositeType, CacheAnnotation>(\n        {\n          max: Object.values(schema.getTypeMap()).filter(isCompositeType)\n            .length,\n        },\n      );\n\n      fieldAnnotationCache = new LRUCache<\n        GraphQLField<unknown, unknown>,\n        CacheAnnotation\n      >({\n        max:\n          Object.values(schema.getTypeMap())\n            .filter(isObjectType)\n            .flatMap((t) => Object.values(t.getFields())).length +\n          Object.values(schema.getTypeMap())\n            .filter(isInterfaceType)\n            .flatMap((t) => Object.values(t.getFields())).length,\n      });\n\n      return undefined;\n    },\n\n    async requestDidStart(requestContext) {\n      function memoizedCacheAnnotationFromType(\n        t: GraphQLCompositeType,\n      ): CacheAnnotation {\n        const existing = typeAnnotationCache.get(t);\n        if (existing) {\n          return existing;\n        }\n        const annotation = cacheAnnotationFromType(t);\n        typeAnnotationCache.set(t, annotation);\n        return annotation;\n      }\n\n      function memoizedCacheAnnotationFromField(\n        field: GraphQLField<unknown, unknown>,\n      ): CacheAnnotation {\n        const existing = fieldAnnotationCache.get(field);\n        if (existing) {\n          return existing;\n        }\n        const annotation = cacheAnnotationFromField(field);\n        fieldAnnotationCache.set(field, annotation);\n        return annotation;\n      }\n\n      const defaultMaxAge: number = options.defaultMaxAge ?? 0;\n      const calculateHttpHeaders = options.calculateHttpHeaders ?? true;\n      const { __testing__cacheHints } = options;\n\n      return {\n        async executionDidStart() {\n          // Did something set the overall cache policy before we've even\n          // started? If so, consider that as an override and don't touch it.\n          // Just put set up fake `info.cacheControl` objects and otherwise\n          // don't track cache policy.\n          //\n          // (This doesn't happen in practice using the core plugins: the main\n          // use case for restricting overallCachePolicy outside of this plugin\n          // is apollo-server-plugin-response-cache, but when it sets the policy\n          // we never get to execution at all.)\n          if (isRestricted(requestContext.overallCachePolicy)) {\n            // This is \"fake\" in the sense that it never actually affects\n            // requestContext.overallCachePolicy.\n            const fakeFieldPolicy = newCachePolicy();\n            return {\n              willResolveField({ info }) {\n                // This `as` is \"safe\" in the sense that this is the statement\n                // that makes a GraphQLResolveInfo into a\n                // GraphQLResolveInfoWithCacheControl.\n                (info as GraphQLResolveInfoWithCacheControl).cacheControl = {\n                  setCacheHint: (dynamicHint: CacheHint) => {\n                    fakeFieldPolicy.replace(dynamicHint);\n                  },\n                  cacheHint: fakeFieldPolicy,\n                  cacheHintFromType: memoizedCacheAnnotationFromType,\n                };\n              },\n            };\n          }\n\n          return {\n            willResolveField({ info }) {\n              const fieldPolicy = newCachePolicy();\n\n              let inheritMaxAge = false;\n\n              // If this field's resolver returns an object/interface/union\n              // (maybe wrapped in list/non-null), look for hints on that return\n              // type.\n              const targetType = getNamedType(info.returnType);\n              if (isCompositeType(targetType)) {\n                const typeAnnotation =\n                  memoizedCacheAnnotationFromType(targetType);\n                fieldPolicy.replace(typeAnnotation);\n                inheritMaxAge = !!typeAnnotation.inheritMaxAge;\n              }\n\n              // Look for hints on the field itself (on its parent type), taking\n              // precedence over previously calculated hints.\n              const fieldAnnotation = memoizedCacheAnnotationFromField(\n                info.parentType.getFields()[info.fieldName],\n              );\n\n              // Note that specifying `@cacheControl(inheritMaxAge: true)` on a\n              // field whose return type defines a `maxAge` gives precedence to\n              // the type's `maxAge`. (Perhaps this should be some sort of\n              // error.)\n              if (\n                fieldAnnotation.inheritMaxAge &&\n                fieldPolicy.maxAge === undefined\n              ) {\n                inheritMaxAge = true;\n                // Handle `@cacheControl(inheritMaxAge: true, scope: PRIVATE)`.\n                // (We ignore any specified `maxAge`; perhaps it should be some\n                // sort of error.)\n                if (fieldAnnotation.scope) {\n                  fieldPolicy.replace({ scope: fieldAnnotation.scope });\n                }\n              } else {\n                fieldPolicy.replace(fieldAnnotation);\n              }\n\n              // This `as` is \"safe\" in the sense that this is the statement\n              // that makes a GraphQLResolveInfo into a\n              // GraphQLResolveInfoWithCacheControl.\n              (info as GraphQLResolveInfoWithCacheControl).cacheControl = {\n                setCacheHint: (dynamicHint: CacheHint) => {\n                  fieldPolicy.replace(dynamicHint);\n                },\n                cacheHint: fieldPolicy,\n                cacheHintFromType: memoizedCacheAnnotationFromType,\n              };\n\n              // When the resolver is done, call restrict once. By calling\n              // restrict after the resolver instead of before, we don't need to\n              // \"undo\" the effect on overallCachePolicy of a static hint that\n              // gets refined by a dynamic hint.\n              return () => {\n                // If this field returns a composite type or is a root field and\n                // we haven't seen an explicit maxAge hint, set the maxAge to 0\n                // (uncached) or the default if specified in the constructor.\n                // (Non-object fields by default are assumed to inherit their\n                // cacheability from their parents. But on the other hand, while\n                // root non-object fields can get explicit hints from their\n                // definition on the Query/Mutation object, if that doesn't\n                // exist then there's no parent field that would assign the\n                // default maxAge, so we do it here.)\n                //\n                // You can disable this on a non-root field by writing\n                // `@cacheControl(inheritMaxAge: true)` on it. If you do this,\n                // then its children will be treated like root paths, since\n                // there is no parent maxAge to inherit.\n                //\n                // We do this in the end hook so that dynamic cache control\n                // prevents it from happening (eg,\n                // `info.cacheControl.cacheHint.restrict({maxAge: 60})` should\n                // work rather than doing nothing because we've already set the\n                // max age to the default of 0). This also lets resolvers assume\n                // any hint in `info.cacheControl.cacheHint` was explicitly set.\n                if (\n                  fieldPolicy.maxAge === undefined &&\n                  ((isCompositeType(targetType) && !inheritMaxAge) ||\n                    !info.path.prev)\n                ) {\n                  fieldPolicy.restrict({ maxAge: defaultMaxAge });\n                }\n\n                if (__testing__cacheHints && isRestricted(fieldPolicy)) {\n                  const path = responsePathAsArray(info.path).join('.');\n                  if (__testing__cacheHints.has(path)) {\n                    throw Error(\n                      \"shouldn't happen: addHint should only be called once per path\",\n                    );\n                  }\n                  __testing__cacheHints.set(path, {\n                    maxAge: fieldPolicy.maxAge,\n                    scope: fieldPolicy.scope,\n                  });\n                }\n                requestContext.overallCachePolicy.restrict(fieldPolicy);\n              };\n            },\n          };\n        },\n\n        async willSendResponse(requestContext) {\n          // This hook is just for setting response headers, so make sure that\n          // hasn't been disabled.\n          if (!calculateHttpHeaders) {\n            return;\n          }\n\n          const { response, overallCachePolicy } = requestContext;\n\n          // Look to see if something has already set the cache-control header.\n          // This could be a different plugin... or it could be this very plugin\n          // operating on a different operation in the same batched HTTP\n          // request.\n          const existingCacheControlHeader = parseExistingCacheControlHeader(\n            response.http.headers.get('cache-control'),\n          );\n\n          // If the header contains something other than a value that this\n          // plugin sets, then we leave it alone. We don't want to mangle\n          // something important that you set! That said, it's probably best to\n          // have only one piece of code that writes to a given header, so you\n          // should probably set `calculateHttpHeaders: false` on this plugin.\n          if (existingCacheControlHeader.kind === 'unparsable') {\n            return;\n          }\n\n          const cachePolicy = newCachePolicy();\n          cachePolicy.replace(overallCachePolicy);\n          if (existingCacheControlHeader.kind === 'parsable-and-cacheable') {\n            cachePolicy.restrict(existingCacheControlHeader.hint);\n          }\n          const policyIfCacheable = cachePolicy.policyIfCacheable();\n\n          if (\n            // This code path is only for if we believe it is cacheable.\n            policyIfCacheable &&\n            // Either there wasn't a cache-control header already, or we've\n            // already incorporated it into policyIfCacheable. (If we couldn't\n            // parse it, that means some other plugin or mechanism set the\n            // header. This is confusing, so we just don't make any more\n            // changes. You should probably set `calculateHttpHeaders` to false\n            // in that case and only set the header from one place.)\n            existingCacheControlHeader.kind !== 'uncacheable' &&\n            // At least for now, we don't set cache-control headers for\n            // incremental delivery responses, since we don't know if a later\n            // part of the execution will affect the cache policy (perhaps\n            // dynamically). (Note that willSendResponse is called when the\n            // initial payload is sent, not the final payload.)\n            response.body.kind === 'single' &&\n            !response.body.singleResult.errors\n          ) {\n            response.http.headers.set(\n              'cache-control',\n              `max-age=${\n                policyIfCacheable.maxAge\n              }, ${policyIfCacheable.scope.toLowerCase()}`,\n            );\n          } else if (calculateHttpHeaders !== 'if-cacheable') {\n            // The response is not cacheable, so make sure it doesn't get\n            // cached. This is especially important for GET requests, because\n            // browsers and other agents cache many GET requests by default.\n            // (But if some other plugin set the header to a value that this\n            // plugin does not produce, we don't do anything.)\n            response.http.headers.set(\n              'cache-control',\n              CACHE_CONTROL_HEADER_UNCACHEABLE,\n            );\n          }\n        },\n      };\n    },\n  });\n}\n\nconst CACHE_CONTROL_HEADER_CACHEABLE_REGEXP =\n  /^max-age=(\\d+), (public|private)$/;\nconst CACHE_CONTROL_HEADER_UNCACHEABLE = 'no-store';\n\ntype ExistingCacheControlHeader =\n  | { kind: 'no-header' }\n  | { kind: 'uncacheable' }\n  | { kind: 'parsable-and-cacheable'; hint: CacheHint }\n  | { kind: 'unparsable' };\n\nfunction parseExistingCacheControlHeader(\n  header: string | undefined,\n): ExistingCacheControlHeader {\n  if (!header) {\n    return { kind: 'no-header' };\n  }\n  if (header === CACHE_CONTROL_HEADER_UNCACHEABLE) {\n    return { kind: 'uncacheable' };\n  }\n  const match = CACHE_CONTROL_HEADER_CACHEABLE_REGEXP.exec(header);\n  if (!match) {\n    return { kind: 'unparsable' };\n  }\n  return {\n    kind: 'parsable-and-cacheable',\n    hint: {\n      maxAge: +match[1],\n      scope: match[2] === 'public' ? 'PUBLIC' : 'PRIVATE',\n    },\n  };\n}\n\nfunction cacheAnnotationFromDirectives(\n  directives: ReadonlyArray<DirectiveNode> | undefined,\n): CacheAnnotation | undefined {\n  if (!directives) return undefined;\n\n  const cacheControlDirective = directives.find(\n    (directive) => directive.name.value === 'cacheControl',\n  );\n  if (!cacheControlDirective) return undefined;\n\n  if (!cacheControlDirective.arguments) return undefined;\n\n  const maxAgeArgument = cacheControlDirective.arguments.find(\n    (argument) => argument.name.value === 'maxAge',\n  );\n  const scopeArgument = cacheControlDirective.arguments.find(\n    (argument) => argument.name.value === 'scope',\n  );\n  const inheritMaxAgeArgument = cacheControlDirective.arguments.find(\n    (argument) => argument.name.value === 'inheritMaxAge',\n  );\n\n  const scopeString =\n    scopeArgument?.value?.kind === 'EnumValue'\n      ? scopeArgument.value.value\n      : undefined;\n\n  const scope: CacheScope | undefined =\n    scopeString === 'PUBLIC' || scopeString === 'PRIVATE'\n      ? scopeString\n      : undefined;\n\n  if (\n    inheritMaxAgeArgument?.value?.kind === 'BooleanValue' &&\n    inheritMaxAgeArgument.value.value\n  ) {\n    // We ignore maxAge if it is also specified.\n    return { inheritMaxAge: true, scope };\n  }\n\n  return {\n    maxAge:\n      maxAgeArgument?.value?.kind === 'IntValue'\n        ? parseInt(maxAgeArgument.value.value)\n        : undefined,\n    scope,\n  };\n}\n\nfunction cacheAnnotationFromType(t: GraphQLCompositeType): CacheAnnotation {\n  if (t.astNode) {\n    const hint = cacheAnnotationFromDirectives(t.astNode.directives);\n    if (hint) {\n      return hint;\n    }\n  }\n  if (t.extensionASTNodes) {\n    for (const node of t.extensionASTNodes) {\n      const hint = cacheAnnotationFromDirectives(node.directives);\n      if (hint) {\n        return hint;\n      }\n    }\n  }\n  return {};\n}\n\nfunction cacheAnnotationFromField(\n  field: GraphQLField<unknown, unknown>,\n): CacheAnnotation {\n  if (field.astNode) {\n    const hint = cacheAnnotationFromDirectives(field.astNode.directives);\n    if (hint) {\n      return hint;\n    }\n  }\n  return {};\n}\n\nfunction isRestricted(hint: CacheHint) {\n  return hint.maxAge !== undefined || hint.scope !== undefined;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3876, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3881, "column": 0}, "map": {"version":3,"file":"traceTreeBuilder.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/plugin/traceTreeBuilder.ts"],"sourcesContent":["// This class is a helper for ApolloServerPluginUsageReporting and\n// ApolloServerPluginInlineTrace.\nimport {\n  GraphQLError,\n  type GraphQLResolveInfo,\n  type ResponsePath,\n} from 'graphql';\nimport { Trace, google } from '@apollo/usage-reporting-protobuf';\nimport type { SendErrorsOptions } from './usageReporting';\nimport { UnreachableCaseError } from '../utils/UnreachableCaseError.js';\n\nfunction internalError(message: string) {\n  return new Error(`[internal apollo-server error] ${message}`);\n}\n\nexport class TraceTreeBuilder {\n  private rootNode = new Trace.Node();\n  public trace = new Trace({\n    root: this.rootNode,\n    // By default, each trace counts as one operation for the sake of field\n    // execution counts. If we end up calling the fieldLevelInstrumentation\n    // callback (once we've successfully resolved the operation) then we\n    // may set this to a higher number; but we'll start it at 1 so that traces\n    // that don't successfully resolve the operation (eg parse failures) or\n    // where we don't call the callback because a plugin set captureTraces to\n    // true have a reasonable default.\n    fieldExecutionWeight: 1,\n  });\n  public startHrTime?: [number, number];\n  private stopped = false;\n  private nodes = new Map<string, Trace.Node>([\n    [responsePathAsString(), this.rootNode],\n  ]);\n  private readonly transformError:\n    | ((err: GraphQLError) => GraphQLError | null)\n    | null;\n\n  public constructor(options: {\n    maskedBy: string;\n    sendErrors?: SendErrorsOptions;\n  }) {\n    const { sendErrors, maskedBy } = options;\n    if (!sendErrors || 'masked' in sendErrors) {\n      this.transformError = () =>\n        new GraphQLError('<masked>', {\n          extensions: { maskedBy },\n        });\n    } else if ('transform' in sendErrors) {\n      this.transformError = sendErrors.transform;\n    } else if ('unmodified' in sendErrors) {\n      this.transformError = null;\n    } else {\n      throw new UnreachableCaseError(sendErrors);\n    }\n  }\n\n  public startTiming() {\n    if (this.startHrTime) {\n      throw internalError('startTiming called twice!');\n    }\n    if (this.stopped) {\n      throw internalError('startTiming called after stopTiming!');\n    }\n    this.trace.startTime = dateToProtoTimestamp(new Date());\n    this.startHrTime = process.hrtime();\n  }\n\n  public stopTiming() {\n    if (!this.startHrTime) {\n      throw internalError('stopTiming called before startTiming!');\n    }\n    if (this.stopped) {\n      throw internalError('stopTiming called twice!');\n    }\n\n    this.trace.durationNs = durationHrTimeToNanos(\n      process.hrtime(this.startHrTime),\n    );\n    this.trace.endTime = dateToProtoTimestamp(new Date());\n    this.stopped = true;\n  }\n\n  public willResolveField(info: GraphQLResolveInfo): () => void {\n    if (!this.startHrTime) {\n      throw internalError('willResolveField called before startTiming!');\n    }\n    if (this.stopped) {\n      // We've been stopped, which means execution is done... and yet we're\n      // still resolving more fields? How can that be? Shouldn't we throw an\n      // error or something?\n      //\n      // Well... we used to do exactly that. But this \"shouldn't happen\" error\n      // showed up in practice! Turns out that graphql-js can actually continue\n      // to execute more fields indefinitely long after `execute()` resolves!\n      // That's because parallelism on a selection set is implemented using\n      // `Promise.all`, and as soon as one of its arguments (ie, one field)\n      // throws an error, the combined Promise resolves, but there's no\n      // \"cancellation\" of the Promises that are the other arguments to\n      // `Promise.all`. So the code contributing to those Promises keeps on\n      // chugging away indefinitely.\n      //\n      // Concrete example: lets say you have\n      //\n      //    { x y { ARBITRARY_SELECTION_SET } }\n      //\n      // where x has a non-null return type, and x and y both have resolvers\n      // that return Promises. And lets say that x returns a Promise that\n      // rejects (or resolves to null). What this means is that were going to\n      // eventually end up with `data: null` (nothing under y will actually\n      // matter), but graphql-js execution will continue running whatever is\n      // under ARBITRARY_SELECTION_SET without any sort of short circuiting. In\n      // fact, the Promise returned from execute itself can happily resolve\n      // while execution is still chugging away on an arbitrary amount of fields\n      // under that ARBITRARY_SELECTION_SET. Theres no way to detect from the\n      // outside \"all the execution related to this operation is done\", nor to\n      // \"short-circuit\" execution so that it stops going.\n      //\n      // So, um. We will record any field whose execution we manage to observe\n      // before we \"stop\" the TraceTreeBuilder (whether it is one that actually\n      // ends up in the response or whether it gets thrown away due to null\n      // bubbling), but if we get any more fields afterwards, we just ignore\n      // them rather than throwing a confusing error.\n      //\n      // (That said, the error we used to throw here generally was hidden\n      // anyway, for the same reason: it comes from a branch of execution that\n      // ends up not being included in the response. But\n      // https://github.com/graphql/graphql-js/pull/3529 means that this\n      // sometimes crashed execution anyway. Our error never caught any actual\n      // problematic cases, so keeping it around doesn't really help.)\n      return () => {};\n    }\n\n    const path = info.path;\n    const node = this.newNode(path);\n    node.type = info.returnType.toString();\n    node.parentType = info.parentType.toString();\n    node.startTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));\n    if (typeof path.key === 'string' && path.key !== info.fieldName) {\n      // This field was aliased; send the original field name too (for FieldStats).\n      node.originalFieldName = info.fieldName;\n    }\n\n    return () => {\n      node.endTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));\n    };\n  }\n\n  public didEncounterErrors(errors: readonly GraphQLError[]) {\n    errors.forEach((err) => {\n      // This is an error from a federated service. We will already be reporting\n      // it in the nested Trace in the query plan.\n      //\n      // XXX This probably shouldn't skip query or validation errors, which are\n      //      not in nested Traces because format() isn't called in this case! Or\n      //      maybe format() should be called in that case?\n      if (err.extensions?.serviceName) {\n        return;\n      }\n\n      // In terms of reporting, errors can be re-written by the user by\n      // utilizing the `transformError` parameter.  This allows changing\n      // the message or stack to remove potentially sensitive information.\n      // Returning `null` will result in the error not being reported at all.\n      const errorForReporting = this.transformAndNormalizeError(err);\n\n      if (errorForReporting === null) {\n        return;\n      }\n\n      this.addProtobufError(\n        errorForReporting.path,\n        errorToProtobufError(errorForReporting),\n      );\n    });\n  }\n\n  private addProtobufError(\n    path: ReadonlyArray<string | number> | undefined,\n    error: Trace.Error,\n  ) {\n    if (!this.startHrTime) {\n      throw internalError('addProtobufError called before startTiming!');\n    }\n    if (this.stopped) {\n      throw internalError('addProtobufError called after stopTiming!');\n    }\n\n    // By default, put errors on the root node.\n    let node = this.rootNode;\n    // If a non-GraphQLError Error sneaks in here somehow with a non-array\n    // path, don't crash.\n    if (Array.isArray(path)) {\n      const specificNode = this.nodes.get(path.join('.'));\n      if (specificNode) {\n        node = specificNode;\n      } else {\n        const responsePath = responsePathFromArray(path, this.rootNode);\n        if (!responsePath) {\n          throw internalError('addProtobufError called with invalid path!');\n        }\n        node = this.newNode(responsePath);\n      }\n    }\n\n    node.error.push(error);\n  }\n\n  private newNode(path: ResponsePath): Trace.Node {\n    const node = new Trace.Node();\n    const id = path.key;\n    if (typeof id === 'number') {\n      node.index = id;\n    } else {\n      node.responseName = id;\n    }\n    this.nodes.set(responsePathAsString(path), node);\n    const parentNode = this.ensureParentNode(path);\n    parentNode.child.push(node);\n    return node;\n  }\n\n  private ensureParentNode(path: ResponsePath): Trace.Node {\n    const parentPath = responsePathAsString(path.prev);\n    const parentNode = this.nodes.get(parentPath);\n    if (parentNode) {\n      return parentNode;\n    }\n    // Because we set up the root path when creating this.nodes, we now know\n    // that path.prev isn't undefined.\n    return this.newNode(path.prev!);\n  }\n\n  private transformAndNormalizeError(err: GraphQLError): GraphQLError | null {\n    if (this.transformError) {\n      // Before passing the error to the user-provided `transformError` function,\n      // we'll make a shadow copy of the error so the user is free to change\n      // the object as they see fit.\n\n      // At this stage, this error is only for the purposes of reporting, but\n      // this is even more important since this is still a reference to the\n      // original error object and changing it would also change the error which\n      // is returned in the response to the client.\n\n      // For the clone, we'll create a new object which utilizes the exact same\n      // prototype of the error being reported.\n      const clonedError = Object.assign(\n        Object.create(Object.getPrototypeOf(err)),\n        err,\n      );\n\n      const rewrittenError = this.transformError(clonedError);\n\n      // Returning an explicit `null` means the user is requesting that the error\n      // not be reported to Apollo.\n      if (rewrittenError === null) {\n        return null;\n      }\n\n      // We don't want users to be inadvertently not reporting errors, so if\n      // they haven't returned an explicit `GraphQLError` (or `null`, handled\n      // above), then we'll report the error as usual.\n      if (!(rewrittenError instanceof GraphQLError)) {\n        return err;\n      }\n\n      // We only allow transformError to change the message and extensions of the\n      // error; we keep everything else the same. That way people don't have to\n      // do extra work to keep the error on the same trace node. We also keep\n      // extensions the same if it isn't explicitly changed (to, eg, {}). (Note\n      // that many of the fields of GraphQLError are not enumerable and won't\n      // show up in the trace (even in the json field) anyway.)\n      return new GraphQLError(rewrittenError.message, {\n        nodes: err.nodes,\n        source: err.source,\n        positions: err.positions,\n        path: err.path,\n        originalError: err.originalError,\n        extensions: rewrittenError.extensions || err.extensions,\n      });\n    }\n    return err;\n  }\n}\n\n// Converts an hrtime array (as returned from process.hrtime) to nanoseconds.\n//\n// ONLY CALL THIS ON VALUES REPRESENTING DELTAS, NOT ON THE RAW RETURN VALUE\n// FROM process.hrtime() WITH NO ARGUMENTS.\n//\n// The entire point of the hrtime data structure is that the JavaScript Number\n// type can't represent all int64 values without loss of precision:\n// Number.MAX_SAFE_INTEGER nanoseconds is about 104 days. Calling this function\n// on a duration that represents a value less than 104 days is fine. Calling\n// this function on an absolute time (which is generally roughly time since\n// system boot) is not a good idea.\n//\n// XXX We should probably use google.protobuf.Duration on the wire instead of\n// ever trying to store durations in a single number.\nfunction durationHrTimeToNanos(hrtime: [number, number]) {\n  return hrtime[0] * 1e9 + hrtime[1];\n}\n\n// Convert from the linked-list ResponsePath format to a dot-joined\n// string. Includes the full path (field names and array indices).\nfunction responsePathAsString(p?: ResponsePath): string {\n  if (p === undefined) {\n    return '';\n  }\n\n  // A previous implementation used `responsePathAsArray` from `graphql-js/execution`,\n  // however, that employed an approach that created new arrays unnecessarily.\n  let res = String(p.key);\n\n  while ((p = p.prev) !== undefined) {\n    res = `${p.key}.${res}`;\n  }\n\n  return res;\n}\n\nfunction responsePathFromArray(\n  path: ReadonlyArray<string | number>,\n  node: Trace.Node,\n): ResponsePath | undefined {\n  let responsePath: ResponsePath | undefined;\n  let nodePtr: Trace.INode | undefined = node;\n  for (const key of path) {\n    nodePtr = nodePtr?.child?.find((child) => child.responseName === key);\n    responsePath = {\n      key,\n      prev: responsePath,\n      typename: nodePtr?.type ?? undefined,\n    };\n  }\n  return responsePath;\n}\n\nfunction errorToProtobufError(error: GraphQLError): Trace.Error {\n  return new Trace.Error({\n    message: error.message,\n    location: (error.locations || []).map(\n      ({ line, column }) => new Trace.Location({ line, column }),\n    ),\n    json: JSON.stringify(error),\n  });\n}\n\n// Converts a JS Date into a Timestamp.\nexport function dateToProtoTimestamp(date: Date): google.protobuf.Timestamp {\n  const totalMillis = +date;\n  const millis = totalMillis % 1000;\n  return new google.protobuf.Timestamp({\n    seconds: (totalMillis - millis) / 1000,\n    nanos: millis * 1e6,\n  });\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4084, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4089, "column": 0}, "map": {"version":3,"file":"iterateOverTrace.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/plugin/usageReporting/iterateOverTrace.ts"],"sourcesContent":["import type { Trace } from '@apollo/usage-reporting-protobuf';\n\n/**\n * Iterates over the entire trace, calling `f` on each Trace.Node found. It\n * looks under the \"root\" node as well as any inside the query plan. If any `f`\n * returns true, it stops walking the tree.\n *\n * Each call to `f` will receive an object that implements ResponseNamePath. If\n * `includePath` is true, `f` can call `toArray()` on it to convert the\n * linked-list representation to an array of the response name (field name)\n * nodes that you navigate to get to the node (including a \"service:subgraph\"\n * top-level node if this is a federated trace). Note that we don't add anything\n * to the path for index (list element) nodes. This is because the only use case\n * we have (error path statistics) does not care about list indexes (it's not\n * that interesting to know that sometimes an error was at foo.3.bar and\n * sometimes foo.5.bar, vs just generally foo.bar).\n *\n * If `includePath` is false, we don't bother to build up the linked lists, and\n * calling `toArray()` will throw.\n */\nexport function iterateOverTrace(\n  trace: Trace,\n  f: (node: Trace.INode, path: ResponseNamePath) => boolean,\n  includePath: boolean,\n) {\n  const rootPath = includePath\n    ? new RootCollectingPathsResponseNamePath()\n    : notCollectingPathsResponseNamePath;\n  if (trace.root) {\n    if (iterateOverTraceNode(trace.root, rootPath, f)) return;\n  }\n\n  if (trace.queryPlan) {\n    if (iterateOverQueryPlan(trace.queryPlan, rootPath, f)) return;\n  }\n}\n\n// Helper for iterateOverTrace; returns true to stop the overall walk.\nfunction iterateOverQueryPlan(\n  node: Trace.IQueryPlanNode,\n  rootPath: ResponseNamePath,\n  f: (node: Trace.INode, path: ResponseNamePath) => boolean,\n): boolean {\n  if (!node) return false;\n\n  if (node.fetch?.trace?.root && node.fetch.serviceName) {\n    return iterateOverTraceNode(\n      node.fetch.trace.root,\n      rootPath.child(`service:${node.fetch.serviceName}`),\n      f,\n    );\n  }\n  if (node.flatten?.node) {\n    return iterateOverQueryPlan(node.flatten.node, rootPath, f);\n  }\n  if (node.parallel?.nodes) {\n    // We want to stop as soon as some call returns true, which happens to be\n    // exactly what 'some' does.\n    return node.parallel.nodes.some((node) =>\n      iterateOverQueryPlan(node, rootPath, f),\n    );\n  }\n  if (node.sequence?.nodes) {\n    // We want to stop as soon as some call returns true, which happens to be\n    // exactly what 'some' does.\n    return node.sequence.nodes.some((node) =>\n      iterateOverQueryPlan(node, rootPath, f),\n    );\n  }\n\n  return false;\n}\n\n// Helper for iterateOverTrace; returns true to stop the overall walk.\nfunction iterateOverTraceNode(\n  node: Trace.INode,\n  path: ResponseNamePath,\n  f: (node: Trace.INode, path: ResponseNamePath) => boolean,\n): boolean {\n  // Invoke the function; if it returns true, don't descend and tell callers to\n  // stop walking.\n  if (f(node, path)) {\n    return true;\n  }\n\n  return (\n    // We want to stop as soon as some call returns true, which happens to be\n    // exactly what 'some' does.\n    node.child?.some((child) => {\n      const childPath = child.responseName\n        ? path.child(child.responseName)\n        : path;\n      return iterateOverTraceNode(child, childPath, f);\n    }) ?? false\n  );\n}\n\nexport interface ResponseNamePath {\n  toArray(): string[];\n  child(responseName: string): ResponseNamePath;\n}\n\nconst notCollectingPathsResponseNamePath: ResponseNamePath = {\n  toArray() {\n    throw Error('not collecting paths!');\n  },\n  child() {\n    return this;\n  },\n};\n\ntype CollectingPathsResponseNamePath =\n  | RootCollectingPathsResponseNamePath\n  | ChildCollectingPathsResponseNamePath;\nclass RootCollectingPathsResponseNamePath implements ResponseNamePath {\n  toArray() {\n    return [];\n  }\n  child(responseName: string) {\n    return new ChildCollectingPathsResponseNamePath(responseName, this);\n  }\n}\nclass ChildCollectingPathsResponseNamePath implements ResponseNamePath {\n  constructor(\n    readonly responseName: string,\n    readonly prev: CollectingPathsResponseNamePath,\n  ) {}\n  toArray() {\n    const out = [];\n    let curr: CollectingPathsResponseNamePath = this;\n    while (curr instanceof ChildCollectingPathsResponseNamePath) {\n      out.push(curr.responseName);\n      curr = curr.prev;\n    }\n    return out.reverse();\n  }\n  child(responseName: string) {\n    return new ChildCollectingPathsResponseNamePath(responseName, this);\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4163, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4168, "column": 0}, "map": {"version":3,"file":"durationHistogram.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/plugin/usageReporting/durationHistogram.ts"],"sourcesContent":["export interface DurationHistogramOptions {\n  initSize?: number;\n  buckets?: number[];\n}\nexport class DurationHistogram {\n  // Note that it's legal for the values in \"buckets\" to be non-integers; they\n  // will be floored by toArray (which is called by the protobuf encoder).\n  // (We take advantage of this for field latencies specifically, because\n  // the ability to return a non-1 weight from fieldLevelInstrumentation\n  // means we want to build up our histograms as floating-point rather than\n  // rounding after every operation.)\n  private readonly buckets: number[];\n  static readonly BUCKET_COUNT = 384;\n  static readonly EXPONENT_LOG = Math.log(1.1);\n\n  toArray(): number[] {\n    let bufferedZeroes = 0;\n    const outputArray: number[] = [];\n\n    for (const value of this.buckets) {\n      if (value === 0) {\n        bufferedZeroes++;\n      } else {\n        if (bufferedZeroes === 1) {\n          outputArray.push(0);\n        } else if (bufferedZeroes !== 0) {\n          outputArray.push(-bufferedZeroes);\n        }\n        outputArray.push(Math.floor(value));\n        bufferedZeroes = 0;\n      }\n    }\n    return outputArray;\n  }\n\n  static durationToBucket(durationNs: number): number {\n    const log = Math.log(durationNs / 1000.0);\n    const unboundedBucket = Math.ceil(log / DurationHistogram.EXPONENT_LOG);\n\n    // Compare <= 0 to catch -0 and -infinity\n    return unboundedBucket <= 0 || Number.isNaN(unboundedBucket)\n      ? 0\n      : unboundedBucket >= DurationHistogram.BUCKET_COUNT\n        ? DurationHistogram.BUCKET_COUNT - 1\n        : unboundedBucket;\n  }\n\n  incrementDuration(durationNs: number, value = 1): DurationHistogram {\n    this.incrementBucket(DurationHistogram.durationToBucket(durationNs), value);\n    return this;\n  }\n\n  incrementBucket(bucket: number, value = 1) {\n    if (bucket >= DurationHistogram.BUCKET_COUNT) {\n      // Since we don't have fixed size arrays I'd rather throw the error manually\n      throw Error('Bucket is out of bounds of the buckets array');\n    }\n\n    // Extend the array if we haven't gotten it long enough to handle the new bucket\n    if (bucket >= this.buckets.length) {\n      const oldLength = this.buckets.length;\n      this.buckets.length = bucket + 1;\n      this.buckets.fill(0, oldLength);\n    }\n\n    this.buckets[bucket] += value;\n  }\n\n  combine(otherHistogram: DurationHistogram) {\n    for (let i = 0; i < otherHistogram.buckets.length; i++) {\n      this.incrementBucket(i, otherHistogram.buckets[i]);\n    }\n  }\n\n  constructor(options?: DurationHistogramOptions) {\n    const initSize = options?.initSize || 74;\n    const buckets = options?.buckets;\n\n    const arrayInitSize = Math.max(buckets?.length || 0, initSize);\n\n    this.buckets = Array<number>(arrayInitSize).fill(0);\n\n    if (buckets) {\n      buckets.forEach((val, index) => (this.buckets[index] = val));\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4230, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4235, "column": 0}, "map": {"version":3,"file":"defaultSendOperationsAsTrace.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/plugin/usageReporting/defaultSendOperationsAsTrace.ts"],"sourcesContent":["import LRUCache from 'lru-cache';\nimport type { Trace } from '@apollo/usage-reporting-protobuf';\nimport { iterateOverTrace } from './iterateOverTrace.js';\nimport { DurationHistogram } from './durationHistogram.js';\n\nexport function defaultSendOperationsAsTrace() {\n  // We keep an LRU cache mapping from a trace key (which consists of the\n  // operation as defined by statsReportKey, the rough duration of the\n  // operation, what minute the operation ended at, etc) to `true` if we've seen\n  // it recently. We actually split this into one cache per minute so we can\n  // throw away a full minute's worth of cache at once; we keep only the last\n  // three minutes.\n  // Note that if a trace is over a certain size, we will always send it as\n  // stats. We check this within the addTrace function of the OurReport class so\n  // that we don't have to encode these large traces twice.\n  const cache = new LRUCache<string, true>({\n    // 3MiB limit, very much approximately since we can't be sure how V8 might\n    // be storing these strings internally. Though this should be enough to\n    // store a fair amount of trace keys.\n\n    // A future version of this might expose some\n    // configuration option to grow the cache, but ideally, we could do that\n    // dynamically based on the resources available to the server, and not add\n    // more configuration surface area. Hopefully the warning message will allow\n    // us to evaluate the need with more validated input from those that receive\n    // it.\n    maxSize: Math.pow(2, 20),\n    sizeCalculation: (_val, key) => {\n      return (key && Buffer.byteLength(key)) || 0;\n    },\n  });\n\n  return (trace: Trace, statsReportKey: string): boolean => {\n    const endTimeSeconds = trace.endTime?.seconds;\n    if (endTimeSeconds == null) {\n      throw Error('programming error: endTime not set on trace');\n    }\n\n    const hasErrors = traceHasErrors(trace);\n    const cacheKey = JSON.stringify([\n      statsReportKey,\n      DurationHistogram.durationToBucket(trace.durationNs),\n      // What minute it started at\n      Math.floor(endTimeSeconds / 60),\n      // If the trace has an error, send one errored trace per 5 second interval\n      // instead of the normal minutely bucket a non-errored trace takes.\n      hasErrors ? Math.floor(endTimeSeconds / 5) : '',\n    ]);\n\n    // If we've already seen something roughly like this, don't send as a trace.\n    if (cache.get(cacheKey)) {\n      return false;\n    }\n\n    cache.set(cacheKey, true);\n    return true;\n  };\n}\n\n// Returns true if any node on the trace has errors. (If this ends up being a\n// hot spot, we can precalculate it in TraceTreeBuilder.)\nfunction traceHasErrors(trace: Trace): boolean {\n  let hasErrors = false;\n\n  function traceNodeStats(node: Trace.INode): boolean {\n    if ((node.error?.length ?? 0) > 0) {\n      hasErrors = true;\n    }\n    return hasErrors;\n  }\n\n  iterateOverTrace(trace, traceNodeStats, false);\n  return hasErrors;\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA,MAAA,cAAA,sCAAiC;AAEjC,MAAA,yDAAyD;AACzD,MAAA,2DAA2D;AAE3D,SAAgB,4BAA4B;IAU1C,MAAM,KAAK,GAAG,IAAI,YAAA,OAAQ,CAAe;QAWvC,OAAO,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC;QACxB,eAAe,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,EAAE;YAC7B,OAAO,AAAC,GAAG,IAAI,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAI,CAAC,CAAC;QAC9C,CAAC;KACF,CAAC,CAAC;IAEH,OAAO,CAAC,KAAY,EAAE,cAAsB,EAAW,EAAE;QACvD,MAAM,cAAc,GAAG,KAAK,CAAC,OAAO,EAAE,OAAO,CAAC;QAC9C,IAAI,cAAc,IAAI,IAAI,EAAE,CAAC;YAC3B,MAAM,KAAK,CAAC,6CAA6C,CAAC,CAAC;QAC7D,CAAC;QAED,MAAM,SAAS,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC;QACxC,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC;YAC9B,cAAc;YACd,uBAAA,iBAAiB,CAAC,gBAAgB,CAAC,KAAK,CAAC,UAAU,CAAC;YAEpD,IAAI,CAAC,KAAK,CAAC,cAAc,GAAG,EAAE,CAAC;YAG/B,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,cAAc,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;SAChD,CAAC,CAAC;QAGH,IAAI,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC;YACxB,OAAO,KAAK,CAAC;QACf,CAAC;QAED,KAAK,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;QAC1B,OAAO,IAAI,CAAC;IACd,CAAC,CAAC;AACJ,CAAC;AApDD,QAAA,4BAAA,GAAA,6BAoDC;AAID,SAAS,cAAc,CAAC,KAAY;IAClC,IAAI,SAAS,GAAG,KAAK,CAAC;IAEtB,SAAS,cAAc,CAAC,IAAiB;QACvC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,MAAM,IAAI,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC;YAClC,SAAS,GAAG,IAAI,CAAC;QACnB,CAAC;QACD,OAAO,SAAS,CAAC;IACnB,CAAC;IAED,CAAA,GAAA,sBAAA,gBAAgB,EAAC,KAAK,EAAE,cAAc,EAAE,KAAK,CAAC,CAAC;IAC/C,OAAO,SAAS,CAAC;AACnB,CAAC","ignoreList":[0]}},
    {"offset": {"line": 4286, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4291, "column": 0}, "map": {"version":3,"file":"operationDerivedDataCache.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/plugin/usageReporting/operationDerivedDataCache.ts"],"sourcesContent":["import type { Logger } from '@apollo/utils.logger';\nimport type { ReferencedFieldsByType } from '@apollo/utils.usagereporting';\nimport LRUCache from 'lru-cache';\n\nexport interface OperationDerivedData {\n  signature: string;\n  referencedFieldsByType: ReferencedFieldsByType;\n}\n\nexport function createOperationDerivedDataCache({\n  logger,\n}: {\n  logger: Logger;\n}): LRUCache<string, OperationDerivedData> {\n  let lastWarn: Date;\n  let lastDisposals = 0;\n  return new LRUCache<string, OperationDerivedData>({\n    // Calculate the length of cache objects by the JSON.stringify byteLength.\n    sizeCalculation(obj) {\n      return Buffer.byteLength(JSON.stringify(obj), 'utf8');\n    },\n    // 10MiB limit, very much approximately since we can't be sure how V8 might\n    // be storing this data internally. Though this should be enough to store a\n    // fair amount of operation data, depending on their overall complexity. A\n    // future version of this might expose some configuration option to grow the\n    // cache, but ideally, we could do that dynamically based on the resources\n    // available to the server, and not add more configuration surface area.\n    // Hopefully the warning message will allow us to evaluate the need with\n    // more validated input from those that receive it.\n    maxSize: Math.pow(2, 20) * 10,\n    dispose() {\n      // Count the number of disposals between warning messages.\n      lastDisposals++;\n\n      // Only show a message warning about the high turnover every 60 seconds.\n      if (!lastWarn || new Date().getTime() - lastWarn.getTime() > 60000) {\n        // Log the time that we last displayed the message.\n        lastWarn = new Date();\n        logger.warn(\n          [\n            'This server is processing a high number of unique operations.  ',\n            `A total of ${lastDisposals} records have been `,\n            'ejected from the ApolloServerPluginUsageReporting signature cache in the past ',\n            'interval.  If you see this warning frequently, please open an ',\n            'issue on the Apollo Server repository.',\n          ].join(''),\n        );\n\n        // Reset the disposal counter for the next message interval.\n        lastDisposals = 0;\n      }\n    },\n  });\n}\n\nexport function operationDerivedDataCacheKey(\n  queryHash: string,\n  operationName: string,\n) {\n  return `${queryHash}${operationName && ':' + operationName}`;\n}\n"],"names":[],"mappings":";;;;;;;;;;AAEA,MAAA,cAAA,sCAAiC;AAOjC,SAAgB,+BAA+B,CAAC,EAC9C,MAAM,EAGP;IACC,IAAI,QAAc,CAAC;IACnB,IAAI,aAAa,GAAG,CAAC,CAAC;IACtB,OAAO,IAAI,YAAA,OAAQ,CAA+B;QAEhD,eAAe,EAAC,GAAG;YACjB,OAAO,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,MAAM,CAAC,CAAC;QACxD,CAAC;QASD,OAAO,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,EAAE;QAC7B,OAAO;YAEL,aAAa,EAAE,CAAC;YAGhB,IAAI,CAAC,QAAQ,IAAI,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,GAAG,QAAQ,CAAC,OAAO,EAAE,GAAG,KAAK,EAAE,CAAC;gBAEnE,QAAQ,GAAG,IAAI,IAAI,EAAE,CAAC;gBACtB,MAAM,CAAC,IAAI,CACT;oBACE,iEAAiE;oBACjE,CAAA,WAAA,EAAc,aAAa,CAAA,mBAAA,CAAqB;oBAChD,gFAAgF;oBAChF,gEAAgE;oBAChE,wCAAwC;iBACzC,CAAC,IAAI,CAAC,EAAE,CAAC,CACX,CAAC;gBAGF,aAAa,GAAG,CAAC,CAAC;YACpB,CAAC;QACH,CAAC;KACF,CAAC,CAAC;AACL,CAAC;AA5CD,QAAA,+BAAA,GAAA,gCA4CC;AAED,SAAgB,4BAA4B,CAC1C,SAAiB,EACjB,aAAqB;IAErB,OAAO,GAAG,SAAS,GAAG,aAAa,IAAI,GAAG,GAAG,aAAa,EAAE,CAAC;AAC/D,CAAC;AALD,QAAA,4BAAA,GAAA,6BAKC","ignoreList":[0]}},
    {"offset": {"line": 4331, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4336, "column": 0}, "map": {"version":3,"file":"stats.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/plugin/usageReporting/stats.ts"],"sourcesContent":["import type { NonFtv1ErrorPath } from '@apollo/server-gateway-interface';\nimport {\n  type google,\n  type IContextualizedStats,\n  type IFieldStat,\n  type IPathErrorStats,\n  type IQueryLatencyStats,\n  type IReport,\n  type IStatsContext,\n  type ITracesAndStats,\n  type ITypeStat,\n  type ReportHeader,\n  Trace,\n} from '@apollo/usage-reporting-protobuf';\nimport type { ReferencedFieldsByType } from '@apollo/utils.usagereporting';\nimport { DurationHistogram } from './durationHistogram.js';\nimport { iterateOverTrace, type ResponseNamePath } from './iterateOverTrace.js';\n\n// protobuf.js exports both a class and an interface (starting with I) for each\n// message type. The class is what it produces when it decodes the message; the\n// interface is what is accepted as input. We build up our messages using custom\n// types implementing the interfaces, so that we can take advantage of the\n// js_use_toArray option we added to our protobuf.js fork which allows us to use\n// classes like DurationHistogram to generate repeated fields. We end up\n// re-creating most of the report structure as custom classes (starting with\n// \"Our\"). TypeScript validates that we've properly listed all of the message\n// fields with the appropriate types (we use `Required` to ensure we implement\n// all message fields). Using our own classes has other advantages, like being\n// able to specify that nested messages are instances of the same class rather\n// than the interface type and thus that they have non-null fields (because the\n// interface type allows all fields to be optional, even though the protobuf\n// format doesn't differentiate between missing and falsey).\n\nexport class SizeEstimator {\n  bytes = 0;\n}\nexport class OurReport implements Required<IReport> {\n  // Apollo Server includes each operation either as aggregated stats or as a\n  // trace, but not both. Other reporting agents such as Apollo Router include\n  // all operations in stats (even those that are sent as traces), and they set\n  // this flag to true.\n  tracesPreAggregated = false;\n\n  constructor(readonly header: ReportHeader) {}\n  readonly tracesPerQuery: Record<string, OurTracesAndStats> =\n    Object.create(null);\n  endTime: google.protobuf.ITimestamp | null = null;\n  operationCount = 0;\n  // A rough estimate of the number of bytes currently in the report. We start\n  // at zero and don't count `header` and `endTime`, which have the same size\n  // for every report. This really is a rough estimate, so we don't stress too\n  // much about counting bytes for the tags and string/message lengths, etc:\n  // we mostly just count the lengths of strings plus some estimates for the\n  // messages with a bunch of numbers in them.\n  //\n  // We store this in a class so we can pass it down as a reference to other\n  // methods which increment it.\n  readonly sizeEstimator = new SizeEstimator();\n\n  ensureCountsAreIntegers() {\n    for (const tracesAndStats of Object.values(this.tracesPerQuery)) {\n      tracesAndStats.ensureCountsAreIntegers();\n    }\n  }\n\n  addTrace({\n    statsReportKey,\n    trace,\n    asTrace,\n    referencedFieldsByType,\n    // The max size a trace can be before it is sent as stats. Note that the\n    // Apollo reporting ingress server will never store any traces over 10mb\n    // anyway. They will still be converted to stats as we would do here.\n    maxTraceBytes = 10 * 1024 * 1024,\n    nonFtv1ErrorPaths,\n  }: {\n    statsReportKey: string;\n    trace: Trace;\n    asTrace: boolean;\n    referencedFieldsByType: ReferencedFieldsByType;\n    maxTraceBytes?: number;\n    nonFtv1ErrorPaths: NonFtv1ErrorPath[];\n  }) {\n    const tracesAndStats = this.getTracesAndStats({\n      statsReportKey,\n      referencedFieldsByType,\n    });\n    if (asTrace) {\n      const encodedTrace = Trace.encode(trace).finish();\n\n      if (!isNaN(maxTraceBytes) && encodedTrace.length > maxTraceBytes) {\n        tracesAndStats.statsWithContext.addTrace(\n          trace,\n          this.sizeEstimator,\n          nonFtv1ErrorPaths,\n        );\n      } else {\n        tracesAndStats.trace.push(encodedTrace);\n        this.sizeEstimator.bytes += 2 + encodedTrace.length;\n      }\n    } else {\n      tracesAndStats.statsWithContext.addTrace(\n        trace,\n        this.sizeEstimator,\n        nonFtv1ErrorPaths,\n      );\n    }\n  }\n\n  private getTracesAndStats({\n    statsReportKey,\n    referencedFieldsByType,\n  }: {\n    statsReportKey: string;\n    referencedFieldsByType: ReferencedFieldsByType;\n  }) {\n    const existing = this.tracesPerQuery[statsReportKey];\n    if (existing) {\n      return existing;\n    }\n    this.sizeEstimator.bytes += estimatedBytesForString(statsReportKey);\n\n    // Update the size estimator for the referenced field structure.\n    for (const [typeName, referencedFieldsForType] of Object.entries(\n      referencedFieldsByType,\n    )) {\n      // Two bytes each for the map entry and for the ReferencedFieldsForType,\n      // and for the isInterface bool if it's set.\n      this.sizeEstimator.bytes += 2 + 2;\n      if (referencedFieldsForType.isInterface) {\n        this.sizeEstimator.bytes += 2;\n      }\n      this.sizeEstimator.bytes += estimatedBytesForString(typeName);\n      for (const fieldName of referencedFieldsForType.fieldNames) {\n        this.sizeEstimator.bytes += estimatedBytesForString(fieldName);\n      }\n    }\n\n    // Include the referenced fields map in the report. (In an ideal world we\n    // could have a slightly more sophisticated protocol and ingestion pipeline\n    // that allowed us to only have to send this data once for each\n    // schema/operation pair.)\n    return (this.tracesPerQuery[statsReportKey] = new OurTracesAndStats(\n      referencedFieldsByType,\n    ));\n  }\n}\n\nclass OurTracesAndStats implements Required<ITracesAndStats> {\n  constructor(readonly referencedFieldsByType: ReferencedFieldsByType) {}\n  readonly trace: Uint8Array[] = [];\n  readonly statsWithContext = new StatsByContext();\n  readonly internalTracesContributingToStats: Uint8Array[] = [];\n\n  ensureCountsAreIntegers() {\n    this.statsWithContext.ensureCountsAreIntegers();\n  }\n}\n\nclass StatsByContext {\n  readonly map: { [k: string]: OurContextualizedStats } = Object.create(null);\n\n  /**\n   * This function is used by the protobuf generator to convert this map into\n   * an array of contextualized stats to serialize\n   */\n  toArray(): IContextualizedStats[] {\n    return Object.values(this.map);\n  }\n\n  ensureCountsAreIntegers() {\n    for (const contextualizedStats of Object.values(this.map)) {\n      contextualizedStats.ensureCountsAreIntegers();\n    }\n  }\n\n  addTrace(\n    trace: Trace,\n    sizeEstimator: SizeEstimator,\n    nonFtv1ErrorPaths: NonFtv1ErrorPath[],\n  ) {\n    this.getContextualizedStats(trace, sizeEstimator).addTrace(\n      trace,\n      sizeEstimator,\n      nonFtv1ErrorPaths,\n    );\n  }\n\n  private getContextualizedStats(\n    trace: Trace,\n    sizeEstimator: SizeEstimator,\n  ): OurContextualizedStats {\n    const statsContext: IStatsContext = {\n      clientName: trace.clientName,\n      clientVersion: trace.clientVersion,\n    };\n    const statsContextKey = JSON.stringify(statsContext);\n\n    const existing = this.map[statsContextKey];\n    if (existing) {\n      return existing;\n    }\n    // Adding a ContextualizedStats means adding a StatsContext plus a\n    // QueryLatencyStats. Let's guess about 20 bytes for a QueryLatencyStats;\n    // it'll be more if more features are used (like cache, APQ, etc).\n    sizeEstimator.bytes +=\n      20 +\n      estimatedBytesForString(trace.clientName) +\n      estimatedBytesForString(trace.clientVersion);\n    const contextualizedStats = new OurContextualizedStats(statsContext);\n    this.map[statsContextKey] = contextualizedStats;\n    return contextualizedStats;\n  }\n}\n\nexport class OurContextualizedStats implements Required<IContextualizedStats> {\n  queryLatencyStats = new OurQueryLatencyStats();\n  perTypeStat: { [k: string]: OurTypeStat } = Object.create(null);\n\n  constructor(readonly context: IStatsContext) {}\n\n  ensureCountsAreIntegers() {\n    for (const typeStat of Object.values(this.perTypeStat)) {\n      typeStat.ensureCountsAreIntegers();\n    }\n  }\n\n  // Extract statistics from the trace, and increment the estimated report size.\n  // We only add to the estimate when adding whole sub-messages. If it really\n  // mattered, we could do a lot more careful things like incrementing it\n  // whenever a numeric field on queryLatencyStats gets incremented over 0.\n  addTrace(\n    trace: Trace,\n    sizeEstimator: SizeEstimator,\n    nonFtv1ErrorPaths: NonFtv1ErrorPath[] = [],\n  ) {\n    const { fieldExecutionWeight } = trace;\n    if (!fieldExecutionWeight) {\n      this.queryLatencyStats.requestsWithoutFieldInstrumentation++;\n    }\n\n    this.queryLatencyStats.requestCount++;\n    if (trace.fullQueryCacheHit) {\n      this.queryLatencyStats.cacheLatencyCount.incrementDuration(\n        trace.durationNs,\n      );\n      this.queryLatencyStats.cacheHits++;\n    } else {\n      this.queryLatencyStats.latencyCount.incrementDuration(trace.durationNs);\n    }\n\n    // We only provide stats about cache TTLs on cache misses (ie, TTLs directly\n    // calculated by the backend), not for cache hits. This matches the\n    // behavior we've had for a while when converting traces into statistics\n    // in Studio's servers.\n    if (!trace.fullQueryCacheHit && trace.cachePolicy?.maxAgeNs != null) {\n      switch (trace.cachePolicy.scope) {\n        case Trace.CachePolicy.Scope.PRIVATE:\n          this.queryLatencyStats.privateCacheTtlCount.incrementDuration(\n            trace.cachePolicy.maxAgeNs,\n          );\n          break;\n        case Trace.CachePolicy.Scope.PUBLIC:\n          this.queryLatencyStats.publicCacheTtlCount.incrementDuration(\n            trace.cachePolicy.maxAgeNs,\n          );\n          break;\n      }\n    }\n\n    if (trace.persistedQueryHit) {\n      this.queryLatencyStats.persistedQueryHits++;\n    }\n    if (trace.persistedQueryRegister) {\n      this.queryLatencyStats.persistedQueryMisses++;\n    }\n\n    if (trace.forbiddenOperation) {\n      this.queryLatencyStats.forbiddenOperationCount++;\n    }\n    if (trace.registeredOperation) {\n      this.queryLatencyStats.registeredOperationCount++;\n    }\n\n    let hasError = false;\n\n    const errorPathStats = new Set<OurPathErrorStats>();\n\n    const traceNodeStats = (node: Trace.INode, path: ResponseNamePath) => {\n      // Generate error stats and error path information\n      if (node.error?.length) {\n        hasError = true;\n\n        let currPathErrorStats = this.queryLatencyStats.rootErrorStats;\n        path.toArray().forEach((subPath) => {\n          currPathErrorStats = currPathErrorStats.getChild(\n            subPath,\n            sizeEstimator,\n          );\n        });\n\n        errorPathStats.add(currPathErrorStats);\n        currPathErrorStats.errorsCount += node.error.length;\n      }\n\n      if (fieldExecutionWeight) {\n        // The actual field name behind the node; originalFieldName is set\n        // if an alias was used, otherwise responseName. (This is falsey for\n        // nodes that are not fields (root, array index, etc).)\n        const fieldName = node.originalFieldName || node.responseName;\n\n        // Protobuf doesn't really differentiate between \"unset\" and \"falsey\" so\n        // we're mostly actually checking that these things are non-empty string /\n        // non-zero numbers. The time fields represent the number of nanoseconds\n        // since the beginning of the entire trace, so let's pretend for the\n        // moment that it's plausible for a node to start or even end exactly when\n        // the trace started (ie, for the time values to be 0). This is unlikely\n        // in practice (everything should take at least 1ns). In practice we only\n        // write `type` and `parentType` on a Node when we write `startTime`, so\n        // the main thing we're looking out for by checking the time values is\n        // whether we somehow failed to write `endTime` at the end of the field;\n        // in this case, the `endTime >= startTime` check won't match.\n        if (\n          node.parentType &&\n          fieldName &&\n          node.type &&\n          node.endTime != null &&\n          node.startTime != null &&\n          node.endTime >= node.startTime\n        ) {\n          const typeStat = this.getTypeStat(node.parentType, sizeEstimator);\n\n          const fieldStat = typeStat.getFieldStat(\n            fieldName,\n            node.type,\n            sizeEstimator,\n          );\n\n          fieldStat.errorsCount += node.error?.length ?? 0;\n          fieldStat.observedExecutionCount++;\n          fieldStat.estimatedExecutionCount += fieldExecutionWeight;\n          // Note: this is actually counting the number of resolver calls for this\n          // field that had at least one error, not the number of overall GraphQL\n          // queries that had at least one error for this field. That doesn't seem\n          // to match the name, but it does match the other implementations of this\n          // logic.\n          fieldStat.requestsWithErrorsCount +=\n            (node.error?.length ?? 0) > 0 ? 1 : 0;\n          fieldStat.latencyCount.incrementDuration(\n            node.endTime - node.startTime,\n            // The latency histogram is always \"estimated\"; we don't track\n            // \"observed\" and \"estimated\" separately.\n            fieldExecutionWeight,\n          );\n        }\n      }\n\n      return false;\n    };\n\n    iterateOverTrace(trace, traceNodeStats, true);\n\n    // iterate over nonFtv1ErrorPaths, using some bits from traceNodeStats function\n    for (const { subgraph, path } of nonFtv1ErrorPaths) {\n      hasError = true;\n      if (path) {\n        let currPathErrorStats = this.queryLatencyStats.rootErrorStats.getChild(\n          `service:${subgraph}`,\n          sizeEstimator,\n        );\n        path.forEach((subPath) => {\n          if (typeof subPath === 'string') {\n            currPathErrorStats = currPathErrorStats.getChild(\n              subPath,\n              sizeEstimator,\n            );\n          }\n        });\n\n        errorPathStats.add(currPathErrorStats);\n        currPathErrorStats.errorsCount += 1;\n      }\n    }\n\n    for (const errorPath of errorPathStats) {\n      errorPath.requestsWithErrorsCount += 1;\n    }\n\n    if (hasError) {\n      this.queryLatencyStats.requestsWithErrorsCount++;\n    }\n  }\n\n  getTypeStat(parentType: string, sizeEstimator: SizeEstimator): OurTypeStat {\n    const existing = this.perTypeStat[parentType];\n    if (existing) {\n      return existing;\n    }\n    sizeEstimator.bytes += estimatedBytesForString(parentType);\n    const typeStat = new OurTypeStat();\n    this.perTypeStat[parentType] = typeStat;\n    return typeStat;\n  }\n}\n\nclass OurQueryLatencyStats implements Required<IQueryLatencyStats> {\n  latencyCount: DurationHistogram = new DurationHistogram();\n  requestCount = 0;\n  requestsWithoutFieldInstrumentation = 0;\n  cacheHits = 0;\n  persistedQueryHits = 0;\n  persistedQueryMisses = 0;\n  cacheLatencyCount: DurationHistogram = new DurationHistogram();\n  rootErrorStats: OurPathErrorStats = new OurPathErrorStats();\n  requestsWithErrorsCount = 0;\n  publicCacheTtlCount: DurationHistogram = new DurationHistogram();\n  privateCacheTtlCount: DurationHistogram = new DurationHistogram();\n  registeredOperationCount = 0;\n  forbiddenOperationCount = 0;\n}\n\nclass OurPathErrorStats implements Required<IPathErrorStats> {\n  children: { [k: string]: OurPathErrorStats } = Object.create(null);\n  errorsCount = 0;\n  requestsWithErrorsCount = 0;\n\n  getChild(subPath: string, sizeEstimator: SizeEstimator): OurPathErrorStats {\n    const existing = this.children[subPath];\n    if (existing) {\n      return existing;\n    }\n    const child = new OurPathErrorStats();\n    this.children[subPath] = child;\n    // Include a few bytes in the estimate for the numbers etc.\n    sizeEstimator.bytes += estimatedBytesForString(subPath) + 4;\n    return child;\n  }\n}\n\nclass OurTypeStat implements Required<ITypeStat> {\n  perFieldStat: { [k: string]: OurFieldStat } = Object.create(null);\n\n  getFieldStat(\n    fieldName: string,\n    returnType: string,\n    sizeEstimator: SizeEstimator,\n  ): OurFieldStat {\n    const existing = this.perFieldStat[fieldName];\n    if (existing) {\n      return existing;\n    }\n    // Rough estimate of 10 bytes for the numbers in the FieldStat.\n    sizeEstimator.bytes +=\n      estimatedBytesForString(fieldName) +\n      estimatedBytesForString(returnType) +\n      10;\n    const fieldStat = new OurFieldStat(returnType);\n    this.perFieldStat[fieldName] = fieldStat;\n    return fieldStat;\n  }\n\n  ensureCountsAreIntegers() {\n    for (const fieldStat of Object.values(this.perFieldStat)) {\n      fieldStat.ensureCountsAreIntegers();\n    }\n  }\n}\n\nclass OurFieldStat implements Required<IFieldStat> {\n  errorsCount = 0;\n  observedExecutionCount = 0;\n  // Note that this number isn't necessarily an integer while it is being\n  // aggregated. Before encoding as a protobuf we call ensureCountsAreIntegers\n  // which floors it.\n  estimatedExecutionCount = 0;\n  requestsWithErrorsCount = 0;\n  latencyCount: DurationHistogram = new DurationHistogram();\n\n  constructor(readonly returnType: string) {}\n\n  ensureCountsAreIntegers() {\n    // This is the only one that ever can receive non-integers.\n    this.estimatedExecutionCount = Math.floor(this.estimatedExecutionCount);\n  }\n}\n\nfunction estimatedBytesForString(s: string) {\n  // 2 is for the tag (field ID + wire type) plus the encoded length. (The\n  // encoded length takes up more than 1 byte for strings that are longer than\n  // 127 bytes, but this is an estimate.)\n  return 2 + Buffer.byteLength(s);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4617, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4622, "column": 0}, "map": {"version":3,"file":"traceDetails.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/plugin/usageReporting/traceDetails.ts"],"sourcesContent":["import { Trace } from '@apollo/usage-reporting-protobuf';\nimport type { VariableValueOptions } from './options.js';\n\n// Creates trace details from request variables, given a specification for modifying\n// values of private or sensitive variables.\n// The details will include all variable names and their (possibly hidden or modified) values.\n// If sendVariableValues is {all: bool}, {none: bool} or {exceptNames: Array}, the option will act similarly to\n// to the to-be-deprecated options.privateVariables, except that the redacted variable\n// names will still be visible in the UI even if the values are hidden.\n// If sendVariableValues is null or undefined, we default to the {none: true} case.\nexport function makeTraceDetails(\n  variables: Record<string, any>,\n  sendVariableValues?: VariableValueOptions,\n  operationString?: string,\n): Trace.Details {\n  const details = new Trace.Details();\n  const variablesToRecord = (() => {\n    if (sendVariableValues && 'transform' in sendVariableValues) {\n      const originalKeys = Object.keys(variables);\n      try {\n        // Custom function to allow user to specify what variablesJson will look like\n        const modifiedVariables = sendVariableValues.transform({\n          variables: variables,\n          operationString: operationString,\n        });\n        return cleanModifiedVariables(originalKeys, modifiedVariables);\n      } catch (e) {\n        // If the custom function provided by the user throws an exception,\n        // change all the variable values to an appropriate error message.\n        return handleVariableValueTransformError(originalKeys);\n      }\n    } else {\n      return variables;\n    }\n  })();\n\n  // Note: we explicitly do *not* include the details.rawQuery field. The\n  // Studio web app currently does nothing with this other than store it in\n  // the database and offer it up via its GraphQL API, and sending it means\n  // that using calculateSignature to hide sensitive data in the query\n  // string is ineffective.\n  Object.keys(variablesToRecord).forEach((name) => {\n    if (\n      !sendVariableValues ||\n      ('none' in sendVariableValues && sendVariableValues.none) ||\n      ('all' in sendVariableValues && !sendVariableValues.all) ||\n      ('exceptNames' in sendVariableValues &&\n        // We assume that most users will have only a few variables values to hide,\n        // or will just set {none: true}; we can change this\n        // linear-time operation if it causes real performance issues.\n        sendVariableValues.exceptNames.includes(name)) ||\n      ('onlyNames' in sendVariableValues &&\n        !sendVariableValues.onlyNames.includes(name))\n    ) {\n      // Special case for private variables. Note that this is a different\n      // representation from a variable containing the empty string, as that\n      // will be sent as '\"\"'.\n      details.variablesJson![name] = '';\n    } else {\n      try {\n        details.variablesJson![name] =\n          typeof variablesToRecord[name] === 'undefined'\n            ? ''\n            : JSON.stringify(variablesToRecord[name]);\n      } catch (e) {\n        details.variablesJson![name] = JSON.stringify(\n          '[Unable to convert value to JSON]',\n        );\n      }\n    }\n  });\n  return details;\n}\n\nfunction handleVariableValueTransformError(\n  variableNames: string[],\n): Record<string, any> {\n  const modifiedVariables = Object.create(null);\n  variableNames.forEach((name) => {\n    modifiedVariables[name] = '[PREDICATE_FUNCTION_ERROR]';\n  });\n  return modifiedVariables;\n}\n\n// Helper for makeTraceDetails() to enforce that the keys of a modified 'variables'\n// matches that of the original 'variables'\nfunction cleanModifiedVariables(\n  originalKeys: Array<string>,\n  modifiedVariables: Record<string, any>,\n): Record<string, any> {\n  const cleanedVariables: Record<string, any> = Object.create(null);\n  originalKeys.forEach((name) => {\n    cleanedVariables[name] = modifiedVariables[name];\n  });\n  return cleanedVariables;\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA,yEAAyD;AAUzD,SAAgB,gBAAgB,CAC9B,SAA8B,EAC9B,kBAAyC,EACzC,eAAwB;IAExB,MAAM,OAAO,GAAG,IAAI,2BAAA,KAAK,CAAC,OAAO,EAAE,CAAC;IACpC,MAAM,iBAAiB,GAAG,CAAC,GAAG,EAAE;QAC9B,IAAI,kBAAkB,IAAI,WAAW,IAAI,kBAAkB,EAAE,CAAC;YAC5D,MAAM,YAAY,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YAC5C,IAAI,CAAC;gBAEH,MAAM,iBAAiB,GAAG,kBAAkB,CAAC,SAAS,CAAC;oBACrD,SAAS,EAAE,SAAS;oBACpB,eAAe,EAAE,eAAe;iBACjC,CAAC,CAAC;gBACH,OAAO,sBAAsB,CAAC,YAAY,EAAE,iBAAiB,CAAC,CAAC;YACjE,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC;gBAGX,OAAO,iCAAiC,CAAC,YAAY,CAAC,CAAC;YACzD,CAAC;QACH,CAAC,MAAM,CAAC;YACN,OAAO,SAAS,CAAC;QACnB,CAAC;IACH,CAAC,CAAC,EAAE,CAAC;IAOL,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QAC9C,IACE,CAAC,kBAAkB,IAClB,MAAM,IAAI,kBAAkB,IAAI,kBAAkB,CAAC,IAAI,CAAC,GACxD,KAAK,IAAI,kBAAkB,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,GACvD,aAAa,IAAI,kBAAkB,IAIlC,kBAAkB,CAAC,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,GAC/C,WAAW,IAAI,kBAAkB,IAChC,CAAC,kBAAkB,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAC/C,CAAC;YAID,OAAO,CAAC,aAAc,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;QACpC,CAAC,MAAM,CAAC;YACN,IAAI,CAAC;gBACH,OAAO,CAAC,aAAc,CAAC,IAAI,CAAC,GAC1B,OAAO,iBAAiB,CAAC,IAAI,CAAC,KAAK,WAAW,GAC1C,EAAE,GACF,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC;YAChD,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC;gBACX,OAAO,CAAC,aAAc,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,CAC3C,mCAAmC,CACpC,CAAC;YACJ,CAAC;QACH,CAAC;IACH,CAAC,CAAC,CAAC;IACH,OAAO,OAAO,CAAC;AACjB,CAAC;AA9DD,QAAA,gBAAA,GAAA,iBA8DC;AAED,SAAS,iCAAiC,CACxC,aAAuB;IAEvB,MAAM,iBAAiB,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAC9C,aAAa,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QAC7B,iBAAiB,CAAC,IAAI,CAAC,GAAG,4BAA4B,CAAC;IACzD,CAAC,CAAC,CAAC;IACH,OAAO,iBAAiB,CAAC;AAC3B,CAAC;AAID,SAAS,sBAAsB,CAC7B,YAA2B,EAC3B,iBAAsC;IAEtC,MAAM,gBAAgB,GAAwB,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAClE,YAAY,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QAC5B,gBAAgB,CAAC,IAAI,CAAC,GAAG,iBAAiB,CAAC,IAAI,CAAC,CAAC;IACnD,CAAC,CAAC,CAAC;IACH,OAAO,gBAAgB,CAAC;AAC1B,CAAC","ignoreList":[0]}},
    {"offset": {"line": 4674, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4679, "column": 0}, "map": {"version":3,"file":"packageVersion.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/generated/packageVersion.ts"],"sourcesContent":["export const packageVersion = \"4.11.3\";\n"],"names":[],"mappings":";;;;;AAAa,QAAA,cAAc,GAAG,QAAQ,CAAC","ignoreList":[0]}},
    {"offset": {"line": 4685, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4690, "column": 0}, "map": {"version":3,"file":"schemaIsSubgraph.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/plugin/schemaIsSubgraph.ts"],"sourcesContent":["import {\n  type GraphQLSchema,\n  isObjectType,\n  isScalarType,\n  isNonNullType,\n} from 'graphql';\n\n// Returns true if it appears that the schema was appears to be of a subgraph\n// (eg, returned from @apollo/subgraph's buildSubgraphSchema). This strategy\n// avoids depending explicitly on @apollo/subgraph or relying on something that\n// might not survive transformations like monkey-patching a boolean field onto\n// the schema.\n//\n// This is used for two things:\n// 1) Determining whether traces should be added to responses if requested with\n//    an HTTP header. If you want to include these traces even for non-subgraphs\n//    (when requested via header, eg for Apollo Explorer's trace view) you can\n//    use ApolloServerPluginInlineTrace explicitly; if you want to never include\n//    these traces even for subgraphs you can use\n//    ApolloServerPluginInlineTraceDisabled.\n// 2) Determining whether schema-reporting should be allowed; subgraphs cannot\n//    report schemas, and we accordingly throw if it's attempted.\nexport function schemaIsSubgraph(schema: GraphQLSchema): boolean {\n  const serviceType = schema.getType('_Service');\n  if (!isObjectType(serviceType)) {\n    return false;\n  }\n  const sdlField = serviceType.getFields().sdl;\n  if (!sdlField) {\n    return false;\n  }\n\n  let sdlFieldType = sdlField.type;\n  if (isNonNullType(sdlFieldType)) {\n    sdlFieldType = sdlFieldType.ofType;\n  }\n  if (!isScalarType(sdlFieldType)) {\n    return false;\n  }\n  return sdlFieldType.name == 'String';\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA,+BAKiB;AAiBjB,SAAgB,gBAAgB,CAAC,MAAqB;IACpD,MAAM,WAAW,GAAG,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;IAC/C,IAAI,CAAC,CAAA,GAAA,UAAA,YAAY,EAAC,WAAW,CAAC,EAAE,CAAC;QAC/B,OAAO,KAAK,CAAC;IACf,CAAC;IACD,MAAM,QAAQ,GAAG,WAAW,CAAC,SAAS,EAAE,CAAC,GAAG,CAAC;IAC7C,IAAI,CAAC,QAAQ,EAAE,CAAC;QACd,OAAO,KAAK,CAAC;IACf,CAAC;IAED,IAAI,YAAY,GAAG,QAAQ,CAAC,IAAI,CAAC;IACjC,IAAI,CAAA,GAAA,UAAA,aAAa,EAAC,YAAY,CAAC,EAAE,CAAC;QAChC,YAAY,GAAG,YAAY,CAAC,MAAM,CAAC;IACrC,CAAC;IACD,IAAI,CAAC,CAAA,GAAA,UAAA,YAAY,EAAC,YAAY,CAAC,EAAE,CAAC;QAChC,OAAO,KAAK,CAAC;IACf,CAAC;IACD,OAAO,YAAY,CAAC,IAAI,IAAI,QAAQ,CAAC;AACvC,CAAC;AAlBD,QAAA,gBAAA,GAAA,iBAkBC","ignoreList":[0]}},
    {"offset": {"line": 4715, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4720, "column": 0}, "map": {"version":3,"file":"plugin.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/plugin/usageReporting/plugin.ts"],"sourcesContent":["import { Report, ReportHeader, Trace } from '@apollo/usage-reporting-protobuf';\nimport type { Fetcher, FetcherResponse } from '@apollo/utils.fetcher';\nimport {\n  usageReportingSignature,\n  calculateReferencedFieldsByType,\n  type ReferencedFieldsByType,\n} from '@apollo/utils.usagereporting';\nimport retry from 'async-retry';\nimport { type GraphQLSchema, printSchema } from 'graphql';\nimport type LRUCache from 'lru-cache';\nimport { AbortController } from 'node-abort-controller';\nimport fetch from 'node-fetch';\nimport os from 'os';\nimport { gzip } from 'zlib';\nimport type {\n  ApolloServerPlugin,\n  BaseContext,\n  GraphQLRequestContext,\n  GraphQLRequestContextDidResolveOperation,\n  GraphQLRequestContextWillSendResponse,\n  GraphQLRequestListener,\n  GraphQLServerListener,\n} from '../../externalTypes/index.js';\nimport { internalPlugin } from '../../internalPlugin.js';\nimport { dateToProtoTimestamp, TraceTreeBuilder } from '../traceTreeBuilder.js';\nimport { defaultSendOperationsAsTrace } from './defaultSendOperationsAsTrace.js';\nimport {\n  createOperationDerivedDataCache,\n  type OperationDerivedData,\n  operationDerivedDataCacheKey,\n} from './operationDerivedDataCache.js';\nimport type {\n  ApolloServerPluginUsageReportingOptions,\n  SendValuesBaseOptions,\n} from './options.js';\nimport { OurReport } from './stats.js';\nimport { makeTraceDetails } from './traceDetails.js';\nimport { packageVersion } from '../../generated/packageVersion.js';\nimport { computeCoreSchemaHash } from '../../utils/computeCoreSchemaHash.js';\nimport type { HeaderMap } from '../../utils/HeaderMap.js';\nimport { schemaIsSubgraph } from '../schemaIsSubgraph.js';\n\nconst reportHeaderDefaults = {\n  hostname: os.hostname(),\n  agentVersion: `@apollo/server@${packageVersion}`,\n  runtimeVersion: `node ${process.version}`,\n  // XXX not actually uname, but what node has easily.\n  uname: `${os.platform()}, ${os.type()}, ${os.release()}, ${os.arch()})`,\n};\n\nexport function ApolloServerPluginUsageReporting<TContext extends BaseContext>(\n  options: ApolloServerPluginUsageReportingOptions<TContext> = Object.create(\n    null,\n  ),\n): ApolloServerPlugin<TContext> {\n  // Note: We'd like to change the default to false in Apollo Server 4, so that\n  // the default usage reporting experience doesn't include *anything* that\n  // could potentially be PII (like error messages) --- just operations and\n  // numbers.\n  const fieldLevelInstrumentationOption = options.fieldLevelInstrumentation;\n  const fieldLevelInstrumentation =\n    typeof fieldLevelInstrumentationOption === 'number'\n      ? async () =>\n          Math.random() < fieldLevelInstrumentationOption\n            ? 1 / fieldLevelInstrumentationOption\n            : 0\n      : fieldLevelInstrumentationOption\n        ? fieldLevelInstrumentationOption\n        : async () => true;\n\n  let requestDidStartHandler:\n    | ((\n        requestContext: GraphQLRequestContext<TContext>,\n      ) => GraphQLRequestListener<TContext>)\n    | null = null;\n  return internalPlugin({\n    __internal_plugin_id__: 'UsageReporting',\n    __is_disabled_plugin__: false,\n\n    // We want to be able to access locals from `serverWillStart` in our `requestDidStart`, thus\n    // this little hack. (Perhaps we should also allow GraphQLServerListener to contain\n    // a requestDidStart?)\n    async requestDidStart(requestContext: GraphQLRequestContext<TContext>) {\n      if (requestDidStartHandler) {\n        return requestDidStartHandler(requestContext);\n      }\n      // This happens if usage reporting is disabled (eg because this is a\n      // subgraph).\n      return {};\n    },\n\n    async serverWillStart({\n      logger: serverLogger,\n      apollo,\n      startedInBackground,\n      schema,\n    }): Promise<GraphQLServerListener> {\n      // Use the plugin-specific logger if one is provided; otherwise the general server one.\n      const logger = options.logger ?? serverLogger;\n      const { key, graphRef } = apollo;\n      if (!(key && graphRef)) {\n        throw new Error(\n          \"You've enabled usage reporting via ApolloServerPluginUsageReporting, \" +\n            'but you also need to provide your Apollo API key and graph ref, via ' +\n            'the APOLLO_KEY/APOLLO_GRAPH_REF environment ' +\n            'variables or via `new ApolloServer({apollo: {key, graphRef})`.',\n        );\n      }\n\n      if (schemaIsSubgraph(schema)) {\n        if (options.__onlyIfSchemaIsNotSubgraph) {\n          logger.warn(\n            'You have specified an Apollo API key and graph ref but this server appears ' +\n              'to be a subgraph. Typically usage reports are sent to Apollo by your Router ' +\n              'or Gateway, not directly from your subgraph; usage reporting is disabled. To ' +\n              'enable usage reporting anyway, explicitly install `ApolloServerPluginUsageReporting`. ' +\n              'To disable this warning, install `ApolloServerPluginUsageReportingDisabled`.',\n          );\n          // This early return means we don't start background timers, don't\n          // register serverDidStart, don't assign requestDidStartHandler, etc.\n          return {};\n        } else {\n          // This is just a warning; usage reporting is still enabled. If it\n          // turns out there are lots of people who really need to have this odd\n          // setup and they don't like the warning, we can provide a new option\n          // to disable the warning (or they can filter in their `logger`).\n          logger.warn(\n            'You have installed `ApolloServerPluginUsageReporting` but this server appears to ' +\n              'be a subgraph. Typically usage reports are sent to Apollo by your Router ' +\n              'or Gateway, not directly from your subgraph. If this was unintentional, remove ' +\n              \"`ApolloServerPluginUsageReporting` from your server's `plugins` array.\",\n          );\n        }\n      }\n\n      logger.info(\n        'Apollo usage reporting starting! See your graph at ' +\n          `https://studio.apollographql.com/graph/${encodeURI(graphRef)}/`,\n      );\n\n      // If sendReportsImmediately is not specified, we default to true if we're running\n      // with the ApolloServer designed for Lambda or similar. That's because these\n      // environments aren't designed around letting us run a background task to\n      // send reports later or hook into container destruction to flush buffered reports.\n      const sendReportsImmediately =\n        options.sendReportsImmediately ?? startedInBackground;\n\n      // Since calculating the signature and referenced fields for usage\n      // reporting is potentially an expensive operation, we'll cache the data\n      // we generate and re-use them for repeated operations for the same\n      // `queryHash`. However, because referenced fields depend on the current\n      // schema, we want to throw it out entirely any time the schema changes.\n      let operationDerivedDataCache: {\n        forSchema: GraphQLSchema;\n        cache: LRUCache<string, OperationDerivedData>;\n      } | null = null;\n\n      // This map maps from executable schema ID (schema hash, basically) to the\n      // report we'll send about it. That's because when we're using a gateway,\n      // the schema can change over time, but each report needs to be about a\n      // single schema. We avoid having this function be a memory leak by\n      // removing values from it when we're in the process of sending reports.\n      // That means we have to be very careful never to pull a Report out of it\n      // and hang on to it for a while before writing to it, because the report\n      // might have gotten sent and discarded in the meantime. So you should\n      // only access the values of this Map via\n      // getReportWhichMustBeUsedImmediately and getAndDeleteReport, and never\n      // hang on to the value returned by getReportWhichMustBeUsedImmediately.\n      const reportByExecutableSchemaId = new Map<string, OurReport>();\n      const getReportWhichMustBeUsedImmediately = (\n        executableSchemaId: string,\n      ): OurReport => {\n        const existing = reportByExecutableSchemaId.get(executableSchemaId);\n        if (existing) {\n          return existing;\n        }\n        const report = new OurReport(\n          new ReportHeader({\n            ...reportHeaderDefaults,\n            executableSchemaId,\n            graphRef,\n          }),\n        );\n        reportByExecutableSchemaId.set(executableSchemaId, report);\n        return report;\n      };\n      const getAndDeleteReport = (\n        executableSchemaId: string,\n      ): OurReport | null => {\n        const report = reportByExecutableSchemaId.get(executableSchemaId);\n        if (report) {\n          reportByExecutableSchemaId.delete(executableSchemaId);\n          return report;\n        }\n        return null;\n      };\n\n      const overriddenExecutableSchemaId = options.overrideReportedSchema\n        ? computeCoreSchemaHash(options.overrideReportedSchema)\n        : undefined;\n\n      let lastSeenExecutableSchemaToId:\n        | {\n            executableSchema: GraphQLSchema;\n            executableSchemaId: string;\n          }\n        | undefined;\n\n      let reportTimer: NodeJS.Timeout | undefined;\n      if (!sendReportsImmediately) {\n        reportTimer = setInterval(\n          () => sendAllReportsAndReportErrors(),\n          options.reportIntervalMs || 10 * 1000,\n        );\n      }\n\n      // We don't send traces if the user set `sendTraces: false`. We also may\n      // set this to false later if the usage-reporting ingress informs us that\n      // this graph does not support viewing traces.\n      let sendTraces = options.sendTraces ?? true;\n      const sendOperationAsTrace =\n        options.experimental_sendOperationAsTrace ??\n        defaultSendOperationsAsTrace();\n\n      let stopped = false;\n\n      function executableSchemaIdForSchema(schema: GraphQLSchema) {\n        if (lastSeenExecutableSchemaToId?.executableSchema === schema) {\n          return lastSeenExecutableSchemaToId.executableSchemaId;\n        }\n        const id = computeCoreSchemaHash(printSchema(schema));\n\n        // We override this variable every time we get a new schema so we cache\n        // the last seen value. It is a single-entry cache.\n        lastSeenExecutableSchemaToId = {\n          executableSchema: schema,\n          executableSchemaId: id,\n        };\n\n        return id;\n      }\n\n      async function sendAllReportsAndReportErrors(): Promise<void> {\n        await Promise.all(\n          [...reportByExecutableSchemaId.keys()].map((executableSchemaId) =>\n            sendReportAndReportErrors(executableSchemaId),\n          ),\n        );\n      }\n\n      async function sendReportAndReportErrors(\n        executableSchemaId: string,\n      ): Promise<void> {\n        return sendReport(executableSchemaId).catch((err) => {\n          // This catch block is primarily intended to catch network errors from\n          // the retried request itself, which include network errors and non-2xx\n          // HTTP errors.\n          if (options.reportErrorFunction) {\n            options.reportErrorFunction(err);\n          } else {\n            logger.error(err.message);\n          }\n        });\n      }\n\n      // Needs to be an arrow function to be confident that key is defined.\n      const sendReport = async (executableSchemaId: string): Promise<void> => {\n        let report = getAndDeleteReport(executableSchemaId);\n        if (\n          !report ||\n          (Object.keys(report.tracesPerQuery).length === 0 &&\n            report.operationCount === 0)\n        ) {\n          return;\n        }\n\n        // Set the report's overall end time. This is the timestamp that will be\n        // associated with the summarized statistics.\n        report.endTime = dateToProtoTimestamp(new Date());\n\n        report.ensureCountsAreIntegers();\n\n        const protobufError = Report.verify(report);\n        if (protobufError) {\n          throw new Error(`Error verifying report: ${protobufError}`);\n        }\n        let message: Uint8Array | null = Report.encode(report).finish();\n        // Let the original protobuf object be garbage collected (helpful if the\n        // HTTP request hangs).\n        report = null;\n\n        // Potential follow-up: we can compare message.length to\n        // report.sizeEstimator.bytes and use it to \"learn\" if our estimation is\n        // off and adjust it based on what we learn.\n\n        if (options.debugPrintReports) {\n          // We decode the report rather than printing the original `report`\n          // so that it includes all of the pre-encoded traces.\n          const decodedReport = Report.decode(message);\n          logger.info(\n            `Apollo usage report: ${JSON.stringify(decodedReport.toJSON())}`,\n          );\n        }\n\n        const compressed = await new Promise<Buffer>((resolve, reject) => {\n          gzip(message!, (error, result) => {\n            error ? reject(error) : resolve(result);\n          });\n        });\n        // Let the uncompressed message be garbage collected (helpful if the\n        // HTTP request is slow).\n        message = null;\n\n        // Wrap fetcher with async-retry for automatic retrying\n        const fetcher: Fetcher = options.fetcher ?? fetch;\n        const response: FetcherResponse = await retry(\n          // Retry on network errors and 5xx HTTP\n          // responses.\n          async () => {\n            // Note that once we require Node v16 we can use its global\n            // AbortController instead of the one from `node-abort-controller`.\n            const controller = new AbortController();\n            const abortTimeout = setTimeout(() => {\n              controller.abort();\n            }, options.requestTimeoutMs ?? 30_000);\n            let curResponse;\n            try {\n              curResponse = await fetcher(\n                (options.endpointUrl ||\n                  'https://usage-reporting.api.apollographql.com') +\n                  '/api/ingress/traces',\n                {\n                  method: 'POST',\n                  headers: {\n                    'user-agent': 'ApolloServerPluginUsageReporting',\n                    'x-api-key': key,\n                    'content-encoding': 'gzip',\n                    accept: 'application/json',\n                  },\n                  body: compressed,\n                  signal: controller.signal,\n                },\n              );\n            } finally {\n              clearTimeout(abortTimeout);\n            }\n\n            if (curResponse.status >= 500 && curResponse.status < 600) {\n              throw new Error(\n                `HTTP status ${curResponse.status}, ${\n                  (await curResponse.text()) || '(no body)'\n                }`,\n              );\n            } else {\n              return curResponse;\n            }\n          },\n          {\n            retries: (options.maxAttempts || 5) - 1,\n            minTimeout: options.minimumRetryDelayMs || 100,\n            factor: 2,\n          },\n        ).catch((err: Error) => {\n          throw new Error(\n            `Error sending report to Apollo servers: ${err.message}`,\n          );\n        });\n\n        if (response.status < 200 || response.status >= 300) {\n          // Note that we don't expect to see a 3xx here because request follows\n          // redirects.\n          throw new Error(\n            `Error sending report to Apollo servers: HTTP status ${\n              response.status\n            }, ${(await response.text()) || '(no body)'}`,\n          );\n        }\n\n        if (\n          sendTraces &&\n          response.status === 200 &&\n          response.headers\n            .get('content-type')\n            ?.match(/^\\s*application\\/json\\s*(?:;|$)/i)\n        ) {\n          const body = await response.text();\n          let parsedBody;\n          try {\n            parsedBody = JSON.parse(body);\n          } catch (e) {\n            throw new Error(`Error parsing response from Apollo servers: ${e}`);\n          }\n          if (parsedBody.tracesIgnored === true) {\n            logger.debug(\n              \"This graph's organization does not have access to traces; sending all \" +\n                'subsequent operations as stats.',\n            );\n            sendTraces = false;\n          }\n        }\n        if (options.debugPrintReports) {\n          logger.info(`Apollo usage report: status ${response.status}`);\n        }\n      };\n\n      requestDidStartHandler = ({\n        metrics,\n        schema,\n        request: { http, variables },\n      }): GraphQLRequestListener<TContext> => {\n        const treeBuilder: TraceTreeBuilder = new TraceTreeBuilder({\n          maskedBy: 'ApolloServerPluginUsageReporting',\n          sendErrors: options.sendErrors,\n        });\n        treeBuilder.startTiming();\n        metrics.startHrTime = treeBuilder.startHrTime;\n        let graphqlValidationFailure = false;\n        let graphqlUnknownOperationName = false;\n        let includeOperationInUsageReporting: boolean | null = null;\n\n        if (http) {\n          treeBuilder.trace.http = new Trace.HTTP({\n            method:\n              Trace.HTTP.Method[\n                http.method as keyof typeof Trace.HTTP.Method\n              ] || Trace.HTTP.Method.UNKNOWN,\n          });\n\n          if (options.sendHeaders) {\n            makeHTTPRequestHeaders(\n              treeBuilder.trace.http,\n              http.headers,\n              options.sendHeaders,\n            );\n          }\n        }\n\n        // After this function completes, includeOperationInUsageReporting is\n        // defined.\n        async function maybeCallIncludeRequestHook(\n          requestContext:\n            | GraphQLRequestContextDidResolveOperation<TContext>\n            | GraphQLRequestContextWillSendResponse<TContext>,\n        ): Promise<void> {\n          // If this is the second call in `willSendResponse` after\n          // `didResolveOperation`, we're done.\n          if (includeOperationInUsageReporting !== null) return;\n\n          if (typeof options.includeRequest !== 'function') {\n            // Default case we always report\n            includeOperationInUsageReporting = true;\n            return;\n          }\n          includeOperationInUsageReporting =\n            await options.includeRequest(requestContext);\n\n          // Help the user understand they've returned an unexpected value,\n          // which might be a subtle mistake.\n          if (typeof includeOperationInUsageReporting !== 'boolean') {\n            logger.warn(\n              \"The 'includeRequest' async predicate function must return a boolean value.\",\n            );\n            includeOperationInUsageReporting = true;\n          }\n        }\n\n        // Our usage reporting groups everything by operation, so we don't\n        // actually report about any issues that prevent us from getting an\n        // operation string (eg, a missing operation, or APQ problems).\n        // This is effectively bypassing the reporting of:\n        //   - PersistedQueryNotFoundError\n        //   - PersistedQueryNotSupportedError\n        //   - Missing `query` error\n        // We may want to report them some other way later!\n        let didResolveSource = false;\n\n        return {\n          async didResolveSource(requestContext) {\n            didResolveSource = true;\n\n            if (metrics.persistedQueryHit) {\n              treeBuilder.trace.persistedQueryHit = true;\n            }\n            if (metrics.persistedQueryRegister) {\n              treeBuilder.trace.persistedQueryRegister = true;\n            }\n\n            if (variables) {\n              treeBuilder.trace.details = makeTraceDetails(\n                variables,\n                options.sendVariableValues,\n                requestContext.source,\n              );\n            }\n\n            const clientInfo = (\n              options.generateClientInfo || defaultGenerateClientInfo\n            )(requestContext);\n            if (clientInfo) {\n              // While there is a clientAddress protobuf field, the backend\n              // doesn't pay attention to it yet, so we'll ignore it for now.\n              const { clientName, clientVersion } = clientInfo;\n              treeBuilder.trace.clientVersion = clientVersion || '';\n              treeBuilder.trace.clientName = clientName || '';\n            }\n          },\n          async validationDidStart() {\n            return async (validationErrors?: ReadonlyArray<Error>) => {\n              graphqlValidationFailure = validationErrors\n                ? validationErrors.length !== 0\n                : false;\n            };\n          },\n          async didResolveOperation(requestContext) {\n            // If operation is undefined then `getOperationAST` returned null\n            // and an unknown operation was specified.\n            graphqlUnknownOperationName =\n              requestContext.operation === undefined;\n            await maybeCallIncludeRequestHook(requestContext);\n\n            if (\n              includeOperationInUsageReporting &&\n              // No need to capture traces if the operation is going to\n              // immediately fail due to unknown operation name.\n              !graphqlUnknownOperationName\n            ) {\n              if (metrics.captureTraces === undefined) {\n                // We're not completely ignoring the operation. But should we\n                // calculate a detailed trace of every field while we do so (either\n                // directly in this plugin, or in a subgraph by sending the\n                // apollo-federation-include-trace header)? That will allow this\n                // operation to contribute to the \"field executions\" column in the\n                // Studio Fields page, to the timing hints in Explorer and\n                // vscode-graphql, and to the traces visible under Operations. (Note\n                // that `true` here does not imply that this operation will\n                // necessarily be *sent* to the usage-reporting endpoint in the form\n                // of a trace --- it still might be aggregated into stats first. But\n                // capturing a trace will mean we can understand exactly what fields\n                // were executed and what their performance was, at the tradeoff of\n                // some overhead for tracking the trace (and transmitting it between\n                // subgraph and gateway).\n                const rawWeight =\n                  await fieldLevelInstrumentation(requestContext);\n                treeBuilder.trace.fieldExecutionWeight =\n                  typeof rawWeight === 'number' ? rawWeight : rawWeight ? 1 : 0;\n\n                metrics.captureTraces =\n                  !!treeBuilder.trace.fieldExecutionWeight;\n              }\n            }\n          },\n          async executionDidStart() {\n            // If we're not capturing traces, don't return a willResolveField so\n            // that we don't build up a detailed trace inside treeBuilder. (We still\n            // will use treeBuilder as a convenient place to put top-level facts\n            // about the operation which can end up aggregated as stats, and we do\n            // eventually put *errors* onto the trace tree.)\n            if (!metrics.captureTraces) return;\n\n            return {\n              willResolveField({ info }) {\n                return treeBuilder.willResolveField(info);\n                // We could save the error into the trace during the end handler, but\n                // it won't have all the information that graphql-js adds to it later,\n                // like 'locations'.\n              },\n            };\n          },\n\n          async didEncounterSubsequentErrors(_requestContext, errors) {\n            treeBuilder.didEncounterErrors(errors);\n          },\n\n          async willSendSubsequentPayload(requestContext, payload) {\n            if (!payload.hasNext) {\n              await operationFinished(requestContext);\n            }\n          },\n\n          async willSendResponse(requestContext) {\n            // Search above for a comment about \"didResolveSource\" to see which\n            // of the pre-source-resolution errors we are intentionally avoiding.\n            if (!didResolveSource) return;\n            if (requestContext.errors) {\n              treeBuilder.didEncounterErrors(requestContext.errors);\n            }\n\n            // If there isn't any defer/stream coming later, we're done.\n            // Otherwise willSendSubsequentPayload will trigger\n            // operationFinished.\n            if (requestContext.response.body.kind === 'single') {\n              await operationFinished(requestContext);\n            }\n          },\n        };\n\n        async function operationFinished(\n          requestContext: GraphQLRequestContextWillSendResponse<TContext>,\n        ) {\n          const resolvedOperation = !!requestContext.operation;\n\n          // If we got an error before we called didResolveOperation (eg parse or\n          // validation error), check to see if we should include the request.\n          await maybeCallIncludeRequestHook(requestContext);\n\n          treeBuilder.stopTiming();\n          const executableSchemaId =\n            overriddenExecutableSchemaId ?? executableSchemaIdForSchema(schema);\n\n          if (includeOperationInUsageReporting === false) {\n            if (resolvedOperation) {\n              getReportWhichMustBeUsedImmediately(executableSchemaId)\n                .operationCount++;\n            }\n            return;\n          }\n\n          treeBuilder.trace.fullQueryCacheHit = !!metrics.responseCacheHit;\n          treeBuilder.trace.forbiddenOperation = !!metrics.forbiddenOperation;\n          treeBuilder.trace.registeredOperation = !!metrics.registeredOperation;\n\n          const policyIfCacheable =\n            requestContext.overallCachePolicy.policyIfCacheable();\n          if (policyIfCacheable) {\n            treeBuilder.trace.cachePolicy = new Trace.CachePolicy({\n              scope:\n                policyIfCacheable.scope === 'PRIVATE'\n                  ? Trace.CachePolicy.Scope.PRIVATE\n                  : policyIfCacheable.scope === 'PUBLIC'\n                    ? Trace.CachePolicy.Scope.PUBLIC\n                    : Trace.CachePolicy.Scope.UNKNOWN,\n              // Convert from seconds to ns.\n              maxAgeNs: policyIfCacheable.maxAge * 1e9,\n            });\n          }\n\n          // If this was a federated operation and we're the gateway, add the query plan\n          // to the trace.\n          if (metrics.queryPlanTrace) {\n            treeBuilder.trace.queryPlan = metrics.queryPlanTrace;\n          }\n\n          // Intentionally un-awaited so as not to block the response.  Any\n          // errors will be logged, but will not manifest a user-facing error.\n          // The logger in this case is a request specific logger OR the logger\n          // defined by the plugin if that's unavailable.  The request-specific\n          // logger is preferred since this is very much coupled directly to a\n          // client-triggered action which might be more granularly tagged by\n          // logging implementations.\n          addTrace().catch(logger.error);\n\n          async function addTrace(): Promise<void> {\n            // Ignore traces that come in after stop().\n            if (stopped) {\n              return;\n            }\n\n            // Ensure that the caller of addTrace (which does not await it) is\n            // not blocked. We use setImmediate rather than process.nextTick or\n            // just relying on the Promise microtask queue because setImmediate\n            // comes after IO, which is what we want.\n            await new Promise((res) => setImmediate(res));\n\n            const executableSchemaId =\n              overriddenExecutableSchemaId ??\n              executableSchemaIdForSchema(schema);\n\n            const { trace } = treeBuilder;\n\n            let statsReportKey: string | undefined = undefined;\n            let referencedFieldsByType: ReferencedFieldsByType;\n            if (!requestContext.document) {\n              statsReportKey = `## GraphQLParseFailure\\n`;\n            } else if (graphqlValidationFailure) {\n              statsReportKey = `## GraphQLValidationFailure\\n`;\n            } else if (graphqlUnknownOperationName) {\n              statsReportKey = `## GraphQLUnknownOperationName\\n`;\n            }\n\n            const isExecutable = statsReportKey === undefined;\n\n            if (statsReportKey) {\n              if (options.sendUnexecutableOperationDocuments) {\n                trace.unexecutedOperationBody = requestContext.source;\n                // Get the operation name from the request (which might not\n                // correspond to an actual operation).\n                trace.unexecutedOperationName =\n                  requestContext.request.operationName || '';\n              }\n              referencedFieldsByType = Object.create(null);\n            } else {\n              const operationDerivedData = getOperationDerivedData();\n              statsReportKey = `# ${requestContext.operationName || '-'}\\n${\n                operationDerivedData.signature\n              }`;\n              referencedFieldsByType =\n                operationDerivedData.referencedFieldsByType;\n            }\n\n            const protobufError = Trace.verify(trace);\n            if (protobufError) {\n              throw new Error(`Error encoding trace: ${protobufError}`);\n            }\n\n            if (resolvedOperation) {\n              getReportWhichMustBeUsedImmediately(executableSchemaId)\n                .operationCount++;\n            }\n\n            getReportWhichMustBeUsedImmediately(executableSchemaId).addTrace({\n              statsReportKey,\n              trace,\n              // We include the operation as a trace (rather than aggregated into stats) only if:\n              // * the user didn't set `sendTraces: false` AND\n              // * it's possible that the organization's plan allows for viewing traces AND\n              // * we captured this as a full trace AND\n              // * gateway reported no errors missing ftv1 data AND\n              // * sendOperationAsTrace says so\n              //\n              // (As an edge case, if the reason metrics.captureTraces is\n              // falsey is that this is an unexecutable operation and thus we\n              // never ran the code in didResolveOperation that sets\n              // metrics.captureTrace, we allow it to be sent as a trace. This\n              // means we'll still send some parse and validation failures as\n              // traces, for the sake of the Errors page.)\n              asTrace:\n                sendTraces &&\n                (!isExecutable || !!metrics.captureTraces) &&\n                !metrics.nonFtv1ErrorPaths?.length &&\n                sendOperationAsTrace(trace, statsReportKey),\n              referencedFieldsByType,\n              nonFtv1ErrorPaths: metrics.nonFtv1ErrorPaths ?? [],\n            });\n\n            // If the buffer gets big (according to our estimate), send.\n            if (\n              sendReportsImmediately ||\n              getReportWhichMustBeUsedImmediately(executableSchemaId)\n                .sizeEstimator.bytes >=\n                (options.maxUncompressedReportSize || 4 * 1024 * 1024)\n            ) {\n              await sendReportAndReportErrors(executableSchemaId);\n            }\n          }\n\n          // Calculates signature and referenced fields for the current document.\n          // Only call this when the document properly parses and validates and\n          // the given operation name (if any) is known!\n          function getOperationDerivedData(): OperationDerivedData {\n            if (!requestContext.document) {\n              // This shouldn't happen: no document means parse failure, which\n              // uses its own special statsReportKey.\n              throw new Error('No document?');\n            }\n\n            const cacheKey = operationDerivedDataCacheKey(\n              requestContext.queryHash,\n              requestContext.operationName || '',\n            );\n\n            // Ensure that the cache we have is for the right schema.\n            if (\n              !operationDerivedDataCache ||\n              operationDerivedDataCache.forSchema !== schema\n            ) {\n              operationDerivedDataCache = {\n                forSchema: schema,\n                cache: createOperationDerivedDataCache({ logger }),\n              };\n            }\n\n            // If we didn't have the signature in the cache, we'll resort to\n            // calculating it.\n            const cachedOperationDerivedData =\n              operationDerivedDataCache.cache.get(cacheKey);\n            if (cachedOperationDerivedData) {\n              return cachedOperationDerivedData;\n            }\n\n            const generatedSignature = (\n              options.calculateSignature || usageReportingSignature\n            )(requestContext.document, requestContext.operationName || '');\n\n            const generatedOperationDerivedData: OperationDerivedData = {\n              signature: generatedSignature,\n              referencedFieldsByType: calculateReferencedFieldsByType({\n                document: requestContext.document,\n                schema,\n                resolvedOperationName: requestContext.operationName ?? null,\n              }),\n            };\n\n            // Note that this cache is always an in-memory cache.\n            // If we replace it with a more generic async cache, we should\n            // not await the write operation.\n            operationDerivedDataCache.cache.set(\n              cacheKey,\n              generatedOperationDerivedData,\n            );\n            return generatedOperationDerivedData;\n          }\n        }\n      };\n\n      return {\n        async serverWillStop() {\n          if (reportTimer) {\n            clearInterval(reportTimer);\n            reportTimer = undefined;\n          }\n\n          stopped = true;\n          await sendAllReportsAndReportErrors();\n        },\n      };\n    },\n  });\n}\n\nexport function makeHTTPRequestHeaders(\n  http: Trace.IHTTP,\n  headers: HeaderMap,\n  sendHeaders?: SendValuesBaseOptions,\n): void {\n  if (\n    !sendHeaders ||\n    ('none' in sendHeaders && sendHeaders.none) ||\n    ('all' in sendHeaders && !sendHeaders.all)\n  ) {\n    return;\n  }\n  for (const [key, value] of headers) {\n    // Note that HeaderMap keys are already lower-case.\n    if (\n      ('exceptNames' in sendHeaders &&\n        // We assume that most users only have a few headers to hide, or will\n        // just set {none: true} ; we can change this linear-time\n        // operation if it causes real performance issues.\n        sendHeaders.exceptNames.some((exceptHeader) => {\n          // Headers are case-insensitive, and should be compared as such.\n          return exceptHeader.toLowerCase() === key;\n        })) ||\n      ('onlyNames' in sendHeaders &&\n        !sendHeaders.onlyNames.some((header) => {\n          return header.toLowerCase() === key;\n        }))\n    ) {\n      continue;\n    }\n\n    switch (key) {\n      case 'authorization':\n      case 'cookie':\n      case 'set-cookie':\n        break;\n      default:\n        http!.requestHeaders![key] = new Trace.HTTP.Values({\n          value: [value],\n        });\n    }\n  }\n}\n\nfunction defaultGenerateClientInfo<TContext extends BaseContext>({\n  request,\n}: GraphQLRequestContext<TContext>) {\n  const clientNameHeaderKey = 'apollographql-client-name';\n  const clientVersionHeaderKey = 'apollographql-client-version';\n\n  // Default to using the `apollo-client-x` header fields if present.\n  // If none are present, fallback on the `clientInfo` query extension\n  // for backwards compatibility.\n  // The default value if neither header values nor query extension is\n  // set is the empty String for all fields (as per protobuf defaults)\n  if (\n    request.http?.headers?.get(clientNameHeaderKey) ||\n    request.http?.headers?.get(clientVersionHeaderKey)\n  ) {\n    return {\n      clientName: request.http?.headers?.get(clientNameHeaderKey),\n      clientVersion: request.http?.headers?.get(clientVersionHeaderKey),\n    };\n  } else if (request.extensions?.clientInfo) {\n    return request.extensions.clientInfo;\n  } else {\n    return {};\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5166, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5171, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/plugin/usageReporting/index.ts"],"sourcesContent":["export { ApolloServerPluginUsageReporting } from './plugin.js';\nexport type {\n  ApolloServerPluginUsageReportingOptions,\n  SendValuesBaseOptions,\n  VariableValueOptions,\n  SendErrorsOptions,\n  ClientInfo,\n  GenerateClientInfo,\n} from './options.js';\n"],"names":[],"mappings":";;;;;AAAA,IAAA,qCAA+D;AAAtD,OAAA,cAAA,CAAA,SAAA,oCAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,YAAA,gCAAgC;IAAA;AAAA,GAAA","ignoreList":[0]}},
    {"offset": {"line": 5183, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5188, "column": 0}, "map": {"version":3,"file":"schemaReporter.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/plugin/schemaReporting/schemaReporter.ts"],"sourcesContent":["import fetch from 'node-fetch';\nimport type { GraphQLRequest } from '../../externalTypes/index.js';\nimport type { Logger } from '@apollo/utils.logger';\nimport type {\n  SchemaReport,\n  SchemaReportMutationVariables,\n  SchemaReportMutation,\n  ReportSchemaResponse,\n} from './generated/operations';\nimport type { Fetcher } from '@apollo/utils.fetcher';\nimport { packageVersion } from '../../generated/packageVersion.js';\n\n// Magic GraphQL comment allows codegen to find the query\n// prettier-ignore\nexport const schemaReportGql = /* GraphQL */ `#graphql\n  mutation SchemaReport($report: SchemaReport!, $coreSchema: String) {\n    reportSchema(report: $report, coreSchema: $coreSchema) {\n      __typename\n      ... on ReportSchemaError {\n        message\n        code\n      }\n      ... on ReportSchemaResponse {\n        inSeconds\n        withCoreSchema\n      }\n    }\n  }\n`;\n\n// This class is meant to be a thin shim around the gql mutations.\nexport class SchemaReporter {\n  // These mirror the gql variables\n  private readonly schemaReport: SchemaReport;\n  private readonly coreSchema: string;\n  private readonly endpointUrl: string;\n  private readonly logger: Logger;\n  private readonly initialReportingDelayInMs: number;\n  private readonly fallbackReportingDelayInMs: number;\n  private readonly fetcher: Fetcher;\n\n  private isStopped: boolean;\n  private pollTimer?: NodeJS.Timeout;\n  private readonly headers: Record<string, string>;\n\n  constructor(options: {\n    schemaReport: SchemaReport;\n    coreSchema: string;\n    apiKey: string;\n    endpointUrl: string | undefined;\n    logger: Logger;\n    initialReportingDelayInMs: number;\n    fallbackReportingDelayInMs: number;\n    fetcher?: Fetcher;\n  }) {\n    this.headers = {\n      'Content-Type': 'application/json',\n      'x-api-key': options.apiKey,\n      'apollographql-client-name': 'ApolloServerPluginSchemaReporting',\n      'apollographql-client-version': packageVersion,\n    };\n\n    this.endpointUrl =\n      options.endpointUrl ||\n      'https://schema-reporting.api.apollographql.com/api/graphql';\n\n    this.schemaReport = options.schemaReport;\n    this.coreSchema = options.coreSchema;\n    this.isStopped = false;\n    this.logger = options.logger;\n    this.initialReportingDelayInMs = options.initialReportingDelayInMs;\n    this.fallbackReportingDelayInMs = options.fallbackReportingDelayInMs;\n    this.fetcher = options.fetcher ?? fetch;\n  }\n\n  public stopped(): boolean {\n    return this.isStopped;\n  }\n\n  public start() {\n    this.pollTimer = setTimeout(\n      () => this.sendOneReportAndScheduleNext(false),\n      this.initialReportingDelayInMs,\n    );\n  }\n\n  public stop() {\n    this.isStopped = true;\n    if (this.pollTimer) {\n      clearTimeout(this.pollTimer);\n      this.pollTimer = undefined;\n    }\n  }\n\n  private async sendOneReportAndScheduleNext(sendNextWithCoreSchema: boolean) {\n    this.pollTimer = undefined;\n\n    // Bail out permanently\n    if (this.stopped()) return;\n    try {\n      const result = await this.reportSchema(sendNextWithCoreSchema);\n      if (!result) {\n        return;\n      }\n      if (!this.stopped()) {\n        this.pollTimer = setTimeout(\n          () => this.sendOneReportAndScheduleNext(result.withCoreSchema),\n          result.inSeconds * 1000,\n        );\n      }\n      return;\n    } catch (error) {\n      // In the case of an error we want to continue looping\n      // We can add hardcoded backoff in the future,\n      // or on repeated failures stop responding reporting.\n      this.logger.error(\n        `Error reporting server info to Apollo during schema reporting: ${error}`,\n      );\n      if (!this.stopped()) {\n        this.pollTimer = setTimeout(\n          () => this.sendOneReportAndScheduleNext(false),\n          this.fallbackReportingDelayInMs,\n        );\n      }\n    }\n  }\n\n  public async reportSchema(\n    withCoreSchema: boolean,\n  ): Promise<ReportSchemaResponse | null> {\n    const { data, errors } = await this.apolloQuery({\n      report: this.schemaReport,\n      coreSchema: withCoreSchema ? this.coreSchema : null,\n    });\n\n    if (errors) {\n      throw new Error(errors.map((x: any) => x.message).join('\\n'));\n    }\n\n    function msgForUnexpectedResponse(data: any): string {\n      return [\n        'Unexpected response shape from Apollo when',\n        'reporting schema. If this continues, please reach',\n        'out to support@apollographql.com.',\n        'Received response:',\n        JSON.stringify(data),\n      ].join(' ');\n    }\n\n    if (!data || !data.reportSchema) {\n      throw new Error(msgForUnexpectedResponse(data));\n    }\n\n    if (data.reportSchema.__typename === 'ReportSchemaResponse') {\n      return data.reportSchema;\n    } else if (data.reportSchema.__typename === 'ReportSchemaError') {\n      this.logger.error(\n        [\n          'Received input validation error from Apollo:',\n          data.reportSchema.message,\n          'Stopping reporting. Please fix the input errors.',\n        ].join(' '),\n      );\n      this.stop();\n      return null;\n    }\n    throw new Error(msgForUnexpectedResponse(data));\n  }\n\n  private async apolloQuery(\n    variables: SchemaReportMutationVariables,\n  ): Promise<{ data?: SchemaReportMutation; errors?: any[] }> {\n    const request: GraphQLRequest = {\n      query: schemaReportGql,\n      variables,\n    };\n\n    const httpResponse = await this.fetcher(this.endpointUrl, {\n      method: 'POST',\n      headers: this.headers,\n      body: JSON.stringify(request),\n    });\n\n    if (!httpResponse.ok) {\n      throw new Error(\n        [\n          `An unexpected HTTP status code (${httpResponse.status}) was`,\n          'encountered during schema reporting.',\n        ].join(' '),\n      );\n    }\n\n    try {\n      // JSON parsing failure due to malformed data is the likely failure case\n      // here.  Any non-JSON response (e.g. HTML) is usually the suspect.\n      return await httpResponse.json();\n    } catch (error) {\n      throw new Error(\n        [\n          \"Couldn't report schema to Apollo.\",\n          'Parsing response as JSON failed.',\n          'If this continues please reach out to support@apollographql.com',\n          error,\n        ].join(' '),\n      );\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5326, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5331, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/plugin/schemaReporting/index.ts"],"sourcesContent":["import os from 'os';\nimport { internalPlugin } from '../../internalPlugin.js';\nimport { v4 as uuidv4 } from 'uuid';\nimport { printSchema, validateSchema, buildSchema } from 'graphql';\nimport { SchemaReporter } from './schemaReporter.js';\nimport { schemaIsSubgraph } from '../schemaIsSubgraph.js';\nimport type { SchemaReport } from './generated/operations.js';\nimport type { ApolloServerPlugin } from '../../externalTypes/index.js';\nimport type { Fetcher } from '@apollo/utils.fetcher';\nimport { packageVersion } from '../../generated/packageVersion.js';\nimport { computeCoreSchemaHash } from '../../utils/computeCoreSchemaHash.js';\n\nexport interface ApolloServerPluginSchemaReportingOptions {\n  /**\n   * The schema reporter waits before starting reporting.\n   * By default, the report waits some random amount of time between 0 and 10 seconds.\n   * A longer interval leads to more staggered starts which means it is less likely\n   * multiple servers will get asked to upload the same schema.\n   *\n   * If this server runs in lambda or in other constrained environments it would be useful\n   * to decrease the schema reporting max wait time to be less than default.\n   *\n   * This number will be the max for the range in ms that the schema reporter will\n   * wait before starting to report.\n   */\n  initialDelayMaxMs?: number;\n  /**\n   * Override the reported schema that is reported to the Apollo registry. This\n   * schema does not go through any normalizations and the string is directly\n   * sent to the Apollo registry. This can be useful for comments or other\n   * ordering and whitespace changes that get stripped when generating a\n   * `GraphQLSchema`.\n   *\n   * **If you pass this option to this plugin, you should explicitly configure\n   * `ApolloServerPluginUsageReporting` and pass the same value to its\n   * `overrideReportedSchema` option.** This ensures that the schema ID\n   * associated with requests reported by the usage reporting plugin matches the\n   * schema ID that this plugin reports. For example:\n   *\n   * ```js\n   * new ApolloServer({\n   *   plugins: [\n   *     ApolloServerPluginSchemaReporting({overrideReportedSchema: schema}),\n   *     ApolloServerPluginUsageReporting({overrideReportedSchema: schema}),\n   *   ],\n   * })\n   * ```\n   */\n  overrideReportedSchema?: string;\n  /**\n   * The URL to use for reporting schemas. Primarily for testing and internal\n   * Apollo use.\n   */\n  endpointUrl?: string;\n  /**\n   * Specifies which Fetch API implementation to use when reporting schemas.\n   */\n  fetcher?: Fetcher;\n}\n\nexport function ApolloServerPluginSchemaReporting(\n  {\n    initialDelayMaxMs,\n    overrideReportedSchema,\n    endpointUrl,\n    fetcher,\n  }: ApolloServerPluginSchemaReportingOptions = Object.create(null),\n): ApolloServerPlugin {\n  const bootId = uuidv4();\n\n  return internalPlugin({\n    __internal_plugin_id__: 'SchemaReporting',\n    __is_disabled_plugin__: false,\n    async serverWillStart({ apollo, schema, logger }) {\n      const { key, graphRef } = apollo;\n      if (!key) {\n        throw Error(\n          'To use ApolloServerPluginSchemaReporting, you must provide an Apollo API ' +\n            'key, via the APOLLO_KEY environment variable or via `new ApolloServer({apollo: {key})`',\n        );\n      }\n      if (!graphRef) {\n        // This error is a bit imprecise as you can also specify ID and variant separately,\n        // or rely on API-key parsing (before AS3), but this is \"best practices\".\n        throw Error(\n          'To use ApolloServerPluginSchemaReporting, you must provide your graph ref (eg, ' +\n            \"'my-graph-id@my-graph-variant'). Try setting the APOLLO_GRAPH_REF environment \" +\n            'variable or passing `new ApolloServer({apollo: {graphRef}})`.',\n        );\n      }\n\n      // Ensure a provided override schema can be parsed and validated\n      if (overrideReportedSchema) {\n        try {\n          const validationErrors = validateSchema(\n            buildSchema(overrideReportedSchema, { noLocation: true }),\n          );\n          if (validationErrors.length) {\n            throw new Error(\n              validationErrors.map((error) => error.message).join('\\n'),\n            );\n          }\n        } catch (err) {\n          throw new Error(\n            'The schema provided to overrideReportedSchema failed to parse or ' +\n              `validate: ${(err as Error).message}`,\n          );\n        }\n      }\n\n      if (schemaIsSubgraph(schema)) {\n        throw Error(\n          [\n            'Schema reporting is not yet compatible with Apollo Federation subgraphs.',\n            \"If you're interested in using schema reporting with subgraphs,\",\n            'please contact Apollo support. To set up managed federation, see',\n            'https://go.apollo.dev/s/managed-federation',\n          ].join(' '),\n        );\n      }\n\n      if (endpointUrl !== undefined) {\n        logger.info(\n          `Apollo schema reporting: schema reporting URL override: ${endpointUrl}`,\n        );\n      }\n\n      const baseSchemaReport: Omit<SchemaReport, 'coreSchemaHash'> = {\n        bootId,\n        graphRef,\n        // The infra environment in which this edge server is running, e.g. localhost, Kubernetes\n        // Length must be <= 256 characters.\n        platform: process.env.APOLLO_SERVER_PLATFORM || 'local',\n        runtimeVersion: `node ${process.version}`,\n        // An identifier used to distinguish the version of the server code such as git or docker sha.\n        // Length must be <= 256 characters\n        userVersion: process.env.APOLLO_SERVER_USER_VERSION,\n        // \"An identifier for the server instance. Length must be <= 256 characters.\n        serverId:\n          process.env.APOLLO_SERVER_ID || process.env.HOSTNAME || os.hostname(),\n        libraryVersion: `@apollo/server@${packageVersion}`,\n      };\n      let currentSchemaReporter: SchemaReporter | undefined;\n\n      return {\n        schemaDidLoadOrUpdate({ apiSchema, coreSupergraphSdl }): void {\n          if (overrideReportedSchema !== undefined) {\n            if (currentSchemaReporter) {\n              // When the schema to report has been overridden, there is no need\n              // to create a new schema reporter.\n              return;\n            } else {\n              logger.info(\n                'Apollo schema reporting: schema to report has been overridden',\n              );\n            }\n          }\n\n          const coreSchema =\n            overrideReportedSchema ??\n            coreSupergraphSdl ??\n            printSchema(apiSchema);\n          const coreSchemaHash = computeCoreSchemaHash(coreSchema);\n          const schemaReport: SchemaReport = {\n            ...baseSchemaReport,\n            coreSchemaHash,\n          };\n\n          currentSchemaReporter?.stop();\n          currentSchemaReporter = new SchemaReporter({\n            schemaReport,\n            coreSchema,\n            apiKey: key,\n            endpointUrl,\n            logger,\n            // Jitter the startup between 0 and 10 seconds\n            initialReportingDelayInMs: Math.floor(\n              Math.random() * (initialDelayMaxMs ?? 10_000),\n            ),\n            fallbackReportingDelayInMs: 20_000,\n            fetcher,\n          });\n          currentSchemaReporter.start();\n\n          logger.info(\n            'Apollo schema reporting: reporting a new schema to Studio! See your graph at ' +\n              `https://studio.apollographql.com/graph/${encodeURI(\n                graphRef,\n              )}/ with server info ${JSON.stringify(schemaReport)}`,\n          );\n        },\n        async serverWillStop() {\n          currentSchemaReporter?.stop();\n        },\n      };\n    },\n  });\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5432, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5437, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/plugin/inlineTrace/index.ts"],"sourcesContent":["import { Trace } from '@apollo/usage-reporting-protobuf';\nimport { TraceTreeBuilder } from '../traceTreeBuilder.js';\nimport type { SendErrorsOptions } from '../usageReporting/index.js';\nimport { internalPlugin } from '../../internalPlugin.js';\nimport { schemaIsSubgraph } from '../schemaIsSubgraph.js';\nimport type { ApolloServerPlugin } from '../../externalTypes/index.js';\n\nexport interface ApolloServerPluginInlineTraceOptions {\n  /**\n   * By default, if a trace contains errors, the errors are included in the\n   * trace with the message `<masked>`. The errors are associated with specific\n   * paths in the operation, but do not include the original error message or\n   * any extensions such as the error `code`, as those details may contain your\n   * users' private data. The extension `maskedBy:\n   * 'ApolloServerPluginInlineTrace'` is added.\n   *\n   * If you'd like details about the error included in traces, set this option.\n   * This option can take several forms:\n   *\n   * - { masked: true }: mask error messages and omit extensions (DEFAULT)\n   * - { unmodified: true }: include all error messages and extensions\n   * - { transform: ... }: a custom function for transforming errors. This\n   *   function receives a `GraphQLError` and may return a `GraphQLError`\n   *   (either a new error, or its potentially-modified argument) or `null`.\n   *   This error is used in the trace; if `null`, the error is not included in\n   *   traces or error statistics.\n   */\n  includeErrors?: SendErrorsOptions;\n  /**\n   * This option is for internal use by `@apollo/server` only.\n   *\n   * By default we want to enable this plugin for subgraph schemas only, but we\n   * need to come up with our list of plugins before we have necessarily loaded\n   * the schema. So (unless the user installs this plugin or\n   * ApolloServerPluginInlineTraceDisabled themselves), `@apollo/server` always\n   * installs this plugin and uses this option to make sure traces are only\n   * included if the schema appears to be a subgraph.\n   */\n  __onlyIfSchemaIsSubgraph?: boolean;\n}\n\n// This ftv1 plugin produces a base64'd Trace protobuf containing only the\n// durationNs, startTime, endTime, and root fields.  This output is placed\n// on the `extensions`.`ftv1` property of the response.  The Apollo Gateway\n// utilizes this data to construct the full trace and submit it to Apollo's\n// usage reporting ingress.\nexport function ApolloServerPluginInlineTrace(\n  options: ApolloServerPluginInlineTraceOptions = Object.create(null),\n): ApolloServerPlugin {\n  let enabled: boolean | null = options.__onlyIfSchemaIsSubgraph ? null : true;\n  return internalPlugin({\n    __internal_plugin_id__: 'InlineTrace',\n    __is_disabled_plugin__: false,\n    async serverWillStart({ schema, logger }) {\n      // Handle the case that the plugin was implicitly installed. We only want it\n      // to actually be active if the schema appears to be federated. If you don't\n      // like the log line, just install `ApolloServerPluginInlineTrace()` in\n      // `plugins` yourself.\n      if (enabled === null) {\n        enabled = schemaIsSubgraph(schema);\n        if (enabled) {\n          logger.info(\n            'Enabling inline tracing for this subgraph. To disable, use ' +\n              'ApolloServerPluginInlineTraceDisabled.',\n          );\n        }\n      }\n    },\n    async requestDidStart({ request: { http }, metrics }) {\n      if (!enabled) {\n        return;\n      }\n\n      const treeBuilder = new TraceTreeBuilder({\n        maskedBy: 'ApolloServerPluginInlineTrace',\n        sendErrors: options.includeErrors,\n      });\n\n      // XXX Provide a mechanism to customize this logic.\n      if (http?.headers.get('apollo-federation-include-trace') !== 'ftv1') {\n        return;\n      }\n\n      // If some other (user-written?) plugin already decided that we are not\n      // capturing traces, then we should not capture traces.\n      if (metrics.captureTraces === false) {\n        return;\n      }\n\n      // Note that this will override any `fieldLevelInstrumentation` parameter\n      // to the usage reporting plugin for requests with the\n      // `apollo-federation-include-trace` header set.\n      metrics.captureTraces = true;\n\n      treeBuilder.startTiming();\n\n      return {\n        async executionDidStart() {\n          return {\n            willResolveField({ info }) {\n              return treeBuilder.willResolveField(info);\n            },\n          };\n        },\n\n        async didEncounterErrors({ errors }) {\n          treeBuilder.didEncounterErrors(errors);\n        },\n\n        async willSendResponse({ response }) {\n          // We record the end time at the latest possible time: right before serializing the trace.\n          // If we wait any longer, the time we record won't actually be sent anywhere!\n          treeBuilder.stopTiming();\n\n          // For now, we don't support inline traces on incremental delivery\n          // responses. (We could perhaps place the trace on the final chunk, or\n          // even deliver it bit by bit. For now, since Gateway does not support\n          // incremental delivery and Router does not pass through defers to\n          // subgraphs, this doesn't affect the \"federated tracing\" use case,\n          // though it does affect the ability to look at inline traces in other\n          // tools like Explorer.\n          if (response.body.kind === 'incremental') {\n            return;\n          }\n\n          // If we're in a gateway, include the query plan (and subgraph traces)\n          // in the inline trace. This is designed more for manually querying\n          // your graph while running locally to see what the query planner is\n          // doing rather than for running in production.\n          if (metrics.queryPlanTrace) {\n            treeBuilder.trace.queryPlan = metrics.queryPlanTrace;\n          }\n\n          const encodedUint8Array = Trace.encode(treeBuilder.trace).finish();\n          const encodedBuffer = Buffer.from(\n            encodedUint8Array,\n            encodedUint8Array.byteOffset,\n            encodedUint8Array.byteLength,\n          );\n\n          const extensions =\n            response.body.singleResult.extensions ||\n            (response.body.singleResult.extensions = Object.create(null));\n\n          // This should only happen if another plugin is using the same name-\n          // space within the `extensions` object and got to it before us.\n          if (typeof extensions.ftv1 !== 'undefined') {\n            throw new Error('The `ftv1` extension was already present.');\n          }\n\n          extensions.ftv1 = encodedBuffer.toString('base64');\n        },\n      };\n    },\n  });\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5507, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5512, "column": 0}, "map": {"version":3,"file":"getEmbeddedHTML.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/plugin/landingPage/default/getEmbeddedHTML.ts"],"sourcesContent":["import type {\n  ApolloServerPluginEmbeddedLandingPageLocalDefaultOptions,\n  ApolloServerPluginEmbeddedLandingPageProductionDefaultOptions,\n} from './types';\n\n// This function turns an object into a string and replaces\n// <, >, &, ' with their unicode chars to avoid adding html tags to\n// the landing page html that might be passed from the config.\n// The only place these characters can appear in the output of\n// JSON.stringify is within string literals, where they can equally\n// well appear \\u-escaped. This specifically means that\n// `</script>` won't terminate the script block early.\n// (Perhaps we should have done this instead of the triple-encoding\n// of encodeConfig for the main landing page.)\nfunction getConfigStringForHtml(config: object) {\n  return JSON.stringify(config)\n    .replace('<', '\\\\u003c')\n    .replace('>', '\\\\u003e')\n    .replace('&', '\\\\u0026')\n    .replace(\"'\", '\\\\u0027');\n}\n\nexport const getEmbeddedExplorerHTML = (\n  explorerCdnVersion: string,\n  config: ApolloServerPluginEmbeddedLandingPageProductionDefaultOptions,\n  apolloServerVersion: string,\n  nonce: string,\n) => {\n  interface EmbeddableExplorerOptions {\n    graphRef: string;\n    target: string;\n\n    initialState?: {\n      document?: string;\n      variables?: Record<string, any>;\n      headers?: Record<string, string>;\n      collectionId?: string;\n      operationId?: string;\n      displayOptions: {\n        docsPanelState?: 'open' | 'closed'; // default to 'open',\n        showHeadersAndEnvVars?: boolean; // default to `false`\n        theme?: 'dark' | 'light';\n      };\n    };\n    persistExplorerState?: boolean; // defaults to 'false'\n\n    endpointUrl: string;\n\n    includeCookies?: boolean; // defaults to 'false'\n\n    runTelemetry?: boolean;\n\n    allowDynamicStyles?: boolean; // defaults to 'true'\n  }\n  const productionLandingPageEmbedConfigOrDefault = {\n    displayOptions: {},\n    persistExplorerState: false,\n    runTelemetry: true,\n    ...(typeof config.embed === 'boolean' ? {} : config.embed),\n  };\n  const embeddedExplorerParams: Omit<\n    EmbeddableExplorerOptions,\n    'endpointUrl'\n  > & { runtime: string } = {\n    graphRef: config.graphRef,\n    target: '#embeddableExplorer',\n    initialState: {\n      ...('document' in config || 'headers' in config || 'variables' in config\n        ? {\n            document: config.document,\n            headers: config.headers,\n            variables: config.variables,\n          }\n        : {}),\n      ...('collectionId' in config\n        ? {\n            collectionId: config.collectionId,\n            operationId: config.operationId,\n          }\n        : {}),\n      displayOptions: {\n        ...productionLandingPageEmbedConfigOrDefault.displayOptions,\n      },\n    },\n    persistExplorerState:\n      productionLandingPageEmbedConfigOrDefault.persistExplorerState,\n    includeCookies: config.includeCookies,\n    runtime: apolloServerVersion,\n    runTelemetry: productionLandingPageEmbedConfigOrDefault.runTelemetry,\n    allowDynamicStyles: false, // disabled for CSP - we add the iframe styles ourselves instead\n  };\n\n  return `\n<div class=\"fallback\">\n  <h1>Welcome to Apollo Server</h1>\n  <p>Apollo Explorer cannot be loaded; it appears that you might be offline.</p>\n</div>\n<style nonce=${nonce}>\n  iframe {\n    background-color: white;\n    height: 100%;\n    width: 100%;\n    border: none;\n  }\n  #embeddableExplorer {\n    width: 100vw;\n    height: 100vh;\n    position: absolute;\n    top: 0;\n  }\n</style>\n<div id=\"embeddableExplorer\"></div>\n<script nonce=\"${nonce}\" src=\"https://embeddable-explorer.cdn.apollographql.com/${encodeURIComponent(\n    explorerCdnVersion,\n  )}/embeddable-explorer.umd.production.min.js?runtime=${encodeURIComponent(\n    apolloServerVersion,\n  )}\"></script>\n<script nonce=\"${nonce}\">\n  var endpointUrl = window.location.href;\n  var embeddedExplorerConfig = ${getConfigStringForHtml(\n    embeddedExplorerParams,\n  )};\n  new window.EmbeddedExplorer({\n    ...embeddedExplorerConfig,\n    endpointUrl,\n  });\n</script>\n`;\n};\n\nexport const getEmbeddedSandboxHTML = (\n  sandboxCdnVersion: string,\n  config: ApolloServerPluginEmbeddedLandingPageLocalDefaultOptions,\n  apolloServerVersion: string,\n  nonce: string,\n) => {\n  const localDevelopmentEmbedConfigOrDefault = {\n    runTelemetry: true,\n    endpointIsEditable: false,\n    initialState: {},\n    ...(typeof config.embed === 'boolean' ? {} : (config.embed ?? {})),\n  };\n  const embeddedSandboxConfig = {\n    target: '#embeddableSandbox',\n    initialState: {\n      ...('document' in config || 'headers' in config || 'variables' in config\n        ? {\n            document: config.document,\n            variables: config.variables,\n            headers: config.headers,\n          }\n        : {}),\n      ...('collectionId' in config\n        ? {\n            collectionId: config.collectionId,\n            operationId: config.operationId,\n          }\n        : {}),\n      includeCookies: config.includeCookies,\n      ...localDevelopmentEmbedConfigOrDefault.initialState,\n    },\n    hideCookieToggle: false,\n    endpointIsEditable: localDevelopmentEmbedConfigOrDefault.endpointIsEditable,\n    runtime: apolloServerVersion,\n    runTelemetry: localDevelopmentEmbedConfigOrDefault.runTelemetry,\n    allowDynamicStyles: false, // disabled for CSP - we add the iframe styles ourselves instead\n  };\n  return `\n<div class=\"fallback\">\n  <h1>Welcome to Apollo Server</h1>\n  <p>Apollo Sandbox cannot be loaded; it appears that you might be offline.</p>\n</div>\n<style nonce=${nonce}>\n  iframe {\n    background-color: white;\n    height: 100%;\n    width: 100%;\n    border: none;\n  }\n  #embeddableSandbox {\n    width: 100vw;\n    height: 100vh;\n    position: absolute;\n    top: 0;\n  }\n</style>\n<div id=\"embeddableSandbox\"></div>\n<script nonce=\"${nonce}\" src=\"https://embeddable-sandbox.cdn.apollographql.com/${encodeURIComponent(\n    sandboxCdnVersion,\n  )}/embeddable-sandbox.umd.production.min.js?runtime=${encodeURIComponent(\n    apolloServerVersion,\n  )}\"></script>\n<script nonce=\"${nonce}\">\n  var initialEndpoint = window.location.href;\n  var embeddedSandboxConfig = ${getConfigStringForHtml(embeddedSandboxConfig)};\n  new window.EmbeddedSandbox(\n    {\n      ...embeddedSandboxConfig,\n      initialEndpoint,\n    }\n  );\n</script>\n`;\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5644, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5649, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/plugin/landingPage/default/index.ts"],"sourcesContent":["import type {\n  ApolloServerPlugin,\n  BaseContext,\n} from '../../../externalTypes/index.js';\nimport type { ImplicitlyInstallablePlugin } from '../../../ApolloServer.js';\nimport type {\n  ApolloServerPluginLandingPageLocalDefaultOptions,\n  ApolloServerPluginLandingPageProductionDefaultOptions,\n  LandingPageConfig,\n} from './types.js';\nimport {\n  getEmbeddedExplorerHTML,\n  getEmbeddedSandboxHTML,\n} from './getEmbeddedHTML.js';\nimport { packageVersion } from '../../../generated/packageVersion.js';\nimport { createHash } from '@apollo/utils.createhash';\nimport { v4 as uuidv4 } from 'uuid';\n\nexport type {\n  ApolloServerPluginLandingPageLocalDefaultOptions,\n  ApolloServerPluginLandingPageProductionDefaultOptions,\n};\n\nexport function ApolloServerPluginLandingPageLocalDefault(\n  options: ApolloServerPluginLandingPageLocalDefaultOptions = {},\n): ApolloServerPlugin {\n  const { version, __internal_apolloStudioEnv__, ...rest } = {\n    // we default to Sandbox unless embed is specified as false\n    embed: true as const,\n    ...options,\n  };\n  return ApolloServerPluginLandingPageDefault(version, {\n    isProd: false,\n    apolloStudioEnv: __internal_apolloStudioEnv__,\n    ...rest,\n  });\n}\n\nexport function ApolloServerPluginLandingPageProductionDefault(\n  options: ApolloServerPluginLandingPageProductionDefaultOptions = {},\n): ApolloServerPlugin {\n  const { version, __internal_apolloStudioEnv__, ...rest } = options;\n  return ApolloServerPluginLandingPageDefault(version, {\n    isProd: true,\n    apolloStudioEnv: __internal_apolloStudioEnv__,\n    ...rest,\n  });\n}\n\n// A triple encoding! Wow! First we use JSON.stringify to turn our object into a\n// string. Then we encodeURIComponent so we don't have to stress about what\n// would happen if the config contained `</script>`. Finally, we JSON.stringify\n// it again, which in practice just wraps it in a pair of double quotes (since\n// there shouldn't be any backslashes left after encodeURIComponent). The\n// consumer of this needs to decodeURIComponent and then JSON.parse; there's\n// only one JSON.parse because the outermost JSON string is parsed by the JS\n// parser itself.\nfunction encodeConfig(config: LandingPageConfig): string {\n  return JSON.stringify(encodeURIComponent(JSON.stringify(config)));\n}\n\nconst getNonEmbeddedLandingPageHTML = (\n  cdnVersion: string,\n  config: LandingPageConfig,\n  apolloServerVersion: string,\n  nonce: string,\n) => {\n  const encodedConfig = encodeConfig(config);\n\n  return `\n <div class=\"fallback\">\n  <h1>Welcome to Apollo Server</h1>\n  <p>The full landing page cannot be loaded; it appears that you might be offline.</p>\n</div>\n<script nonce=\"${nonce}\">window.landingPage = ${encodedConfig};</script>\n<script nonce=\"${nonce}\" src=\"https://apollo-server-landing-page.cdn.apollographql.com/${encodeURIComponent(\n    cdnVersion,\n  )}/static/js/main.js?runtime=${apolloServerVersion}\"></script>`;\n};\n\nexport const DEFAULT_EMBEDDED_EXPLORER_VERSION = 'v3';\nexport const DEFAULT_EMBEDDED_SANDBOX_VERSION = 'v2';\nexport const DEFAULT_APOLLO_SERVER_LANDING_PAGE_VERSION = '_latest';\n\n// Helper for the two actual plugin functions.\nfunction ApolloServerPluginLandingPageDefault<TContext extends BaseContext>(\n  maybeVersion: string | undefined,\n  config: LandingPageConfig & {\n    isProd: boolean;\n    apolloStudioEnv: 'staging' | 'prod' | undefined;\n  },\n): ImplicitlyInstallablePlugin<TContext> {\n  const explorerVersion = maybeVersion ?? DEFAULT_EMBEDDED_EXPLORER_VERSION;\n  const sandboxVersion = maybeVersion ?? DEFAULT_EMBEDDED_SANDBOX_VERSION;\n  const apolloServerLandingPageVersion =\n    maybeVersion ?? DEFAULT_APOLLO_SERVER_LANDING_PAGE_VERSION;\n  const apolloServerVersion = `@apollo/server@${packageVersion}`;\n\n  const scriptSafeList = [\n    'https://apollo-server-landing-page.cdn.apollographql.com',\n    'https://embeddable-sandbox.cdn.apollographql.com',\n    'https://embeddable-explorer.cdn.apollographql.com',\n  ].join(' ');\n  const styleSafeList = [\n    'https://apollo-server-landing-page.cdn.apollographql.com',\n    'https://embeddable-sandbox.cdn.apollographql.com',\n    'https://embeddable-explorer.cdn.apollographql.com',\n    'https://fonts.googleapis.com',\n  ].join(' ');\n  const iframeSafeList = [\n    'https://explorer.embed.apollographql.com',\n    'https://sandbox.embed.apollographql.com',\n    'https://embed.apollo.local:3000',\n  ].join(' ');\n\n  return {\n    __internal_installed_implicitly__: false,\n    async serverWillStart(server) {\n      if (config.precomputedNonce) {\n        server.logger.warn(\n          \"The `precomputedNonce` landing page configuration option is deprecated. Removing this option is strictly an improvement to Apollo Server's landing page Content Security Policy (CSP) implementation for preventing XSS attacks.\",\n        );\n      }\n      return {\n        async renderLandingPage() {\n          const encodedASLandingPageVersion = encodeURIComponent(\n            apolloServerLandingPageVersion,\n          );\n          async function html() {\n            const nonce =\n              config.precomputedNonce ??\n              createHash('sha256').update(uuidv4()).digest('hex');\n            const scriptCsp = `script-src 'self' 'nonce-${nonce}' ${scriptSafeList}`;\n            const styleCsp = `style-src 'nonce-${nonce}' ${styleSafeList}`;\n            const imageCsp = `img-src https://apollo-server-landing-page.cdn.apollographql.com`;\n            const manifestCsp = `manifest-src https://apollo-server-landing-page.cdn.apollographql.com`;\n            const frameCsp = `frame-src ${iframeSafeList}`;\n            return `\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta http-equiv=\"Content-Security-Policy\" content=\"${scriptCsp}; ${styleCsp}; ${imageCsp}; ${manifestCsp}; ${frameCsp}\" />\n    <link\n      rel=\"icon\"\n      href=\"https://apollo-server-landing-page.cdn.apollographql.com/${encodedASLandingPageVersion}/assets/favicon.png\"\n    />\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n    <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" />\n    <link\n      href=\"https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap\"\n      rel=\"stylesheet\"\n    />\n    <meta name=\"theme-color\" content=\"#000000\" />\n    <meta name=\"description\" content=\"Apollo server landing page\" />\n    <link\n      rel=\"apple-touch-icon\"\n      href=\"https://apollo-server-landing-page.cdn.apollographql.com/${encodedASLandingPageVersion}/assets/favicon.png\"\n    />\n    <link\n      rel=\"manifest\"\n      href=\"https://apollo-server-landing-page.cdn.apollographql.com/${encodedASLandingPageVersion}/manifest.json\"\n    />\n    <title>Apollo Server</title>\n  </head>\n  <body>\n    <noscript>You need to enable JavaScript to run this app.</noscript>\n    <div id=\"react-root\">\n      <style nonce=${nonce}>\n        body {\n          margin: 0;\n          overflow-x: hidden;\n          overflow-y: hidden;\n        }\n        .fallback {\n          opacity: 0;\n          animation: fadeIn 1s 1s;\n          animation-iteration-count: 1;\n          animation-fill-mode: forwards;\n          padding: 1em;\n        }\n        @keyframes fadeIn {\n          0% {opacity:0;}\n          100% {opacity:1; }\n        }\n      </style>\n    ${\n      config.embed\n        ? 'graphRef' in config && config.graphRef\n          ? getEmbeddedExplorerHTML(\n              explorerVersion,\n              config,\n              apolloServerVersion,\n              nonce,\n            )\n          : !('graphRef' in config)\n            ? getEmbeddedSandboxHTML(\n                sandboxVersion,\n                config,\n                apolloServerVersion,\n                nonce,\n              )\n            : getNonEmbeddedLandingPageHTML(\n                apolloServerLandingPageVersion,\n                config,\n                apolloServerVersion,\n                nonce,\n              )\n        : getNonEmbeddedLandingPageHTML(\n            apolloServerLandingPageVersion,\n            config,\n            apolloServerVersion,\n            nonce,\n          )\n    }\n    </div>\n  </body>\n</html>\n          `;\n          }\n          return { html };\n        },\n      };\n    },\n  };\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5795, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5800, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/plugin/disableSuggestions/index.ts"],"sourcesContent":["import type { ApolloServerPlugin } from '../../externalTypes/index.js';\nimport { internalPlugin } from '../../internalPlugin.js';\n\nexport function ApolloServerPluginDisableSuggestions(): ApolloServerPlugin {\n  return internalPlugin({\n    __internal_plugin_id__: 'DisableSuggestions',\n    __is_disabled_plugin__: false,\n    async requestDidStart() {\n      return {\n        async validationDidStart() {\n          return async (validationErrors) => {\n            validationErrors?.forEach((error) => {\n              error.message = error.message.replace(\n                / ?Did you mean(.+?)\\?$/,\n                '',\n              );\n            });\n          };\n        },\n      };\n    },\n  });\n}\n"],"names":[],"mappings":";;;;;AACA,MAAA,yDAAyD;AAEzD,SAAgB,oCAAoC;IAClD,OAAO,CAAA,GAAA,oBAAA,cAAc,EAAC;QACpB,sBAAsB,EAAE,oBAAoB;QAC5C,sBAAsB,EAAE,KAAK;QAC7B,KAAK,CAAC,eAAe;YACnB,OAAO;gBACL,KAAK,CAAC,kBAAkB;oBACtB,OAAO,KAAK,EAAE,gBAAgB,EAAE,EAAE;wBAChC,gBAAgB,EAAE,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;4BAClC,KAAK,CAAC,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC,OAAO,CACnC,wBAAwB,EACxB,EAAE,CACH,CAAC;wBACJ,CAAC,CAAC,CAAC;oBACL,CAAC,CAAC;gBACJ,CAAC;aACF,CAAC;QACJ,CAAC;KACF,CAAC,CAAC;AACL,CAAC;AAnBD,QAAA,oCAAA,GAAA,qCAmBC","ignoreList":[0]}},
    {"offset": {"line": 5824, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5829, "column": 0}, "map": {"version":3,"file":"ApolloServer.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/ApolloServer.ts"],"sourcesContent":["import type { GatewayExecutor } from '@apollo/server-gateway-interface';\nimport { isNodeLike } from '@apollo/utils.isnodelike';\nimport {\n  InMemoryLRUCache,\n  PrefixingKeyValueCache,\n  type KeyValueCache,\n} from '@apollo/utils.keyvaluecache';\nimport type { Logger } from '@apollo/utils.logger';\nimport type { WithRequired } from '@apollo/utils.withrequired';\nimport { makeExecutableSchema } from '@graphql-tools/schema';\nimport resolvable, { type Resolvable } from './utils/resolvable.js';\nimport {\n  GraphQLError,\n  assertValidSchema,\n  print,\n  printSchema,\n  type DocumentNode,\n  type FormattedExecutionResult,\n  type GraphQLFieldResolver,\n  type GraphQLFormattedError,\n  type GraphQLSchema,\n  type ParseOptions,\n  type TypedQueryDocumentNode,\n  type ValidationContext,\n  type ValidationRule,\n} from 'graphql';\nimport loglevel from 'loglevel';\nimport Negotiator from 'negotiator';\nimport { newCachePolicy } from './cachePolicy.js';\nimport { determineApolloConfig } from './determineApolloConfig.js';\nimport {\n  ensureError,\n  ensureGraphQLError,\n  normalizeAndFormatErrors,\n} from './errorNormalize.js';\nimport {\n  ApolloServerErrorCode,\n  ApolloServerValidationErrorCode,\n} from './errors/index.js';\nimport type { ApolloServerOptionsWithStaticSchema } from './externalTypes/constructor.js';\nimport type {\n  ExecuteOperationOptions,\n  VariableValues,\n} from './externalTypes/graphql.js';\nimport type {\n  ApolloConfig,\n  ApolloServerOptions,\n  ApolloServerPlugin,\n  BaseContext,\n  ContextThunk,\n  DocumentStore,\n  GraphQLRequest,\n  GraphQLRequestContext,\n  GraphQLResponse,\n  GraphQLServerContext,\n  GraphQLServerListener,\n  HTTPGraphQLHead,\n  HTTPGraphQLRequest,\n  HTTPGraphQLResponse,\n  LandingPage,\n  PersistedQueryOptions,\n} from './externalTypes/index.js';\nimport { runPotentiallyBatchedHttpQuery } from './httpBatching.js';\nimport type { GraphQLExperimentalIncrementalExecutionResults } from './incrementalDeliveryPolyfill.js';\nimport { pluginIsInternal, type InternalPluginId } from './internalPlugin.js';\nimport {\n  preventCsrf,\n  recommendedCsrfPreventionRequestHeaders,\n} from './preventCsrf.js';\nimport { APQ_CACHE_PREFIX, processGraphQLRequest } from './requestPipeline.js';\nimport { newHTTPGraphQLHead, prettyJSONStringify } from './runHttpQuery.js';\nimport { HeaderMap } from './utils/HeaderMap.js';\nimport { UnreachableCaseError } from './utils/UnreachableCaseError.js';\nimport { computeCoreSchemaHash } from './utils/computeCoreSchemaHash.js';\nimport { isDefined } from './utils/isDefined.js';\nimport { SchemaManager } from './utils/schemaManager.js';\n\nconst NoIntrospection: ValidationRule = (context: ValidationContext) => ({\n  Field(node) {\n    if (node.name.value === '__schema' || node.name.value === '__type') {\n      context.reportError(\n        new GraphQLError(\n          'GraphQL introspection is not allowed by Apollo Server, but the query contained __schema or __type. To enable introspection, pass introspection: true to ApolloServer in production',\n          {\n            nodes: [node],\n            extensions: {\n              validationErrorCode:\n                ApolloServerValidationErrorCode.INTROSPECTION_DISABLED,\n            },\n          },\n        ),\n      );\n    }\n  },\n});\n\nexport type SchemaDerivedData = {\n  schema: GraphQLSchema;\n  // A store that, when enabled (default), will store the parsed and validated\n  // versions of operations in-memory, allowing subsequent parses/validates\n  // on the same operation to be executed immediately.\n  documentStore: DocumentStore | null;\n  // Prefix for keys in the DocumentStore if a custom one is provided (to\n  // separate the cache for different schema versions). This is vital to\n  // security so we do it explicitly so that\n  // PrefixingKeyValueCache.cacheDangerouslyDoesNotNeedPrefixesForIsolation\n  // doesn't affect it.\n  documentStoreKeyPrefix: string;\n};\n\ntype RunningServerState = {\n  schemaManager: SchemaManager;\n  landingPage: LandingPage | null;\n};\n\ntype ServerState =\n  | {\n      phase: 'initialized';\n      schemaManager: SchemaManager;\n    }\n  | {\n      phase: 'starting';\n      barrier: Resolvable<void>;\n      schemaManager: SchemaManager;\n      // This is set to true if you called\n      // startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests\n      // instead of start. The main purpose is that assertStarted allows you to\n      // still be in the starting phase if this is set. (This is the serverless\n      // use case.)\n      startedInBackground: boolean;\n    }\n  | {\n      phase: 'failed to start';\n      error: Error;\n    }\n  | ({\n      phase: 'started';\n      drainServers: (() => Promise<void>) | null;\n      toDispose: (() => Promise<void>)[];\n      toDisposeLast: (() => Promise<void>)[];\n    } & RunningServerState)\n  | ({\n      phase: 'draining';\n      barrier: Resolvable<void>;\n    } & RunningServerState)\n  | {\n      phase: 'stopping';\n      barrier: Resolvable<void>;\n    }\n  | {\n      phase: 'stopped';\n      stopError: Error | null;\n    };\n\nexport interface ApolloServerInternals<TContext extends BaseContext> {\n  state: ServerState;\n  gatewayExecutor: GatewayExecutor | null;\n  dangerouslyDisableValidation?: boolean;\n  formatError?: (\n    formattedError: GraphQLFormattedError,\n    error: unknown,\n  ) => GraphQLFormattedError;\n  includeStacktraceInErrorResponses: boolean;\n  persistedQueries?: WithRequired<PersistedQueryOptions, 'cache'>;\n  nodeEnv: string;\n  allowBatchedHttpRequests: boolean;\n  apolloConfig: ApolloConfig;\n  plugins: ApolloServerPlugin<TContext>[];\n  parseOptions: ParseOptions;\n  // `undefined` means we figure out what to do during _start (because\n  // the default depends on whether or not we used the background version\n  // of start).\n  stopOnTerminationSignals: boolean | undefined;\n  csrfPreventionRequestHeaders: string[] | null;\n\n  rootValue?: ((parsedQuery: DocumentNode) => unknown) | unknown;\n  validationRules: Array<ValidationRule>;\n  hideSchemaDetailsFromClientErrors: boolean;\n  fieldResolver?: GraphQLFieldResolver<any, TContext>;\n  // TODO(AS5): remove OR warn + ignore with this option set, ignore option and\n  // flip default behavior.\n  status400ForVariableCoercionErrors?: boolean;\n  __testing_incrementalExecutionResults?: GraphQLExperimentalIncrementalExecutionResults;\n  stringifyResult: (\n    value: FormattedExecutionResult,\n  ) => string | Promise<string>;\n}\n\nfunction defaultLogger(): Logger {\n  const loglevelLogger = loglevel.getLogger('apollo-server');\n  loglevelLogger.setLevel(loglevel.levels.INFO);\n  return loglevelLogger;\n}\n\n// We really want to prevent this from being legal:\n//\n//     const s: ApolloServer<{}> =\n//       new ApolloServer<{importantContextField: boolean}>({ ... });\n//     s.executeOperation({query}, {contextValue: {}});\n//\n// ie, if you declare an ApolloServer whose context values must be of a certain\n// type, you can't assign it to a variable whose context values are less\n// constrained and then pass in a context value missing important fields.\n//\n// We also want this to be illegal:\n//\n//     const sBase = new ApolloServer<{}>({ ... });\n//     const s: ApolloServer<{importantContextField: boolean}> = sBase;\n//     s.addPlugin({async requestDidStart({contextValue: {importantContextField}}) { ... }})\n//     sBase.executeOperation({query}, {contextValue: {}});\n//\n// so you shouldn't be able to assign an ApolloServer to a variable whose\n// context values are more constrained, either. So we want to declare that\n// ApolloServer is *invariant* in TContext, which we do with `in out` (a\n// TypeScript 4.7 feature).\nexport class ApolloServer<in out TContext extends BaseContext = BaseContext> {\n  private internals: ApolloServerInternals<TContext>;\n\n  public readonly cache: KeyValueCache<string>;\n  public readonly logger: Logger;\n\n  constructor(config: ApolloServerOptions<TContext>) {\n    const nodeEnv = config.nodeEnv ?? process.env.NODE_ENV ?? '';\n\n    this.logger = config.logger ?? defaultLogger();\n\n    const apolloConfig = determineApolloConfig(config.apollo, this.logger);\n\n    const isDev = nodeEnv !== 'production';\n\n    if (\n      config.cache &&\n      config.cache !== 'bounded' &&\n      PrefixingKeyValueCache.prefixesAreUnnecessaryForIsolation(config.cache)\n    ) {\n      throw new Error(\n        'You cannot pass a cache returned from ' +\n          '`PrefixingKeyValueCache.cacheDangerouslyDoesNotNeedPrefixesForIsolation`' +\n          'to `new ApolloServer({ cache })`, because Apollo Server may use it for ' +\n          'multiple features whose cache keys must be distinct from each other.',\n      );\n    }\n\n    const state: ServerState = config.gateway\n      ? // ApolloServer has been initialized but we have not yet tried to load the\n        // schema from the gateway. That will wait until `start()` or\n        // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests()`\n        // is called. (These may be called by other helpers; for example,\n        // `standaloneServer` calls `start` for you inside its `listen` method,\n        // and a serverless framework integration would call\n        // startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests\n        // for you.)\n        {\n          phase: 'initialized',\n          schemaManager: new SchemaManager({\n            gateway: config.gateway,\n            apolloConfig,\n            schemaDerivedDataProvider: (schema) =>\n              ApolloServer.generateSchemaDerivedData(\n                schema,\n                config.documentStore,\n              ),\n            logger: this.logger,\n          }),\n        }\n      : // We construct the schema synchronously so that we can fail fast if the\n        // schema can't be constructed. (This used to be more important because we\n        // used to have a 'schema' field that was publicly accessible immediately\n        // after construction, though that field never actually worked with\n        // gateways.)\n        {\n          phase: 'initialized',\n          schemaManager: new SchemaManager({\n            apiSchema: ApolloServer.constructSchema(config),\n            schemaDerivedDataProvider: (schema) =>\n              ApolloServer.generateSchemaDerivedData(\n                schema,\n                config.documentStore,\n              ),\n            logger: this.logger,\n          }),\n        };\n\n    const introspectionEnabled = config.introspection ?? isDev;\n    const hideSchemaDetailsFromClientErrors =\n      config.hideSchemaDetailsFromClientErrors ?? false;\n\n    // We continue to allow 'bounded' for backwards-compatibility with the AS3.9\n    // API.\n    this.cache =\n      config.cache === undefined || config.cache === 'bounded'\n        ? new InMemoryLRUCache()\n        : config.cache;\n\n    // Note that we avoid calling methods on `this` before `this.internals` is assigned\n    // (thus a bunch of things being static methods above).\n    this.internals = {\n      formatError: config.formatError,\n      rootValue: config.rootValue,\n      validationRules: [\n        ...(config.validationRules ?? []),\n        ...(introspectionEnabled ? [] : [NoIntrospection]),\n      ],\n      hideSchemaDetailsFromClientErrors,\n      dangerouslyDisableValidation:\n        config.dangerouslyDisableValidation ?? false,\n      fieldResolver: config.fieldResolver,\n      includeStacktraceInErrorResponses:\n        config.includeStacktraceInErrorResponses ??\n        (nodeEnv !== 'production' && nodeEnv !== 'test'),\n      persistedQueries:\n        config.persistedQueries === false\n          ? undefined\n          : {\n              ...config.persistedQueries,\n              cache: new PrefixingKeyValueCache(\n                config.persistedQueries?.cache ?? this.cache,\n                APQ_CACHE_PREFIX,\n              ),\n            },\n      nodeEnv,\n      allowBatchedHttpRequests: config.allowBatchedHttpRequests ?? false,\n      apolloConfig,\n      // Note that more plugins can be added before `start()` with `addPlugin()`\n      // (eg, plugins that want to take this ApolloServer as an argument), and\n      // `start()` will call `addDefaultPlugins` to add default plugins.\n      plugins: config.plugins ?? [],\n      parseOptions: config.parseOptions ?? {},\n      state,\n      stopOnTerminationSignals: config.stopOnTerminationSignals,\n\n      gatewayExecutor: null, // set by _start\n\n      csrfPreventionRequestHeaders:\n        config.csrfPrevention === true || config.csrfPrevention === undefined\n          ? recommendedCsrfPreventionRequestHeaders\n          : config.csrfPrevention === false\n            ? null\n            : (config.csrfPrevention.requestHeaders ??\n              recommendedCsrfPreventionRequestHeaders),\n      status400ForVariableCoercionErrors:\n        config.status400ForVariableCoercionErrors ?? false,\n      __testing_incrementalExecutionResults:\n        config.__testing_incrementalExecutionResults,\n      stringifyResult: config.stringifyResult ?? prettyJSONStringify,\n    };\n  }\n\n  // Awaiting a call to `start` ensures that a schema has been loaded and that\n  // all plugin `serverWillStart` hooks have been called. If either of these\n  // processes throw, `start` will (async) throw as well.\n  //\n  // If you're using `standaloneServer`, you don't need to call `start` yourself\n  // (in fact, it will throw if you do so); its `listen` method takes care of\n  // that for you.\n  //\n  // If instead you're using an integration package for a non-serverless\n  // framework (like Express), you must await a call to `start` immediately\n  // after creating your `ApolloServer`, before attaching it to your web\n  // framework and starting to accept requests. `start` should only be called\n  // once; if it throws and you'd like to retry, just create another\n  // `ApolloServer`. (Calling `start` was optional in Apollo Server 2, but in\n  // Apollo Server 3+ the functions like `expressMiddleware` use `assertStarted`\n  // to throw if `start` hasn't successfully completed.)\n  //\n  // Serverless integrations like Lambda do not support calling `start()`,\n  // because their lifecycle doesn't allow you to wait before assigning a\n  // handler or allowing the handler to be called. So they call\n  // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests()`\n  // instead, and don't really differentiate between startup failures and\n  // request failures. This is hopefully appropriate for a \"serverless\"\n  // framework. Serverless startup failures result in returning a redacted error\n  // to the end user and logging the more detailed error.\n  public async start(): Promise<void> {\n    return await this._start(false);\n  }\n\n  public startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests(): void {\n    this._start(true).catch((e) => this.logStartupError(e));\n  }\n\n  private async _start(startedInBackground: boolean): Promise<void> {\n    if (this.internals.state.phase !== 'initialized') {\n      // If we wanted we could make this error detectable and change\n      // `standaloneServer` to change the message to say not to call start() at\n      // all.\n      throw new Error(\n        `You should only call 'start()' or ` +\n          `'startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests()' ` +\n          `once on your ApolloServer.`,\n      );\n    }\n    const schemaManager = this.internals.state.schemaManager;\n    const barrier = resolvable();\n    this.internals.state = {\n      phase: 'starting',\n      barrier,\n      schemaManager,\n      startedInBackground,\n    };\n    try {\n      // Now that you can't call addPlugin any more, add default plugins like\n      // usage reporting if they're not already added.\n      await this.addDefaultPlugins();\n\n      const toDispose: (() => Promise<void>)[] = [];\n      const executor = await schemaManager.start();\n      if (executor) {\n        this.internals.gatewayExecutor = executor;\n      }\n      toDispose.push(async () => {\n        await schemaManager.stop();\n      });\n\n      const schemaDerivedData = schemaManager.getSchemaDerivedData();\n      const service: GraphQLServerContext = {\n        logger: this.logger,\n        cache: this.cache,\n        schema: schemaDerivedData.schema,\n        apollo: this.internals.apolloConfig,\n        startedInBackground,\n      };\n\n      const taggedServerListeners = (\n        await Promise.all(\n          this.internals.plugins.map(async (plugin) => ({\n            serverListener:\n              plugin.serverWillStart && (await plugin.serverWillStart(service)),\n            installedImplicitly:\n              isImplicitlyInstallablePlugin(plugin) &&\n              plugin.__internal_installed_implicitly__,\n          })),\n        )\n      ).filter(\n        (\n          maybeTaggedServerListener,\n        ): maybeTaggedServerListener is {\n          serverListener: GraphQLServerListener;\n          installedImplicitly: boolean;\n        } => typeof maybeTaggedServerListener.serverListener === 'object',\n      );\n\n      taggedServerListeners.forEach(\n        ({ serverListener: { schemaDidLoadOrUpdate } }) => {\n          if (schemaDidLoadOrUpdate) {\n            schemaManager.onSchemaLoadOrUpdate(schemaDidLoadOrUpdate);\n          }\n        },\n      );\n\n      const serverWillStops = taggedServerListeners\n        .map((l) => l.serverListener.serverWillStop)\n        .filter(isDefined);\n      if (serverWillStops.length) {\n        toDispose.push(async () => {\n          await Promise.all(\n            serverWillStops.map((serverWillStop) => serverWillStop()),\n          );\n        });\n      }\n\n      const drainServerCallbacks = taggedServerListeners\n        .map((l) => l.serverListener.drainServer)\n        .filter(isDefined);\n      const drainServers = drainServerCallbacks.length\n        ? async () => {\n            await Promise.all(\n              drainServerCallbacks.map((drainServer) => drainServer()),\n            );\n          }\n        : null;\n\n      // Find the renderLandingPage callback, if one is provided. If the user\n      // installed ApolloServerPluginLandingPageDisabled then there may be none\n      // found. On the other hand, if the user installed a landingPage plugin,\n      // then both the implicit installation of\n      // ApolloServerPluginLandingPage*Default and the other plugin will be\n      // found; we skip the implicit plugin.\n      let taggedServerListenersWithRenderLandingPage =\n        taggedServerListeners.filter((l) => l.serverListener.renderLandingPage);\n      if (taggedServerListenersWithRenderLandingPage.length > 1) {\n        taggedServerListenersWithRenderLandingPage =\n          taggedServerListenersWithRenderLandingPage.filter(\n            (l) => !l.installedImplicitly,\n          );\n      }\n      let landingPage: LandingPage | null = null;\n      if (taggedServerListenersWithRenderLandingPage.length > 1) {\n        throw Error('Only one plugin can implement renderLandingPage.');\n      } else if (taggedServerListenersWithRenderLandingPage.length) {\n        landingPage =\n          await taggedServerListenersWithRenderLandingPage[0].serverListener\n            .renderLandingPage!();\n      }\n\n      const toDisposeLast = this.maybeRegisterTerminationSignalHandlers(\n        ['SIGINT', 'SIGTERM'],\n        startedInBackground,\n      );\n\n      this.internals.state = {\n        phase: 'started',\n        schemaManager,\n        drainServers,\n        landingPage,\n        toDispose,\n        toDisposeLast,\n      };\n    } catch (maybeError: unknown) {\n      const error = ensureError(maybeError);\n\n      try {\n        await Promise.all(\n          this.internals.plugins.map(async (plugin) =>\n            plugin.startupDidFail?.({ error }),\n          ),\n        );\n      } catch (pluginError) {\n        this.logger.error(`startupDidFail hook threw: ${pluginError}`);\n      }\n\n      this.internals.state = {\n        phase: 'failed to start',\n        error,\n      };\n      throw error;\n    } finally {\n      barrier.resolve();\n    }\n  }\n\n  private maybeRegisterTerminationSignalHandlers(\n    signals: NodeJS.Signals[],\n    startedInBackground: boolean,\n  ): (() => Promise<void>)[] {\n    const toDisposeLast: (() => Promise<void>)[] = [];\n\n    // We handle signals if it was explicitly requested\n    // (stopOnTerminationSignals === true), or if we're in Node, not in a test,\n    // not in a serverless framework (which we guess based on whether they\n    // called\n    // startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests),\n    // and it wasn't explicitly turned off. (We only actually register the\n    // signal handlers once we've successfully started up, because there's\n    // nothing to stop otherwise.)\n    if (\n      this.internals.stopOnTerminationSignals === false ||\n      (this.internals.stopOnTerminationSignals === undefined &&\n        !(\n          isNodeLike &&\n          this.internals.nodeEnv !== 'test' &&\n          !startedInBackground\n        ))\n    ) {\n      return toDisposeLast;\n    }\n\n    let receivedSignal = false;\n    const signalHandler: NodeJS.SignalsListener = async (signal) => {\n      if (receivedSignal) {\n        // If we receive another SIGINT or SIGTERM while we're waiting\n        // for the server to stop, just ignore it.\n        return;\n      }\n      receivedSignal = true;\n      try {\n        await this.stop();\n      } catch (e) {\n        this.logger.error(`stop() threw during ${signal} shutdown`);\n        this.logger.error(e);\n        // Can't rely on the signal handlers being removed.\n        process.exit(1);\n      }\n      // Note: this.stop will call the toDisposeLast handlers below, so at\n      // this point this handler will have been removed and we can re-kill\n      // ourself to die with the appropriate signal exit status. this.stop\n      // takes care to call toDisposeLast last, so the signal handler isn't\n      // removed until after the rest of shutdown happens.\n      process.kill(process.pid, signal);\n    };\n\n    signals.forEach((signal) => {\n      process.on(signal, signalHandler);\n      toDisposeLast.push(async () => {\n        process.removeListener(signal, signalHandler);\n      });\n    });\n    return toDisposeLast;\n  }\n\n  // This method is called at the beginning of each GraphQL request by\n  // `executeHTTPGraphQLRequest` and `executeOperation`. Most of its logic is\n  // only helpful if you started the server in the background (ie, for\n  // serverless frameworks): unless you're in a serverless framework, you should\n  // have called `await server.start()` before the server got to the point of\n  // running GraphQL requests (`assertStarted` calls in the framework\n  // integrations verify that) and so the only cases for non-serverless\n  // frameworks that this should hit are 'started', 'stopping', and 'stopped'.\n  // But if you started the server in the background (with\n  // startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests), this\n  // lets the server wait until fully started before serving operations.\n  private async _ensureStarted(): Promise<RunningServerState> {\n    while (true) {\n      switch (this.internals.state.phase) {\n        case 'initialized':\n          // This error probably won't happen: serverless framework integrations\n          // should call\n          // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests`\n          // for you, and other frameworks call `assertStarted` before setting\n          // things up enough to make calling this function possible.\n          throw new Error(\n            'You need to call `server.start()` before using your Apollo Server.',\n          );\n        case 'starting':\n          await this.internals.state.barrier;\n          // continue the while loop\n          break;\n        case 'failed to start':\n          // First we log the error that prevented startup (which means it will\n          // get logged once for every GraphQL operation).\n          this.logStartupError(this.internals.state.error);\n          // Now make the operation itself fail.\n          // We intentionally do not re-throw actual startup error as it may contain\n          // implementation details and this error will propagate to the client.\n          throw new Error(\n            'This data graph is missing a valid configuration. More details may be available in the server logs.',\n          );\n        case 'started':\n        case 'draining': // We continue to run operations while draining.\n          return this.internals.state;\n        case 'stopping':\n        case 'stopped':\n          this.logger.warn(\n            'A GraphQL operation was received during server shutdown. The ' +\n              'operation will fail. Consider draining the HTTP server on shutdown; ' +\n              'see https://go.apollo.dev/s/drain for details.',\n          );\n          throw new Error(\n            `Cannot execute GraphQL operations ${\n              this.internals.state.phase === 'stopping'\n                ? 'while the server is stopping'\n                : 'after the server has stopped'\n            }.'`,\n          );\n        default:\n          throw new UnreachableCaseError(this.internals.state);\n      }\n    }\n  }\n\n  // Framework integrations should call this to ensure that you've properly\n  // started your server before you get anywhere close to actually listening for\n  // incoming requests.\n  //\n  // There's a special case that if you called\n  // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests` and\n  // it hasn't finished starting up yet, this works too. This is intended for\n  // cases like a serverless integration (say, Google Cloud Functions) that\n  // calls\n  // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests` for\n  // you and then immediately sets up an integration based on another middleware\n  // like `expressMiddleware` which calls this function. We'd like this to be\n  // OK, but we still want normal Express users to start their ApolloServer\n  // before setting up their HTTP server unless they know what they are doing\n  // well enough to call the function with the long name themselves.\n  public assertStarted(expressionForError: string) {\n    if (\n      this.internals.state.phase !== 'started' &&\n      this.internals.state.phase !== 'draining' &&\n      !(\n        this.internals.state.phase === 'starting' &&\n        this.internals.state.startedInBackground\n      )\n    ) {\n      throw new Error(\n        'You must `await server.start()` before calling `' +\n          expressionForError +\n          '`',\n      );\n    }\n  }\n\n  // Given an error that occurred during Apollo Server startup, log it with a\n  // helpful message. This should happen when you call\n  // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests` (ie,\n  // in serverless frameworks); with other frameworks, you must `await\n  // server.start()` which will throw the startup error directly instead of\n  // logging. This gets called both immediately when the startup error happens,\n  // and on all subsequent requests.\n  private logStartupError(err: Error) {\n    this.logger.error(\n      'An error occurred during Apollo Server startup. All GraphQL requests ' +\n        'will now fail. The startup error was: ' +\n        (err?.message || err),\n    );\n  }\n\n  private static constructSchema<TContext extends BaseContext>(\n    config: ApolloServerOptionsWithStaticSchema<TContext>,\n  ): GraphQLSchema {\n    if (config.schema) {\n      return config.schema;\n    }\n\n    const { typeDefs, resolvers } = config;\n    const augmentedTypeDefs = Array.isArray(typeDefs) ? typeDefs : [typeDefs];\n\n    // For convenience, we allow you to pass a few options that we pass through\n    // to a particular version of `@graphql-tools/schema`'s\n    // `makeExecutableSchema`. If you want to use more of this function's\n    // features or have more control over the version of the packages used, just\n    // call it yourself like `new ApolloServer({schema:\n    // makeExecutableSchema(...)})`.\n    return makeExecutableSchema({\n      typeDefs: augmentedTypeDefs,\n      resolvers,\n    });\n  }\n\n  private static generateSchemaDerivedData(\n    schema: GraphQLSchema,\n    // null means don't use a documentStore at all.\n    // missing/undefined means use the default (creating a new one each\n    // time).\n    // defined means wrap this one in a random prefix for each new schema.\n    providedDocumentStore: DocumentStore | null | undefined,\n  ): SchemaDerivedData {\n    // Instead of waiting for the first operation execution against the schema\n    // to find out if it's a valid schema or not, check right now. In the\n    // non-gateway case, if this throws then the `new ApolloServer` call will\n    // throw. In the gateway case if this throws then it will log a message and\n    // just not update the schema (although oddly the message will claim that\n    // the schema is updating).\n    assertValidSchema(schema);\n\n    return {\n      schema,\n      // The DocumentStore is schema-derived because we put documents in it\n      // after checking that they pass GraphQL validation against the schema and\n      // use this to skip validation as well as parsing. So we can't reuse the\n      // same DocumentStore for different schemas because that might make us\n      // treat invalid operations as valid. If we're using the default\n      // DocumentStore, then we just create it from scratch each time we get a\n      // new schema. If we're using a user-provided DocumentStore, then we use\n      // the schema hash as a prefix.\n      documentStore:\n        providedDocumentStore === undefined\n          ? new InMemoryLRUCache<DocumentNode>()\n          : providedDocumentStore,\n      documentStoreKeyPrefix: providedDocumentStore\n        ? `${computeCoreSchemaHash(printSchema(schema))}:`\n        : '',\n    };\n  }\n\n  public async stop() {\n    switch (this.internals.state.phase) {\n      case 'initialized':\n      case 'starting':\n      case 'failed to start':\n        throw Error(\n          'apolloServer.stop() should only be called after `await apolloServer.start()` has succeeded',\n        );\n\n      // Calling stop more than once should have the same result as the first time.\n      case 'stopped':\n        if (this.internals.state.stopError) {\n          throw this.internals.state.stopError;\n        }\n        return;\n\n      // Two parallel calls to stop; just wait for the other one to finish and\n      // do whatever it did.\n      case 'stopping':\n      case 'draining': {\n        await this.internals.state.barrier;\n        // The cast here is because TS doesn't understand that this.state can\n        // change during the await\n        // (https://github.com/microsoft/TypeScript/issues/9998).\n        const state = this.internals.state as ServerState;\n        if (state.phase !== 'stopped') {\n          throw Error(`Surprising post-stopping state ${state.phase}`);\n        }\n        if (state.stopError) {\n          throw state.stopError;\n        }\n        return;\n      }\n\n      case 'started':\n        // This is handled by the rest of the function.\n        break;\n\n      default:\n        throw new UnreachableCaseError(this.internals.state);\n    }\n\n    const barrier = resolvable();\n\n    const {\n      schemaManager,\n      drainServers,\n      landingPage,\n      toDispose,\n      toDisposeLast,\n    } = this.internals.state;\n\n    // Commit to stopping and start draining servers.\n    this.internals.state = {\n      phase: 'draining',\n      barrier,\n      schemaManager,\n      landingPage,\n    };\n\n    try {\n      await drainServers?.();\n\n      // Servers are drained. Prevent further operations from starting and call\n      // stop handlers.\n      this.internals.state = { phase: 'stopping', barrier };\n\n      // We run shutdown handlers in two phases because we don't want to turn\n      // off our signal listeners (ie, allow signals to kill the process) until\n      // we've done the important parts of shutdown like running serverWillStop\n      // handlers. (We can make this more generic later if it's helpful.)\n      await Promise.all([...toDispose].map((dispose) => dispose()));\n      await Promise.all([...toDisposeLast].map((dispose) => dispose()));\n    } catch (stopError) {\n      this.internals.state = {\n        phase: 'stopped',\n        stopError: stopError as Error,\n      };\n      barrier.resolve();\n      throw stopError;\n    }\n    this.internals.state = { phase: 'stopped', stopError: null };\n  }\n\n  private async addDefaultPlugins() {\n    const {\n      plugins,\n      apolloConfig,\n      nodeEnv,\n      hideSchemaDetailsFromClientErrors,\n    } = this.internals;\n    const isDev = nodeEnv !== 'production';\n\n    const alreadyHavePluginWithInternalId = (id: InternalPluginId) =>\n      plugins.some(\n        (p) => pluginIsInternal(p) && p.__internal_plugin_id__ === id,\n      );\n\n    // Make sure we're not trying to explicitly enable and disable the same\n    // feature. (Be careful: we are not trying to stop people from installing\n    // the same plugin twice if they have a use case for it, like two usage\n    // reporting plugins for different variants.)\n    //\n    // Note that this check doesn't work for the landing page plugin, because\n    // users can write their own landing page plugins and we don't know if a\n    // given plugin is a landing page plugin until the server has started.\n    const pluginsByInternalID = new Map<\n      InternalPluginId,\n      { sawDisabled: boolean; sawNonDisabled: boolean }\n    >();\n    for (const p of plugins) {\n      if (pluginIsInternal(p)) {\n        const id = p.__internal_plugin_id__;\n        if (!pluginsByInternalID.has(id)) {\n          pluginsByInternalID.set(id, {\n            sawDisabled: false,\n            sawNonDisabled: false,\n          });\n        }\n        const seen = pluginsByInternalID.get(id)!;\n        if (p.__is_disabled_plugin__) {\n          seen.sawDisabled = true;\n        } else {\n          seen.sawNonDisabled = true;\n        }\n\n        if (seen.sawDisabled && seen.sawNonDisabled) {\n          throw new Error(\n            `You have tried to install both ApolloServerPlugin${id} and ` +\n              `ApolloServerPlugin${id}Disabled in your server. Please choose ` +\n              `whether or not you want to disable the feature and install the ` +\n              `appropriate plugin for your use case.`,\n          );\n        }\n      }\n    }\n\n    // Special case: cache control is on unless you explicitly disable it.\n    {\n      if (!alreadyHavePluginWithInternalId('CacheControl')) {\n        const { ApolloServerPluginCacheControl } = await import(\n          './plugin/cacheControl/index.js'\n        );\n        plugins.push(ApolloServerPluginCacheControl());\n      }\n    }\n\n    // Special case: usage reporting is on by default (and first!) if you\n    // configure an API key.\n    {\n      const alreadyHavePlugin =\n        alreadyHavePluginWithInternalId('UsageReporting');\n      if (!alreadyHavePlugin && apolloConfig.key) {\n        if (apolloConfig.graphRef) {\n          // Keep this plugin first so it wraps everything. (Unfortunately despite\n          // the fact that the person who wrote this line also was the original\n          // author of the comment above in #1105, they don't quite understand why this was important.)\n          const { ApolloServerPluginUsageReporting } = await import(\n            './plugin/usageReporting/index.js'\n          );\n          plugins.unshift(\n            ApolloServerPluginUsageReporting({\n              __onlyIfSchemaIsNotSubgraph: true,\n            }),\n          );\n        } else {\n          this.logger.warn(\n            'You have specified an Apollo key but have not specified a graph ref; usage ' +\n              'reporting is disabled. To enable usage reporting, set the `APOLLO_GRAPH_REF` ' +\n              'environment variable to `your-graph-id@your-graph-variant`. To disable this ' +\n              'warning, install `ApolloServerPluginUsageReportingDisabled`.',\n          );\n        }\n      }\n    }\n\n    // Special case: schema reporting can be turned on via environment variable.\n    {\n      const alreadyHavePlugin =\n        alreadyHavePluginWithInternalId('SchemaReporting');\n      const enabledViaEnvVar = process.env.APOLLO_SCHEMA_REPORTING === 'true';\n      if (!alreadyHavePlugin && enabledViaEnvVar) {\n        if (apolloConfig.key) {\n          const { ApolloServerPluginSchemaReporting } = await import(\n            './plugin/schemaReporting/index.js'\n          );\n          plugins.push(ApolloServerPluginSchemaReporting());\n        } else {\n          throw new Error(\n            \"You've enabled schema reporting by setting the APOLLO_SCHEMA_REPORTING \" +\n              'environment variable to true, but you also need to provide your ' +\n              'Apollo API key, via the APOLLO_KEY environment ' +\n              'variable or via `new ApolloServer({apollo: {key})',\n          );\n        }\n      }\n    }\n\n    // Special case: inline tracing is on by default for federated schemas.\n    {\n      const alreadyHavePlugin = alreadyHavePluginWithInternalId('InlineTrace');\n      if (!alreadyHavePlugin) {\n        // If we haven't explicitly disabled inline tracing via\n        // ApolloServerPluginInlineTraceDisabled or explicitly installed our own\n        // ApolloServerPluginInlineTrace, we set up inline tracing in \"only if\n        // federated\" mode.  (This is slightly different than the\n        // pre-ApolloServerPluginInlineTrace where we would also avoid doing\n        // this if an API key was configured and log a warning.)\n        const { ApolloServerPluginInlineTrace } = await import(\n          './plugin/inlineTrace/index.js'\n        );\n        plugins.push(\n          ApolloServerPluginInlineTrace({ __onlyIfSchemaIsSubgraph: true }),\n        );\n      }\n    }\n\n    // Special case: If we're not in production, show our default landing page.\n    //\n    // This works a bit differently from the other implicitly installed plugins,\n    // which rely entirely on the __internal_plugin_id__ to decide whether the\n    // plugin takes effect. That's because we want third-party plugins to be\n    // able to provide a landing page that overrides the default landing page,\n    // without them having to know about __internal_plugin_id__. So unless we\n    // actively disable the default landing page with\n    // ApolloServerPluginLandingPageDisabled, we install the default landing\n    // page, but with a special flag that _start() uses to ignore it if some\n    // other plugin defines a renderLandingPage callback. (We can't just look\n    // now to see if the plugin defines renderLandingPage because we haven't run\n    // serverWillStart yet.)\n    const alreadyHavePlugin = alreadyHavePluginWithInternalId(\n      'LandingPageDisabled',\n    );\n    if (!alreadyHavePlugin) {\n      const {\n        ApolloServerPluginLandingPageLocalDefault,\n        ApolloServerPluginLandingPageProductionDefault,\n      } = await import('./plugin/landingPage/default/index.js');\n      const plugin: ApolloServerPlugin<TContext> = isDev\n        ? ApolloServerPluginLandingPageLocalDefault()\n        : ApolloServerPluginLandingPageProductionDefault();\n      if (!isImplicitlyInstallablePlugin(plugin)) {\n        throw Error(\n          'default landing page plugin should be implicitly installable?',\n        );\n      }\n      plugin.__internal_installed_implicitly__ = true;\n      plugins.push(plugin);\n    }\n\n    {\n      const alreadyHavePlugin =\n        alreadyHavePluginWithInternalId('DisableSuggestions');\n      if (hideSchemaDetailsFromClientErrors && !alreadyHavePlugin) {\n        const { ApolloServerPluginDisableSuggestions } = await import(\n          './plugin/disableSuggestions/index.js'\n        );\n        plugins.push(ApolloServerPluginDisableSuggestions());\n      }\n    }\n  }\n\n  public addPlugin(plugin: ApolloServerPlugin<TContext>) {\n    if (this.internals.state.phase !== 'initialized') {\n      throw new Error(\"Can't add plugins after the server has started\");\n    }\n    this.internals.plugins.push(plugin);\n  }\n\n  public async executeHTTPGraphQLRequest({\n    httpGraphQLRequest,\n    context,\n  }: {\n    httpGraphQLRequest: HTTPGraphQLRequest;\n    context: ContextThunk<TContext>;\n  }): Promise<HTTPGraphQLResponse> {\n    try {\n      let runningServerState;\n      try {\n        runningServerState = await this._ensureStarted();\n      } catch (error: unknown) {\n        // This is typically either the masked error from when background startup\n        // failed, or related to invoking this function before startup or\n        // during/after shutdown (due to lack of draining).\n        return await this.errorResponse(error, httpGraphQLRequest);\n      }\n\n      if (\n        runningServerState.landingPage &&\n        this.prefersHTML(httpGraphQLRequest)\n      ) {\n        let renderedHtml;\n        if (typeof runningServerState.landingPage.html === 'string') {\n          renderedHtml = runningServerState.landingPage.html;\n        } else {\n          try {\n            renderedHtml = await runningServerState.landingPage.html();\n          } catch (maybeError: unknown) {\n            const error = ensureError(maybeError);\n            this.logger.error(`Landing page \\`html\\` function threw: ${error}`);\n            return await this.errorResponse(error, httpGraphQLRequest);\n          }\n        }\n\n        return {\n          headers: new HeaderMap([['content-type', 'text/html']]),\n          body: {\n            kind: 'complete',\n            string: renderedHtml,\n          },\n        };\n      }\n\n      // If enabled, check to ensure that this request was preflighted before doing\n      // anything real (such as running the context function).\n      if (this.internals.csrfPreventionRequestHeaders) {\n        preventCsrf(\n          httpGraphQLRequest.headers,\n          this.internals.csrfPreventionRequestHeaders,\n        );\n      }\n\n      let contextValue: TContext;\n      try {\n        contextValue = await context();\n      } catch (maybeError: unknown) {\n        const error = ensureError(maybeError);\n        try {\n          await Promise.all(\n            this.internals.plugins.map(async (plugin) =>\n              plugin.contextCreationDidFail?.({\n                error,\n              }),\n            ),\n          );\n        } catch (pluginError) {\n          this.logger.error(\n            `contextCreationDidFail hook threw: ${pluginError}`,\n          );\n        }\n\n        // If some random function threw, add a helpful prefix when converting\n        // to GraphQLError. If it was already a GraphQLError, trust that the\n        // message was chosen thoughtfully and leave off the prefix.\n        return await this.errorResponse(\n          ensureGraphQLError(error, 'Context creation failed: '),\n          httpGraphQLRequest,\n        );\n      }\n\n      return await runPotentiallyBatchedHttpQuery(\n        this,\n        httpGraphQLRequest,\n        contextValue,\n        runningServerState.schemaManager.getSchemaDerivedData(),\n        this.internals,\n      );\n    } catch (maybeError_: unknown) {\n      const maybeError = maybeError_; // fixes inference because catch vars are not const\n      if (\n        maybeError instanceof GraphQLError &&\n        maybeError.extensions.code === ApolloServerErrorCode.BAD_REQUEST\n      ) {\n        try {\n          await Promise.all(\n            this.internals.plugins.map(async (plugin) =>\n              plugin.invalidRequestWasReceived?.({ error: maybeError }),\n            ),\n          );\n        } catch (pluginError) {\n          this.logger.error(\n            `invalidRequestWasReceived hook threw: ${pluginError}`,\n          );\n        }\n      }\n      return await this.errorResponse(maybeError, httpGraphQLRequest);\n    }\n  }\n\n  private async errorResponse(\n    error: unknown,\n    requestHead: HTTPGraphQLHead,\n  ): Promise<HTTPGraphQLResponse> {\n    const { formattedErrors, httpFromErrors } = normalizeAndFormatErrors(\n      [error],\n      {\n        includeStacktraceInErrorResponses:\n          this.internals.includeStacktraceInErrorResponses,\n        formatError: this.internals.formatError,\n      },\n    );\n\n    return {\n      status: httpFromErrors.status ?? 500,\n      headers: new HeaderMap([\n        ...httpFromErrors.headers,\n        [\n          'content-type',\n          // Note that we may change the default to\n          // 'application/graphql-response+json' by 2025 as encouraged by the\n          // graphql-over-http spec. It's maybe a bit bad for us to provide\n          // an application/json response if they send `accept: foo/bar`,\n          // but we're already providing some sort of bad request error, and\n          // it's probably more useful for them to fix the other error before\n          // they deal with the `accept` header.\n          chooseContentTypeForSingleResultResponse(requestHead) ??\n            MEDIA_TYPES.APPLICATION_JSON,\n        ],\n      ]),\n      body: {\n        kind: 'complete',\n        string: await this.internals.stringifyResult({\n          errors: formattedErrors,\n        }),\n      },\n    };\n  }\n\n  private prefersHTML(request: HTTPGraphQLRequest): boolean {\n    const acceptHeader = request.headers.get('accept');\n    return (\n      request.method === 'GET' &&\n      !!acceptHeader &&\n      new Negotiator({\n        headers: { accept: acceptHeader },\n      }).mediaType([\n        // We need it to actively prefer text/html over less browser-y types;\n        // eg, `accept: */*' should still go for JSON. Negotiator does tiebreak\n        // by the order in the list we provide, so we put text/html last.\n        MEDIA_TYPES.APPLICATION_JSON,\n        MEDIA_TYPES.APPLICATION_GRAPHQL_RESPONSE_JSON,\n        MEDIA_TYPES.MULTIPART_MIXED_EXPERIMENTAL,\n        MEDIA_TYPES.MULTIPART_MIXED_NO_DEFER_SPEC,\n        MEDIA_TYPES.TEXT_HTML,\n      ]) === MEDIA_TYPES.TEXT_HTML\n    );\n  }\n\n  /**\n   * This method is primarily meant for testing: it allows you to execute a\n   * GraphQL operation via the request pipeline without going through the HTTP\n   * layer. Note that this means that any handling you do in your server at the\n   * HTTP level will not affect this call!\n   *\n   * For convenience, you can provide `request.query` either as a string or a\n   * DocumentNode, in case you choose to use the gql tag in your tests. This is\n   * just a convenience, not an optimization (we convert provided ASTs back into\n   * string).\n   *\n   * The second object is an optional options object which includes the optional\n   * `contextValue` object available in resolvers.\n   *\n   * You may specify the TData and TVariables generic types when calling this\n   * method; Apollo Server does not validate that the returned data actually\n   * matches the structure of TData. (Typically these types are created by a\n   * code generation tool.) Note that this does not enforce that `variables` is\n   * provided at all, just that it has the right type if provided.\n   */\n  public async executeOperation<\n    TData = Record<string, unknown>,\n    TVariables extends VariableValues = VariableValues,\n  >(\n    this: ApolloServer<BaseContext>,\n    request: Omit<GraphQLRequest<TVariables>, 'query'> & {\n      query?: string | DocumentNode | TypedQueryDocumentNode<TData, TVariables>;\n    },\n  ): Promise<GraphQLResponse<TData>>;\n  public async executeOperation<\n    TData = Record<string, unknown>,\n    TVariables extends VariableValues = VariableValues,\n  >(\n    request: Omit<GraphQLRequest<TVariables>, 'query'> & {\n      query?: string | DocumentNode | TypedQueryDocumentNode<TData, TVariables>;\n    },\n    options?: ExecuteOperationOptions<TContext>,\n  ): Promise<GraphQLResponse<TData>>;\n\n  async executeOperation<\n    TData = Record<string, unknown>,\n    TVariables extends VariableValues = VariableValues,\n  >(\n    request: Omit<GraphQLRequest<TVariables>, 'query'> & {\n      // We should consider supporting TypedDocumentNode from\n      // `@graphql-typed-document-node/core` as well, as it is more popular than\n      // the newer built-in type.\n      query?: string | DocumentNode | TypedQueryDocumentNode<TData, TVariables>;\n    },\n    options: ExecuteOperationOptions<TContext> = {},\n  ): Promise<GraphQLResponse<TData>> {\n    // Since this function is mostly for testing, you don't need to explicitly\n    // start your server before calling it. (That also means you can use it with\n    // `apollo-server` which doesn't support `start()`.)\n    if (this.internals.state.phase === 'initialized') {\n      await this.start();\n    }\n\n    const schemaDerivedData = (\n      await this._ensureStarted()\n    ).schemaManager.getSchemaDerivedData();\n\n    // For convenience, this function lets you pass either a string or an AST,\n    // but we normalize to string.\n    const graphQLRequest: GraphQLRequest = {\n      ...request,\n      query:\n        request.query && typeof request.query !== 'string'\n          ? print(request.query)\n          : request.query,\n    };\n\n    const response: GraphQLResponse = await internalExecuteOperation(\n      {\n        server: this,\n        graphQLRequest,\n        internals: this.internals,\n        schemaDerivedData,\n        sharedResponseHTTPGraphQLHead: null,\n      },\n      options,\n    );\n\n    // It's your job to set an appropriate TData (perhaps using codegen); we\n    // don't validate it.\n    return response as GraphQLResponse<TData>;\n  }\n}\n\n// Shared code between runHttpQuery (ie executeHTTPGraphQLRequest) and\n// executeOperation to set up a request context and invoke the request pipeline.\nexport async function internalExecuteOperation<TContext extends BaseContext>(\n  {\n    server,\n    graphQLRequest,\n    internals,\n    schemaDerivedData,\n    sharedResponseHTTPGraphQLHead,\n  }: {\n    server: ApolloServer<TContext>;\n    graphQLRequest: GraphQLRequest;\n    internals: ApolloServerInternals<TContext>;\n    schemaDerivedData: SchemaDerivedData;\n    sharedResponseHTTPGraphQLHead: HTTPGraphQLHead | null;\n  },\n  options: ExecuteOperationOptions<TContext>,\n): Promise<GraphQLResponse> {\n  const requestContext: GraphQLRequestContext<TContext> = {\n    logger: server.logger,\n    cache: server.cache,\n    schema: schemaDerivedData.schema,\n    request: graphQLRequest,\n    response: {\n      http: sharedResponseHTTPGraphQLHead ?? newHTTPGraphQLHead(),\n    },\n    // We clone the context because there are some assumptions that every operation\n    // execution has a brand new context object; specifically, in order to implement\n    // willResolveField we put a Symbol on the context that is specific to a particular\n    // request pipeline execution. We could avoid this if we had a better way of\n    // instrumenting execution.\n    //\n    // We don't want to do a deep clone here, because one of the main advantages of\n    // using batched HTTP requests is to share context across operations for a\n    // single request.\n    //\n    // The typecast here is safe, because the only way `contextValue` can be\n    // null-ish is if we used the `contextValue?: BaseContext` override, in\n    // which case TContext is BaseContext and {} is ok. (This does depend on\n    // the fact we've hackily forced the class to be contravariant in\n    // TContext.)\n    contextValue: cloneObject(options?.contextValue ?? ({} as TContext)),\n    metrics: {},\n    overallCachePolicy: newCachePolicy(),\n    requestIsBatched: sharedResponseHTTPGraphQLHead !== null,\n  };\n\n  try {\n    return await processGraphQLRequest(\n      schemaDerivedData,\n      server,\n      internals,\n      requestContext,\n    );\n  } catch (maybeError: unknown) {\n    // processGraphQLRequest throwing usually means that either there's a bug in\n    // Apollo Server or some plugin hook threw unexpectedly.\n    const error = ensureError(maybeError);\n    // If *these* hooks throw then we'll still get a 500 but won't mask its\n    // error.\n    await Promise.all(\n      internals.plugins.map(async (plugin) =>\n        plugin.unexpectedErrorProcessingRequest?.({\n          requestContext,\n          error,\n        }),\n      ),\n    );\n    // Mask unexpected error externally.\n    server.logger.error(`Unexpected error processing request: ${error}`);\n    throw new Error('Internal server error');\n  }\n}\n\n// Unlike InternalPlugins (where we can decide whether to install the default\n// plugin based on looking at which plugins are installed),\n// ImplicitlyInstallablePlugins (ie the default landing page plugin) can't\n// determine if they're needed until later in startup. Specifically, we can't\n// know if we've defined our own landing page until after serverWillStart\n// plugins have run.\nexport type ImplicitlyInstallablePlugin<TContext extends BaseContext> =\n  ApolloServerPlugin<TContext> & {\n    __internal_installed_implicitly__: boolean;\n  };\n\nexport function isImplicitlyInstallablePlugin<TContext extends BaseContext>(\n  p: ApolloServerPlugin<TContext>,\n): p is ImplicitlyInstallablePlugin<TContext> {\n  return '__internal_installed_implicitly__' in p;\n}\n\nexport const MEDIA_TYPES = {\n  APPLICATION_JSON: 'application/json; charset=utf-8',\n  APPLICATION_JSON_GRAPHQL_CALLBACK:\n    'application/json; callbackSpec=1.0; charset=utf-8',\n  APPLICATION_GRAPHQL_RESPONSE_JSON:\n    'application/graphql-response+json; charset=utf-8',\n  // We do *not* currently support this content-type; we will once incremental\n  // delivery is part of the official GraphQL spec.\n  MULTIPART_MIXED_NO_DEFER_SPEC: 'multipart/mixed',\n  MULTIPART_MIXED_EXPERIMENTAL: 'multipart/mixed; deferSpec=20220824',\n  TEXT_HTML: 'text/html',\n};\n\nexport function chooseContentTypeForSingleResultResponse(\n  head: HTTPGraphQLHead,\n): string | null {\n  const acceptHeader = head.headers.get('accept');\n  if (!acceptHeader) {\n    // Note that we may change the default to\n    // 'application/graphql-response+json' by 2025 as encouraged by the\n    // graphql-over-http spec.\n    return MEDIA_TYPES.APPLICATION_JSON;\n  } else {\n    const preferred = new Negotiator({\n      headers: { accept: head.headers.get('accept') },\n    }).mediaType([\n      MEDIA_TYPES.APPLICATION_JSON,\n      MEDIA_TYPES.APPLICATION_GRAPHQL_RESPONSE_JSON,\n      MEDIA_TYPES.APPLICATION_JSON_GRAPHQL_CALLBACK,\n    ]);\n    if (preferred) {\n      return preferred;\n    } else {\n      return null;\n    }\n  }\n}\n\nfunction cloneObject<T extends Object>(object: T): T {\n  return Object.assign(Object.create(Object.getPrototypeOf(object)), object);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6485, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6490, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/externalTypes/index.ts"],"sourcesContent":["/**\n * This file represents the external type definitions needed by end users,\n * integration implementors, and plugin implementors. Everything from this file\n * is re-exported by the root (via * export), so add exports to this file with\n * intention (it's public API).\n */\nexport type { BaseContext, ContextFunction, ContextThunk } from './context.js';\nexport type { GraphQLRequest, GraphQLResponse } from './graphql.js';\nexport type {\n  HTTPGraphQLRequest,\n  HTTPGraphQLResponse,\n  HTTPGraphQLHead,\n} from './http.js';\nexport type {\n  ApolloServerPlugin,\n  GraphQLFieldResolverParams,\n  GraphQLRequestExecutionListener,\n  GraphQLRequestListener,\n  GraphQLRequestListenerDidResolveField,\n  GraphQLRequestListenerExecutionDidEnd,\n  GraphQLRequestListenerParsingDidEnd,\n  GraphQLRequestListenerValidationDidEnd,\n  GraphQLSchemaContext,\n  GraphQLServerListener,\n  GraphQLServerContext,\n  LandingPage,\n} from './plugins.js';\nexport type {\n  GraphQLRequestContext,\n  GraphQLRequestMetrics,\n  GraphQLRequestContextDidEncounterErrors,\n  GraphQLRequestContextDidResolveOperation,\n  GraphQLRequestContextDidResolveSource,\n  GraphQLRequestContextExecutionDidStart,\n  GraphQLRequestContextParsingDidStart,\n  GraphQLRequestContextResponseForOperation,\n  GraphQLRequestContextValidationDidStart,\n  GraphQLRequestContextWillSendResponse,\n} from './requestPipeline.js';\nexport type {\n  DocumentStore,\n  ApolloConfigInput,\n  ApolloConfig,\n  PersistedQueryOptions,\n  CSRFPreventionOptions,\n  ApolloServerOptionsWithSchema,\n  ApolloServerOptionsWithTypeDefs,\n  ApolloServerOptionsWithStaticSchema,\n  ApolloServerOptionsWithGateway,\n  ApolloServerOptions,\n} from './constructor.js';\n\nexport type {\n  GraphQLExperimentalFormattedInitialIncrementalExecutionResult,\n  GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult,\n  GraphQLExperimentalFormattedIncrementalResult,\n  GraphQLExperimentalFormattedIncrementalDeferResult,\n  GraphQLExperimentalFormattedIncrementalStreamResult,\n} from './incrementalDeliveryPolyfill.js';\n"],"names":[],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 6494, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6499, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/oem/Desktop/lifology_BlogApp/node_modules/%40apollo/server/src/index.ts"],"sourcesContent":["export { ApolloServer } from './ApolloServer.js';\nexport { HeaderMap } from './utils/HeaderMap.js';\n// Note that this is purely a type export.\nexport * from './externalTypes/index.js';\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,iDAAiD;AAAxC,OAAA,cAAA,CAAA,SAAA,gBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,kBAAA,YAAY;IAAA;AAAA,GAAA;AACrB,IAAA,iDAAiD;AAAxC,OAAA,cAAA,CAAA,SAAA,aAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,eAAA,SAAS;IAAA;AAAA,GAAA;AAElB,sIAAA,SAAyC","ignoreList":[0]}},
    {"offset": {"line": 6538, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}